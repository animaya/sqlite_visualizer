This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
client/
  dist/
    assets/
      index-967cdcaf.js
      index-991a2c60.css
    index.html
    vite.svg
  public/
    vite.svg
  src/
    components/
      common/
        ExportButton.tsx
        Sidebar.tsx
      connection/
        ConnectionForm.tsx
        ConnectionList.tsx
      table/
        DataTable.tsx
        TableSelector.tsx
      templates/
        index.ts
        TemplateApplyButton.tsx
        TemplateCard.tsx
        TemplateConfigurator.tsx
        TemplateFieldMapper.tsx
        TemplateList.tsx
        TemplatePreview.tsx
      visualization/
        ChartPreview.tsx
        ChartRenderer.tsx
        ChartRenderer.tsx.backup
        ChartTypeSelector.tsx
        FieldMapper.tsx
    layouts/
      MainLayout.tsx
    pages/
      Connections.tsx
      NotFound.tsx
      SavedVisualizations.tsx
      SavedVisualizations.tsx.backup
      TableViewer.tsx
      TemplateApplication.tsx
      Templates.tsx
      VisualizationBuilder.tsx
    services/
      api.ts
    types/
      index.ts
    App.tsx
    config.ts
    index.css
    main.tsx
    types.ts
  .vite-port
  index.html
  package.json
  tailwind.config.js
  tsconfig.json
  tsconfig.node.json
  vite.config.ts
docs/
  data-validator.md
scripts/
  create_test_db.js
  setup-db.js
  start-dev.js
  stop-processes.js
server/
  examples/
    validationExample.js
  middleware/
    dataValidator.js
    errorHandler.js
  models/
    connection.js
    template.js
    visualization.js
  routes/
    connections.js
    export.js
    tables.js
    templates.js
    visualizations.js
  services/
    appDbService.js
    connectionService.js
    databaseService.js
    exportService.js
    templateService.js
    visualizationService.js
  utils/
    dbUtils.js
    queryBuilder.js
    responseFormatter.js
  app.js
.gitignore
CLAUDE.md
package.json
README.md
SQLite
SQLite_Visualizer_Masterplan.md
SQLite_Visualizer_Style_Guide_Design_System.md
SQLite_Visualizer_Technical_Design_Document.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="SQLite">
# SQLite Visualizer Technical Design Document

## 1. Introduction

### 1.1 Purpose
This Technical Design Document (TDD) provides detailed specifications for the SQLite Visualizer application. It serves as a comprehensive guide for the development team to implement the application according to the requirements.

### 1.2 Scope
The SQLite Visualizer is a web-based application designed to provide visual representation of SQLite database content through tabular views and charts. It is designed for a small team of 5 professionals to analyze SQLite database data without requiring SQL knowledge.

### 1.3 Definitions, Acronyms, and Abbreviations
- **UI**: User Interface
- **API**: Application Programming Interface
- **DB**: Database
- **CSV**: Comma-Separated Values
- **KPI**: Key Performance Indicator

## 2. System Architecture

### 2.1 High-Level Architecture
The application follows a client-server architecture:
- **Client**: Web browser-based interface built with Tailwind CSS and shadcn UI components
- **Server**: Deno-based backend service that communicates with SQLite databases
- **Database**: Two types of SQLite databases:
  - Target databases (read-only access for visualization)
  - Application database (for storing configurations and saved visualizations)

```
┌─────────────────┐      ┌─────────────────┐      ┌─────────────────┐
│                 │      │                 │      │  Target SQLite  │
│  Web Browser    │<────>│  Deno Server    │<────>│  Databases      │
│  (Client)       │      │  (Backend)      │      │  (Read-only)    │
└─────────────────┘      └────────┬────────┘      └─────────────────┘
                                  │
                                  ▼
                         ┌─────────────────┐
                         │  App SQLite DB  │
                         │  (Config & viz) │
                         └─────────────────┘
```

### 2.2 Component Architecture

#### 2.2.1 Frontend Components
1. **ConnectionManager**
   - Handles database connection requests
   - Displays and manages connection history
   - Performs initial database health checks

2. **TableViewer**
   - Renders database tables in a clean, filterable format
   - Provides column sorting and filtering capabilities
   - Enables selection of data for visualization

3. **VisualizationBuilder**
   - Constructs charts based on selected data
   - Provides chart type selection interface
   - Manages visualization configuration

4. **VisualizationGallery**
   - Displays saved visualizations
   - Enables management of saved configurations
   - Provides export functionality

5. **TemplateSelector**
   - Presents pre-configured insight templates
   - Maps template requirements to available data
   - Generates visualizations from templates

#### 2.2.2 Backend Components
1. **DatabaseConnector**
   - Establishes and manages SQLite database connections
   - Validates connection parameters
   - Provides database metadata

2. **QueryProcessor**
   - Executes read-only queries against target databases
   - Formats query results for frontend consumption
   - Implements pagination and data sampling for large datasets

3. **VisualizationService**
   - Processes data for chart generation
   - Manages saved visualization configurations
   - Handles visualization template processing

4. **ExportService**
   - Formats data for CSV export
   - Handles file generation and delivery

5. **ConfigurationManager**
   - Manages application settings
   - Stores and retrieves connection history
   - Handles saved visualization persistence

## 3. Detailed Technical Specifications

### 3.1 Frontend Technologies

#### 3.1.1 Core Framework
**Technology Choice**: React with optional TypeScript
**Rationale**: React offers a robust ecosystem with extensive community support and documentation. TypeScript provides type safety for more robust code.

#### 3.1.2 UI Framework
**Technology Choice**: Tailwind CSS with shadcn UI
**Rationale**: Tailwind provides utility-first CSS for rapid development, while shadcn offers pre-built accessible components that work well with Tailwind.

#### 3.1.3 State Management
**Technology Choice**: React Hooks and Context API
**Rationale**: React's built-in state management solutions provide a clean, maintainable approach without additional dependencies for an application of this size.

#### 3.1.4 Visualization Libraries
**Primary Choice**: Chart.js
**Secondary Choice**: D3.js (for any complex visualizations)
**Rationale**: Chart.js provides simple, responsive charts with good performance. D3.js can be used for more complex visualizations if needed.

### 3.2 Backend Technologies

#### 3.2.1 Runtime Environment
**Technology Choice**: Node.js
**Rationale**: Node.js is a widely-used JavaScript runtime with a mature ecosystem and extensive library support.

#### 3.2.2 Web Framework
**Technology Choice**: Express.js
**Rationale**: Express is a minimal and flexible Node.js web application framework that provides robust features for web and mobile applications.

#### 3.2.3 Database Access
**Technology Choice**: `better-sqlite3` Node.js module
**Rationale**: High-performance SQLite3 library for Node.js with prepared statements, transactions, and type-safe binding.

#### 3.2.4 API Pattern
**Technology Choice**: REST API with JSON
**Rationale**: Simple, widely understood pattern suitable for the application's needs.

### 3.3 Database Schema

#### 3.3.1 Application Database

```sql
-- Database Connections Table
CREATE TABLE connections (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    path TEXT NOT NULL,
    last_accessed TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    size_bytes INTEGER,
    table_count INTEGER,
    is_valid BOOLEAN DEFAULT 1
);

-- Saved Visualizations Table
CREATE TABLE saved_visualizations (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    connection_id INTEGER,
    name TEXT NOT NULL,
    type TEXT NOT NULL,  -- 'bar', 'pie', 'line', etc.
    config TEXT NOT NULL,  -- JSON configuration
    table_name TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (connection_id) REFERENCES connections(id) ON DELETE CASCADE
);

-- Insight Templates Table
CREATE TABLE insight_templates (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    description TEXT,
    type TEXT NOT NULL,  -- 'bar', 'pie', 'line', etc.
    config TEXT NOT NULL,  -- JSON configuration template
    category TEXT,  -- e.g., 'sales', 'performance', etc.
    is_default BOOLEAN DEFAULT 0
);
```

### 3.4 API Endpoints

#### 3.4.1 Connection Management
- `GET /api/connections` - List all saved connections
- `POST /api/connections` - Create a new connection
- `GET /api/connections/:id` - Get connection details
- `DELETE /api/connections/:id` - Remove a connection
- `GET /api/connections/:id/health` - Check database health/size

#### 3.4.2 Database Exploration
- `GET /api/connections/:id/tables` - List all tables in the database
- `GET /api/connections/:id/tables/:table/schema` - Get table schema
- `GET /api/connections/:id/tables/:table/data` - Get table data (with pagination)
- `GET /api/connections/:id/tables/:table/data/sample` - Get a sample of table data

#### 3.4.3 Visualization Management
- `POST /api/visualizations` - Create a new visualization
- `GET /api/visualizations` - List all saved visualizations
- `GET /api/visualizations/:id` - Get visualization details
- `PUT /api/visualizations/:id` - Update a visualization
- `DELETE /api/visualizations/:id` - Delete a visualization
- `GET /api/templates` - List all insight templates
- `GET /api/templates/:id` - Get template details
- `POST /api/templates/:id/apply` - Apply template to selected data

#### 3.4.4 Export Functionality
- `GET /api/export/csv/:vizId` - Export visualization as CSV
- `GET /api/export/csv/table/:connectionId/:tableName` - Export table as CSV

### 3.5 Data Flow Diagrams

#### 3.5.1 Database Connection Flow
```
User → Input Connection Details → Backend Validates → Check DB Size/Health → 
Connect to DB → Save Connection to App DB → Return Connection Details
```

#### 3.5.2 Visualization Creation Flow
```
User → Select Table → Choose Data Fields → Select Chart Type → 
Configure Chart Options → Backend Processes Data → 
Generate Visualization → Optional: Save Configuration → Render Chart
```

#### 3.5.3 Template Application Flow
```
User → Select Template → Backend Analyzes DB Structure → 
Suggest Field Mappings → User Confirms/Adjusts Mappings → 
Backend Processes Data → Generate Visualization → Render Chart
```

## 4. Implementation Details

### 4.1 Frontend Implementation

#### 4.1.1 Component Structure
The frontend will follow a component-based architecture:

```
src/
├── components/
│   ├── common/
│   │   ├── Button.tsx
│   │   ├── Dropdown.tsx
│   │   ├── Modal.tsx
│   │   └── ...
│   ├── connection/
│   │   ├── ConnectionForm.tsx
│   │   ├── ConnectionList.tsx
│   │   └── ...
│   ├── table/
│   │   ├── DataTable.tsx
│   │   ├── TableSelector.tsx
│   │   └── ...
│   ├── visualization/
│   │   ├── ChartRenderer.tsx
│   │   ├── ChartTypeSelector.tsx
│   │   ├── FieldMapper.tsx
│   │   └── ...
│   └── templates/
│       ├── TemplateList.tsx
│       ├── TemplateConfigurator.tsx
│       └── ...
├── layouts/
│   ├── MainLayout.tsx
│   └── ...
├── pages/
│   ├── Connections.tsx
│   ├── TableViewer.tsx
│   ├── VisualizationBuilder.tsx
│   ├── SavedVisualizations.tsx
│   └── ...
├── services/
│   ├── api.ts
│   ├── connectionService.ts
│   ├── visualizationService.ts
│   └── ...
└── utils/
    ├── dataTransformers.ts
    ├── formatters.ts
    └── ...
```

#### 4.1.2 State Management
The application will use a combination of:
- **React useState/useReducer**: For local component state
- **React Context API**: For shared application state
- **URL Parameters**: For shareable visualization states

#### 4.1.3 Routing Structure
```
/                        → Home/Dashboard
/connections             → Connection management
/connections/:id/tables  → Table explorer
/visualize               → Visualization builder
/gallery                 → Saved visualizations
/templates               → Insight templates
```

### 4.2 Backend Implementation

#### 4.2.1 Directory Structure
```
server/
├── routes/
│   ├── connections.js
│   ├── tables.js
│   ├── visualizations.js
│   ├── templates.js
│   └── export.js
├── services/
│   ├── connectionService.js
│   ├── databaseService.js
│   ├── visualizationService.js
│   ├── templateService.js
│   └── exportService.js
├── models/
│   ├── connection.js
│   ├── visualization.js
│   └── template.js
├── utils/
│   ├── dbUtils.js
│   ├── queryBuilder.js
│   └── responseFormatter.js
├── middleware/
│   ├── errorHandler.js
│   └── dataValidator.js
└── app.js
```

#### 4.2.2 Database Connection Handling
- Connection pooling for target databases
- Connection validation and health checking
- Table schema introspection
- Read-only query execution with timeout protection

#### 4.2.3 Data Processing
- Pagination implementation for large datasets
- Data transformation for visualization preparation
- Type inference for automatic chart suggestions
- Template mapping logic for insight generation

### 4.3 Security Considerations

#### 4.3.1 Input Validation
- All user inputs sanitized before use in database queries
- Schema validation for API payloads
- Path traversal prevention for database file access

#### 4.3.2 Query Safety
- Parameterized queries to prevent SQL injection
- Query timeout limits to prevent long-running operations
- Read-only access enforcement

#### 4.3.3 Error Handling
- Custom error classes for different error types
- Generic error responses to avoid exposing system details
- Comprehensive error logging

## 5. Testing Strategy

### 5.1 Unit Testing
- Component tests for frontend UI elements
- Service function tests for backend logic
- Data transformation function tests

### 5.2 Integration Testing
- API endpoint tests
- Database connection tests
- End-to-end user flow tests

### 5.3 Performance Testing
- Response time with various database sizes
- Chart rendering performance with large datasets
- Connection handling under concurrent usage

## 6. Deployment Considerations

### 6.1 Local Development Setup
```bash
# Clone repository
git clone [repository-url]

# Install dependencies
cd sqlite-visualizer
npm install

# Set up application database
node scripts/setup-db.js

# Start development server
npm run dev
```

### 6.2 Production Deployment
For local Mac deployment:
```bash
# Build production assets
npm run build

# Start production server
npm start
```

### 6.3 Network Configuration
- Configure server to listen on specified port
- Set up local network access for team members
- Document IP/hostname for team access

## 7. Performance Optimization

### 7.1 Database Query Optimization
- Implement query result caching for frequently accessed data
- Use data sampling for large tables (>10,000 rows)
- Implement lazy loading for table data

### 7.2 Frontend Optimization
- Bundle splitting for faster initial load
- Virtualized tables for large datasets
- Chart rendering optimizations
- Asset compression and caching

## 8. Future Technical Considerations

### 8.1 Potential Extensions
- Support for additional database types
- More advanced visualization types
- Query builder interface for advanced users
- Data modification capabilities

### 8.2 Scalability Path
- Move to separate application and visualization databases
- Implement more robust caching
- Add authentication for wider deployment
- Support for remote database connections

## 9. Appendices

### 9.1 Technology Stack Reference
- **Node.js**: https://nodejs.org/
- **Express.js**: https://expressjs.com/
- **SQLite**: https://www.sqlite.org/
- **better-sqlite3**: https://github.com/JoshuaWise/better-sqlite3
- **Preact**: https://preactjs.com/
- **Tailwind CSS**: https://tailwindcss.com/
- **shadcn UI**: https://ui.shadcn.com/
- **Chart.js**: https://www.chartjs.org/

### 9.2 Coding Standards
- Use JavaScript with optional TypeScript for type checking
- Follow Airbnb JavaScript Style Guide
- Component naming: PascalCase
- Function naming: camelCase
- API endpoints: kebab-case
- Commit messages: Conventional Commits format

This Technical Design Document provides a comprehensive guide for implementing the SQLite Visualizer application according to the requirements. It should serve as the primary reference during the development process.
</file>

<file path="SQLite_Visualizer_Style_Guide_Design_System.md">
# SQLite Visualizer Style Guide & Design System

## 1. Introduction

This style guide and design system outlines the visual and interactive elements of the SQLite Visualizer application. It serves as a reference to ensure consistency in design implementation across the entire application.

### 1.1 Purpose

This document provides guidelines for:
- Visual design elements (colors, typography, spacing)
- Component styling and behavior
- Data visualization standards
- Interactive patterns
- Responsive design considerations

### 1.2 Design Philosophy

The SQLite Visualizer adheres to the following design principles:
- **Clarity**: Present data in a clean, uncluttered manner
- **Efficiency**: Optimize for quick understanding and interaction
- **Consistency**: Maintain uniform patterns throughout the application
- **Accessibility**: Ensure usability for all team members regardless of technical expertise

## 2. Color System

### 2.1 Primary Colors

| Name | Hex | Tailwind | Usage |
|------|-----|----------|-------|
| Primary | `#2563EB` | `blue-600` | Primary actions, active states, links |
| Primary Dark | `#1E40AF` | `blue-800` | Hover states, emphasis |
| Primary Light | `#DBEAFE` | `blue-100` | Backgrounds, highlighting |

### 2.2 Neutral Colors

| Name | Hex | Tailwind | Usage |
|------|-----|----------|-------|
| Background | `#FFFFFF` | `white` | Page background |
| Surface | `#F8FAFC` | `slate-50` | Card backgrounds, panels |
| Border | `#E2E8F0` | `slate-200` | Dividers, borders |
| Text Primary | `#0F172A` | `slate-900` | Primary text |
| Text Secondary | `#64748B` | `slate-500` | Secondary text, labels |
| Text Tertiary | `#94A3B8` | `slate-400` | Placeholders, disabled text |

### 2.3 Semantic Colors

| Name | Hex | Tailwind | Usage |
|------|-----|----------|-------|
| Success | `#10B981` | `emerald-500` | Success states, positive values |
| Warning | `#F59E0B` | `amber-500` | Warning states, alerts |
| Error | `#EF4444` | `red-500` | Error states, negative values |
| Info | `#0EA5E9` | `sky-500` | Information, neutral alerts |

### 2.4 Chart Colors

A set of 10 distinct colors for data visualization, ensuring accessibility and clear differentiation:

| Name | Hex | Tailwind |
|------|-----|----------|
| Chart-1 | `#2563EB` | `blue-600` |
| Chart-2 | `#D946EF` | `fuchsia-500` |
| Chart-3 | `#F59E0B` | `amber-500` |
| Chart-4 | `#10B981` | `emerald-500` |
| Chart-5 | `#6366F1` | `indigo-500` |
| Chart-6 | `#EF4444` | `red-500` |
| Chart-7 | `#8B5CF6` | `violet-500` |
| Chart-8 | `#EC4899` | `pink-500` |
| Chart-9 | `#06B6D4` | `cyan-500` |
| Chart-10 | `#84CC16` | `lime-500` |

## 3. Typography

### 3.1 Font Family

**Primary Font**: Inter (Sans-serif)
```css
font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
```

Tailwind configuration:
```js
fontFamily: {
  sans: ['Inter', ...defaultTheme.fontFamily.sans],
}
```

### 3.2 Type Scale

| Name | Size | Line Height | Tailwind | Usage |
|------|------|-------------|----------|-------|
| Display | 30px | 36px | `text-3xl` | Page titles |
| Heading 1 | 24px | 32px | `text-2xl` | Section titles |
| Heading 2 | 20px | 28px | `text-xl` | Subsection titles |
| Heading 3 | 16px | 24px | `text-base` | Card titles, field labels |
| Body | 14px | 20px | `text-sm` | Primary body text |
| Caption | 12px | 16px | `text-xs` | Supporting text, metadata |
| Small | 10px | 14px | `text-[10px]` | Footnotes, legal |

### 3.3 Font Weights

| Weight | Tailwind | Usage |
|--------|----------|-------|
| Regular (400) | `font-normal` | Body text, general content |
| Medium (500) | `font-medium` | Emphasis, labels, headers |
| Semibold (600) | `font-semibold` | Headers, buttons, strong emphasis |

### 3.4 Text Colors

Follow the neutral colors system, with:
- `slate-900` for primary text
- `slate-500` for secondary text
- `slate-400` for tertiary/disabled text
- `blue-600` for interactive text elements

## 4. Spacing System

The spacing system follows Tailwind's default scale, with emphasis on these key values:

| Name | Value | Tailwind | Usage |
|------|-------|----------|-------|
| 2XS | 4px | `p-1` `m-1` | Minimal spacing, icons |
| XS | 8px | `p-2` `m-2` | Tight spacing, compact elements |
| S | 12px | `p-3` `m-3` | Default inner padding |
| M | 16px | `p-4` `m-4` | Standard spacing, section margins |
| L | 24px | `p-6` `m-6` | Generous spacing, section padding |
| XL | 32px | `p-8` `m-8` | Layout spacing, large gaps |
| 2XL | 48px | `p-12` `m-12` | Major section divisions |

## 5. Shadows & Elevation

| Name | Tailwind | Usage |
|------|----------|-------|
| None | `shadow-none` | Flat elements |
| Low | `shadow-sm` | Cards, subtle elevation |
| Medium | `shadow` | Dropdowns, popovers |
| High | `shadow-md` | Modals, floating elements |
| Focus | `ring-2 ring-blue-500 ring-opacity-50` | Interactive elements in focus state |

## 6. Border Radius

| Name | Value | Tailwind | Usage |
|------|-------|----------|-------|
| None | 0 | `rounded-none` | Tables, certain UI elements |
| Small | 4px | `rounded-sm` | Inputs, buttons, small elements |
| Medium | 6px | `rounded` | Cards, larger containers |
| Large | 8px | `rounded-md` | Modals, prominent elements |
| Full | 9999px | `rounded-full` | Pills, tags, circular buttons |

## 7. Component Styling

### 7.1 Buttons

#### Primary Button
```html
<button class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 
               focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 
               transition-colors font-medium text-sm">
  Button Text
</button>
```

#### Secondary Button
```html
<button class="px-4 py-2 bg-white text-slate-900 border border-slate-300 rounded 
               hover:bg-slate-50 focus:outline-none focus:ring-2 focus:ring-blue-500 
               focus:ring-opacity-50 transition-colors font-medium text-sm">
  Button Text
</button>
```

#### Tertiary Button (Text)
```html
<button class="px-3 py-1.5 text-blue-600 rounded hover:bg-blue-50 
               focus:outline-none focus:ring-2 focus:ring-blue-500 
               focus:ring-opacity-50 transition-colors font-medium text-sm">
  Button Text
</button>
```

#### Icon Button
```html
<button class="p-2 text-slate-500 rounded hover:bg-slate-100 
               focus:outline-none focus:ring-2 focus:ring-blue-500 
               focus:ring-opacity-50 transition-colors">
  <svg><!-- Icon --></svg>
</button>
```

### 7.2 Input Fields

#### Text Input
```html
<div class="space-y-1">
  <label class="block text-sm font-medium text-slate-700">Label</label>
  <input type="text" 
         class="w-full px-3 py-2 border border-slate-300 rounded-sm text-sm 
                text-slate-900 placeholder-slate-400
                focus:outline-none focus:ring-2 focus:ring-blue-500 
                focus:border-blue-500">
  <p class="text-xs text-slate-500">Helper text</p>
</div>
```

#### Select Dropdown
```html
<div class="space-y-1">
  <label class="block text-sm font-medium text-slate-700">Label</label>
  <select class="w-full px-3 py-2 border border-slate-300 rounded-sm text-sm 
                 text-slate-900 bg-white
                 focus:outline-none focus:ring-2 focus:ring-blue-500 
                 focus:border-blue-500 appearance-none">
    <option>Option 1</option>
    <option>Option 2</option>
  </select>
</div>
```

#### Checkbox
```html
<div class="flex items-center">
  <input type="checkbox" 
         class="h-4 w-4 text-blue-600 border-slate-300 rounded 
                focus:ring-blue-500">
  <label class="ml-2 text-sm text-slate-700">
    Checkbox label
  </label>
</div>
```

### 7.3 Cards & Containers

#### Standard Card
```html
<div class="bg-white border border-slate-200 rounded p-4 
            shadow-sm">
  Card content
</div>
```

#### Interactive Card
```html
<div class="bg-white border border-slate-200 rounded p-4 
            shadow-sm hover:shadow transition-shadow">
  Interactive card content
</div>
```

#### Section Container
```html
<section class="bg-white border border-slate-200 rounded-md p-6">
  <h2 class="text-xl font-semibold text-slate-900 mb-4">Section Title</h2>
  <div>
    Section content
  </div>
</section>
```

### 7.4 Navigation Elements

#### Tab Bar
```html
<div class="border-b border-slate-200">
  <nav class="flex space-x-6">
    <a class="py-3 border-b-2 border-blue-600 font-medium text-sm text-blue-600">
      Active Tab
    </a>
    <a class="py-3 border-b-2 border-transparent font-medium text-sm text-slate-500 
              hover:text-slate-700 hover:border-slate-300">
      Inactive Tab
    </a>
  </nav>
</div>
```

#### Pagination
```html
<nav class="flex items-center justify-between py-3">
  <button class="px-3 py-1 border border-slate-300 rounded-sm text-sm text-slate-700
                 hover:bg-slate-50 disabled:opacity-50 disabled:cursor-not-allowed">
    Previous
  </button>
  <div class="flex space-x-1">
    <button class="px-3 py-1 border border-blue-600 rounded-sm text-sm 
                   bg-blue-50 text-blue-600 font-medium">1</button>
    <button class="px-3 py-1 border border-slate-300 rounded-sm text-sm 
                   text-slate-700 hover:bg-slate-50">2</button>
  </div>
  <button class="px-3 py-1 border border-slate-300 rounded-sm text-sm text-slate-700
                 hover:bg-slate-50">
    Next
  </button>
</nav>
```

### 7.5 Data Tables

#### Table Styling
```html
<div class="overflow-x-auto">
  <table class="min-w-full divide-y divide-slate-200">
    <thead>
      <tr class="bg-slate-50">
        <th class="px-4 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider">
          Column Header
        </th>
        <!-- More headers -->
      </tr>
    </thead>
    <tbody class="bg-white divide-y divide-slate-200">
      <tr class="hover:bg-slate-50">
        <td class="px-4 py-3 text-sm text-slate-900">
          Cell content
        </td>
        <!-- More cells -->
      </tr>
      <!-- More rows -->
    </tbody>
  </table>
</div>
```

### 7.6 Alert & Notification Styles

#### Info Alert
```html
<div class="p-4 rounded-md bg-blue-50 border border-blue-200">
  <div class="flex">
    <div class="flex-shrink-0 text-blue-400">
      <!-- Info icon -->
    </div>
    <div class="ml-3">
      <p class="text-sm text-blue-700">Information message</p>
    </div>
  </div>
</div>
```

#### Success Alert
```html
<div class="p-4 rounded-md bg-emerald-50 border border-emerald-200">
  <div class="flex">
    <div class="flex-shrink-0 text-emerald-400">
      <!-- Success icon -->
    </div>
    <div class="ml-3">
      <p class="text-sm text-emerald-700">Success message</p>
    </div>
  </div>
</div>
```

#### Warning Alert
```html
<div class="p-4 rounded-md bg-amber-50 border border-amber-200">
  <div class="flex">
    <div class="flex-shrink-0 text-amber-400">
      <!-- Warning icon -->
    </div>
    <div class="ml-3">
      <p class="text-sm text-amber-700">Warning message</p>
    </div>
  </div>
</div>
```

#### Error Alert
```html
<div class="p-4 rounded-md bg-red-50 border border-red-200">
  <div class="flex">
    <div class="flex-shrink-0 text-red-400">
      <!-- Error icon -->
    </div>
    <div class="ml-3">
      <p class="text-sm text-red-700">Error message</p>
    </div>
  </div>
</div>
```

## 8. Data Visualization Styling

### 8.1 Chart Containers

All charts should be contained within a consistent wrapper:

```html
<div class="p-4 bg-white border border-slate-200 rounded-md shadow-sm">
  <div class="flex justify-between items-center mb-4">
    <h3 class="text-base font-medium text-slate-900">Chart Title</h3>
    <div class="flex space-x-2">
      <!-- Chart controls -->
    </div>
  </div>
  <div class="h-[300px]">
    <!-- Chart content -->
  </div>
</div>
```

### 8.2 Chart.js Configuration Defaults

```javascript
Chart.defaults.font.family = "'Inter', sans-serif";
Chart.defaults.color = '#64748B'; // text-slate-500
Chart.defaults.borderColor = '#E2E8F0'; // text-slate-200
Chart.defaults.plugins.tooltip.backgroundColor = '#0F172A'; // slate-900
Chart.defaults.plugins.tooltip.titleColor = '#FFFFFF';
Chart.defaults.plugins.tooltip.bodyColor = '#FFFFFF';
Chart.defaults.plugins.tooltip.padding = 12;
Chart.defaults.plugins.tooltip.cornerRadius = 4;
Chart.defaults.plugins.tooltip.titleFont = { weight: 'medium' };
```

### 8.3 Chart Type-Specific Styling

#### Bar Charts
```javascript
const barChartConfig = {
  datasets: [{
    backgroundColor: [
      '#2563EB', '#D946EF', '#F59E0B', '#10B981', '#6366F1',
      '#EF4444', '#8B5CF6', '#EC4899', '#06B6D4', '#84CC16'
    ],
    borderRadius: 4,
    maxBarThickness: 40
  }],
  plugins: {
    legend: {
      position: 'bottom',
      labels: {
        boxWidth: 12,
        padding: 15
      }
    }
  }
};
```

#### Line Charts
```javascript
const lineChartConfig = {
  datasets: [{
    borderWidth: 2,
    tension: 0.2,
    pointRadius: 3,
    pointHoverRadius: 5
  }],
  plugins: {
    legend: {
      position: 'bottom',
      labels: {
        boxWidth: 12,
        padding: 15
      }
    }
  }
};
```

#### Pie/Doughnut Charts
```javascript
const pieChartConfig = {
  datasets: [{
    backgroundColor: [
      '#2563EB', '#D946EF', '#F59E0B', '#10B981', '#6366F1',
      '#EF4444', '#8B5CF6', '#EC4899', '#06B6D4', '#84CC16'
    ],
    borderWidth: 2,
    borderColor: '#FFFFFF'
  }],
  plugins: {
    legend: {
      position: 'right',
      labels: {
        boxWidth: 12,
        padding: 15
      }
    }
  }
};
```

## 9. Responsive Design Guidelines

### 9.1 Breakpoints

Following Tailwind's default breakpoints:

| Name | Min Width | Tailwind |
|------|-----------|----------|
| SM | 640px | `sm:` |
| MD | 768px | `md:` |
| LG | 1024px | `lg:` |
| XL | 1280px | `xl:` |
| 2XL | 1536px | `2xl:` |

### 9.2 Layout Adjustments

#### Navigation
- Below `md`: Use collapsible sidebar with hamburger menu
- Above `md`: Keep sidebar visible

#### Tables
- Below `md`: Allow horizontal scrolling for tables
- All sizes: Use responsive text sizing

#### Charts
- Below `md`: Stack charts vertically
- Above `md`: Arrange charts in grid layout
- Below `sm`: Simplify chart legends or move to bottom
- Consider disabling certain chart interactions on touch devices

### 9.3 Component-Specific Guidelines

#### Cards
```html
<div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
  <!-- Cards -->
</div>
```

#### Forms
```html
<div class="grid grid-cols-1 md:grid-cols-2 gap-4">
  <!-- Form fields -->
</div>
```

## 10. Motion & Animation Guidelines

### 10.1 Transition Defaults

```css
/* Duration */
.transition-duration-default: 150ms;
.transition-duration-long: 300ms;

/* Easing */
.transition-timing-default: cubic-bezier(0.4, 0, 0.2, 1);
.transition-timing-entrance: cubic-bezier(0, 0, 0.2, 1);
.transition-timing-exit: cubic-bezier(0.4, 0, 1, 1);
```

### 10.2 Common Transitions

#### Hover States
```css
.hover-transition {
  @apply transition-colors duration-150 ease-in-out;
}
```

#### Modals/Dialogs
```css
.modal-transition {
  @apply transition-opacity duration-300 ease-in-out;
}
```

#### Expanding Elements
```css
.expand-transition {
  @apply transition-all duration-300 ease-out;
}
```

### 10.3 Chart Animations

```javascript
const chartAnimationDefaults = {
  duration: 750,
  easing: 'easeOutQuart'
};
```

## 11. Accessibility Guidelines

### 11.1 Color Contrast

- All text must have a contrast ratio of at least 4.5:1 against its background
- All interactive elements must have a contrast ratio of at least 3:1
- Use the semantic colors consistently to indicate states

### 11.2 Focus States

All interactive elements must have visible focus states:
```css
.focus-visible:outline-none .focus-visible:ring-2 .focus-visible:ring-blue-500 .focus-visible:ring-opacity-50
```

### 11.3 Screen Reader Support

- All form inputs must have associated labels
- All images and icons must have appropriate alt text or aria-labels
- Use appropriate ARIA roles for custom interactive elements

## 12. Implementation Guidelines

### 12.1 Tailwind Configuration

```javascript
// tailwind.config.js
module.exports = {
  content: [
    "./src/**/*.{js,jsx,ts,tsx}",
    "./public/index.html"
  ],
  theme: {
    extend: {
      colors: {
        // Define color palette
        primary: {
          DEFAULT: '#2563EB', // blue-600
          dark: '#1E40AF',    // blue-800
          light: '#DBEAFE',   // blue-100
        },
        // Add other custom colors
      },
      fontFamily: {
        sans: ['Inter', ...defaultTheme.fontFamily.sans],
      },
      // Other theme extensions
    },
  },
  plugins: [
    require('@tailwindcss/forms'),
  ],
}
```

### 12.2 CSS Custom Properties

For values that Tailwind doesn't cover, use CSS custom properties:

```css
:root {
  --chart-height-sm: 200px;
  --chart-height-md: 300px;
  --chart-height-lg: 400px;
  
  --transition-duration-default: 150ms;
  --transition-duration-long: 300ms;
  
  --shadow-color: 215 25% 27%;
}
```

### 12.3 Using shadcn UI Components

When implementing shadcn UI components, follow these guidelines:

1. Use the shadcn UI CLI to add components:
   ```bash
   npx shadcn-ui@latest add button
   npx shadcn-ui@latest add card
   npx shadcn-ui@latest add table
   ```

2. Customize the component themes in the component CSS files to match this style guide

3. When using shadcn UI with Tailwind, prefer composition over direct customization:
   ```jsx
   <Button variant="default" className="px-6">
     Extended Button
   </Button>
   ```

## 13. Asset Guidelines

### 13.1 Icons

Use a consistent icon library (recommended: Lucide Icons or Heroicons)

- **Icon Sizes**:
  - Small: 16px (`w-4 h-4`)
  - Medium: 20px (`w-5 h-5`) - Default
  - Large: 24px (`w-6 h-6`)

- **Icon Colors**:
  - Use current color by default: `fill-current` or `stroke-current`
  - Follow text color system for context

### 13.2 Imagery & Illustrations

- Use illustrations that match the color system
- Keep illustrations minimal and functional rather than decorative
- Ensure all images are optimized for web

## 14. File Naming Conventions

- **Components**: PascalCase (e.g., `DataTable.tsx`, `ConnectionForm.tsx`)
- **Utilities**: camelCase (e.g., `formatNumber.ts`, `dateUtils.ts`)
- **CSS Modules**: kebab-case (e.g., `button-styles.module.css`)
- **Assets**: kebab-case (e.g., `database-icon.svg`, `chart-preview.png`)

---

This style guide serves as a living document and should be updated as design decisions evolve throughout the development process. All team members should adhere to these guidelines to ensure a consistent, high-quality user experience.
</file>

<file path="SQLite_Visualizer_Technical_Design_Document.md">
# SQLite Visualizer Technical Design Document

## 1. Introduction

### 1.1 Purpose
This Technical Design Document (TDD) provides detailed specifications for the SQLite Visualizer application as currently implemented. It serves as a comprehensive guide for the development team to maintain and extend the application according to the established architecture and design patterns.

### 1.2 Scope
The SQLite Visualizer is a web-based application designed to provide visual representation of SQLite database content through tabular views and charts. It is designed for a small team of 5 professionals to analyze SQLite database data without requiring SQL knowledge. The application enables data exploration, visualization, and export capabilities in a user-friendly interface.

### 1.3 Definitions, Acronyms, and Abbreviations
- **UI**: User Interface
- **API**: Application Programming Interface
- **DB**: Database
- **CSV**: Comma-Separated Values
- **KPI**: Key Performance Indicator

## 2. System Architecture

### 2.1 High-Level Architecture
The application follows a client-server architecture:
- **Client**: React-based interface built with TypeScript, Tailwind CSS, and Chart.js
- **Server**: Node.js backend service that communicates with SQLite databases
- **Database**: Two types of SQLite databases:
  - Target databases (read-only access for visualization)
  - Application database (for storing configurations and saved visualizations)

```
┌─────────────────┐      ┌─────────────────┐      ┌─────────────────┐
│                 │      │                 │      │  Target SQLite  │
│  Web Browser    │<────>│  Node.js Server │<────>│  Databases      │
│  (React Client) │      │  (Express)      │      │  (Read-only)    │
└─────────────────┘      └────────┬────────┘      └─────────────────┘
                                  │
                                  ▼
                         ┌─────────────────┐
                         │  App SQLite DB  │
                         │  (Config & viz) │
                         └─────────────────┘
```

### 2.2 Component Architecture

#### 2.2.1 Frontend Components
The frontend is organized into the following major component categories:

1. **Connection Management**
   - `ConnectionForm`: Handles creation of new database connections
   - `ConnectionList`: Displays and manages existing connections

2. **Table Viewing**
   - `TableSelector`: Allows selection of tables from connected databases
   - `DataTable`: Displays table data with sorting, filtering, and pagination

3. **Visualization Building**
   - `ChartTypeSelector`: UI for selecting visualization types
   - `FieldMapper`: Maps database fields to chart dimensions
   - `ChartRenderer`: Renders different chart types using Chart.js
   - `ChartPreview`: Provides a preview of the configured visualization

4. **Template Management**
   - `TemplateList`: Displays available insight templates
   - `TemplateCard`: Presents individual template information
   - `TemplateConfigurator`: Configures templates for specific databases
   - `TemplateFieldMapper`: Maps template fields to database columns

5. **Common Components**
   - `Sidebar`: Main navigation component
   - `ExportButton`: Handles data export functionality

#### 2.2.2 Backend Components
The backend is organized into the following service modules:

1. **Connection Service**
   - Establishes and manages SQLite database connections
   - Validates connection parameters
   - Provides database metadata and health checks

2. **Database Service**
   - Executes read-only queries against target databases
   - Formats query results for frontend consumption
   - Implements pagination and data sampling

3. **Visualization Service**
   - Processes data for chart generation
   - Manages saved visualization configurations
   - Provides data transformation utilities

4. **Template Service**
   - Manages insight templates
   - Provides template application logic
   - Handles template field mapping suggestions

5. **Export Service**
   - Formats data for CSV export
   - Handles file generation and delivery

## 3. Detailed Technical Specifications

### 3.1 Frontend Technologies

#### 3.1.1 Core Framework
**Technology**: React with TypeScript
**Implementation**: The application uses React 18 with TypeScript for type safety. Component files use the `.tsx` extension.

#### 3.1.2 UI Framework
**Technology**: Tailwind CSS
**Implementation**: The application uses Tailwind CSS for styling, following the design system defined in the style guide. The implementation maintains consistent spacing, colors, and typography across all components.

#### 3.1.3 State Management
**Technology**: React Hooks and fetch API
**Implementation**: The application uses React's built-in useState and useEffect hooks for state management, along with the fetch API for data retrieval from the backend.

#### 3.1.4 Visualization Libraries
**Technology**: Chart.js with react-chartjs-2
**Implementation**: The application uses Chart.js through the react-chartjs-2 wrapper to create various chart types. Chart configurations follow the styling guidelines defined in the style guide.

#### 3.1.5 Routing
**Technology**: React Router
**Implementation**: The application uses React Router for client-side routing, allowing for navigation between different views while maintaining application state.

### 3.2 Backend Technologies

#### 3.2.1 Runtime Environment
**Technology**: Node.js
**Implementation**: The server runs on Node.js, providing a JavaScript runtime for server-side code.

#### 3.2.2 Web Framework
**Technology**: Express.js
**Implementation**: The backend uses Express.js to create a RESTful API, with route handlers organized by resource type.

#### 3.2.3 Database Access
**Technology**: better-sqlite3
**Implementation**: The application uses the better-sqlite3 module for high-performance SQLite database access, with prepared statements for security and performance.

#### 3.2.4 Middleware
**Technologies**: cors, helmet, morgan, custom middleware
**Implementation**: The Express application uses:
- cors: For Cross-Origin Resource Sharing
- helmet: For security headers
- morgan: For request logging
- Custom middleware for error handling and request validation

### 3.3 Database Schema

#### 3.3.1 Application Database
The application uses a SQLite database with the following schema:

```sql
-- Database Connections Table
CREATE TABLE connections (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    path TEXT NOT NULL,
    last_accessed TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    size_bytes INTEGER,
    table_count INTEGER,
    is_valid BOOLEAN DEFAULT 1
);

-- Saved Visualizations Table
CREATE TABLE saved_visualizations (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    connection_id INTEGER,
    name TEXT NOT NULL,
    type TEXT NOT NULL,  -- 'bar', 'pie', 'line', etc.
    config TEXT NOT NULL,  -- JSON configuration
    table_name TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (connection_id) REFERENCES connections(id) ON DELETE CASCADE
);

-- Insight Templates Table
CREATE TABLE insight_templates (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    description TEXT,
    type TEXT NOT NULL,  -- 'bar', 'pie', 'line', etc.
    config TEXT NOT NULL,  -- JSON configuration template
    category TEXT,  -- e.g., 'sales', 'performance', etc.
    is_default BOOLEAN DEFAULT 0
);
```

### 3.4 API Endpoints

The application implements a comprehensive RESTful API:

#### 3.4.1 Connection Management
- `GET /api/connections` - List all saved connections
- `POST /api/connections` - Create a new connection
- `GET /api/connections/:id` - Get connection details
- `DELETE /api/connections/:id` - Remove a connection
- `GET /api/connections/:id/health` - Check database health/size

#### 3.4.2 Database Exploration
- `GET /api/connections/:id/tables` - List all tables in the database
- `GET /api/connections/:id/tables/:table/schema` - Get table schema
- `GET /api/connections/:id/tables/:table/data` - Get table data (with pagination)
- `GET /api/connections/:id/tables/:table/data/sample` - Get a sample of table data

#### 3.4.3 Visualization Management
- `POST /api/visualizations` - Create a new visualization
- `GET /api/visualizations` - List all saved visualizations
- `GET /api/visualizations/:id` - Get visualization details
- `PUT /api/visualizations/:id` - Update a visualization
- `DELETE /api/visualizations/:id` - Delete a visualization
- `GET /api/templates` - List all insight templates
- `GET /api/templates/:id` - Get template details
- `POST /api/templates/:id/apply` - Apply template to selected data

#### 3.4.4 Export Functionality
- `GET /api/export/csv/:vizId` - Export visualization as CSV
- `GET /api/export/csv/table/:connectionId/:tableName` - Export table as CSV

### 3.5 Data Flow Diagrams

#### 3.5.1 Database Connection Flow
```
User → Input Connection Details → Backend Validates → Check DB Size/Health → 
Connect to DB → Save Connection to App DB → Return Connection Details
```

#### 3.5.2 Visualization Creation Flow
```
User → Select Table → Choose Data Fields → Select Chart Type → 
Configure Chart Options → Backend Processes Data → 
Generate Visualization → Optional: Save Configuration → Render Chart
```

#### 3.5.3 Template Application Flow
```
User → Select Template → Backend Analyzes DB Structure → 
Suggest Field Mappings → User Confirms/Adjusts Mappings → 
Backend Processes Data → Generate Visualization → Render Chart
```

## 4. Implementation Details

### 4.1 Frontend Implementation

#### 4.1.1 Component Structure
The frontend follows a component-based architecture as follows:

```
src/
├── components/
│   ├── common/
│   │   ├── ExportButton.tsx
│   │   ├── Sidebar.tsx
│   │   └── ...
│   ├── connection/
│   │   ├── ConnectionForm.tsx
│   │   ├── ConnectionList.tsx
│   │   └── ...
│   ├── table/
│   │   ├── DataTable.tsx
│   │   ├── TableSelector.tsx
│   │   └── ...
│   ├── visualization/
│   │   ├── ChartRenderer.tsx
│   │   ├── ChartTypeSelector.tsx
│   │   ├── FieldMapper.tsx
│   │   ├── ChartPreview.tsx
│   │   └── ...
│   └── templates/
│       ├── TemplateList.tsx
│       ├── TemplateCard.tsx
│       ├── TemplateConfigurator.tsx
│       ├── TemplateFieldMapper.tsx
│       └── ...
├── layouts/
│   └── MainLayout.tsx
├── pages/
│   ├── Connections.tsx
│   ├── TableViewer.tsx
│   ├── VisualizationBuilder.tsx
│   ├── SavedVisualizations.tsx
│   ├── Templates.tsx
│   ├── TemplateApplication.tsx
│   └── NotFound.tsx
├── services/
│   └── api.ts
├── types/
│   └── index.ts
├── config.ts
├── App.tsx
└── main.tsx
```

#### 4.1.2 State Management
The application uses a combination of:
- **React useState/useEffect**: For local component state and side effects
- **URL Parameters**: For shareable visualization states
- **Fetch API**: For data fetching from the backend

#### 4.1.3 Routing Structure
The application implements the following routes:

```
/                         → Home/Connections page
/connections              → Connection management
/tables/:connectionId     → Table explorer for a specific connection
/visualize/:connectionId  → Visualization builder for a specific connection
/visualizations           → Saved visualizations gallery
/templates                → Insight templates list
/templates/:templateId    → Template application page
```

### 4.2 Backend Implementation

#### 4.2.1 Directory Structure
The backend follows a modular structure as follows:

```
server/
├── routes/
│   ├── connections.js      → Connection endpoints
│   ├── tables.js           → Table and data endpoints
│   ├── visualizations.js   → Visualization endpoints
│   ├── templates.js        → Template endpoints
│   └── export.js           → Export functionality
├── services/
│   ├── appDbService.js     → Application database service
│   ├── connectionService.js → Connection management
│   ├── databaseService.js  → Database querying
│   ├── visualizationService.js → Visualization processing
│   ├── templateService.js  → Template management
│   └── exportService.js    → Export functionality
├── models/
│   ├── connection.js       → Connection data model
│   ├── visualization.js    → Visualization data model
│   └── template.js         → Template data model
├── middleware/
│   ├── errorHandler.js     → Error handling middleware
│   └── dataValidator.js    → Request validation
├── utils/
│   ├── dbUtils.js          → Database utilities
│   ├── queryBuilder.js     → SQL query construction
│   └── responseFormatter.js → Response formatting
└── app.js                  → Main application entry point
```

#### 4.2.2 Database Connection Handling
The backend implements the following for database connections:
- SQLite connection management using better-sqlite3
- Connection validation and health checking
- Table schema introspection through SQLite's information_schema queries
- Read-only query execution with prepared statements
- Connection pooling for efficient resource usage

#### 4.2.3 Data Processing
The backend implements the following data processing capabilities:
- Pagination with limit and offset for large datasets
- Data sampling for visualization previews
- Data transformation for various chart types
- Automatic field type detection for visualization suggestions
- Template field mapping with intelligent suggestions

### 4.3 Security Implementation

#### 4.3.1 Input Validation
The application implements the following security measures for input validation:
- Request validation using Joi schema validation
- Parameter sanitization before use in database queries
- Path validation for database file access to prevent directory traversal

#### 4.3.2 Query Safety
The application implements the following for query safety:
- Parameterized queries using better-sqlite3's prepared statements
- Read-only database access enforcement
- Query timeout limits for long-running operations

#### 4.3.3 Error Handling
The application implements comprehensive error handling:
- Custom error handling middleware
- Appropriate HTTP status codes for different error types
- Sanitized error messages to avoid exposing system details
- Structured error responses

## 5. Performance Optimizations

### 5.1 Database Query Optimization
The application implements the following database optimizations:
- Efficient SQLite connections with better-sqlite3
- Prepared statements for query performance
- Pagination for large datasets
- Selective column fetching
- Data sampling for visualization previews

### 5.2 Frontend Optimization
The application implements the following frontend optimizations:
- React component optimization with proper dependency management
- Lazy loading of chart components
- Efficient re-rendering with proper React patterns
- Optimized Chart.js configurations

## 6. Deployment Configuration

### 6.1 Development Environment
The application includes the following for development:
- Concurrent server and client development with hot reloading
- Development-specific logging
- Environment variable configuration
- Source maps for debugging

```bash
# Start development server with concurrent client and server
npm run dev
```

### 6.2 Production Environment
The application includes the following for production:
- Built React assets served by Express
- Optimized asset bundling
- Production-appropriate error handling
- Process management

```bash
# Build production assets
npm run build

# Start production server
npm start
```

## 7. Future Technical Considerations

### 7.1 Potential Extensions
The following features could be considered for future development:
- Support for additional database types beyond SQLite
- Advanced visualization types (heatmaps, treemaps, etc.)
- Query builder interface for advanced users
- Data modification capabilities with proper validation
- User authentication and access controls

### 7.2 Scalability Considerations
For future scaling, the following could be implemented:
- Separate application and visualization databases
- More robust caching strategies
- Connection pooling optimizations
- Support for remote database connections with proper security

## 8. Appendices

### 8.1 Technology Stack Reference
- **Node.js**: https://nodejs.org/
- **Express.js**: https://expressjs.com/
- **SQLite**: https://www.sqlite.org/
- **better-sqlite3**: https://github.com/JoshuaWise/better-sqlite3
- **React**: https://reactjs.org/
- **TypeScript**: https://www.typescriptlang.org/
- **Tailwind CSS**: https://tailwindcss.com/
- **Chart.js**: https://www.chartjs.org/
- **React Router**: https://reactrouter.com/

### 8.2 Coding Standards
The application follows these coding standards:
- TypeScript for type safety in the frontend
- ESM modules for imports/exports
- Component naming: PascalCase
- Function naming: camelCase
- CSS classes: Tailwind utility classes
- File naming: Component files match component names
- RESTful API endpoints

This Technical Design Document reflects the current state of the SQLite Visualizer application as implemented. It serves as a reference guide for maintenance and future development.
</file>

<file path="client/dist/assets/index-967cdcaf.js">
var t=Object.defineProperty,e=(e,n,i)=>(((e,n,i)=>{n in e?t(e,n,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[n]=i})(e,"symbol"!=typeof n?n+"":n,i),i);function n(t,e){for(var n=0;n<e.length;n++){const i=e[n];if("string"!=typeof i&&!Array.isArray(i))for(const e in i)if("default"!==e&&!(e in t)){const n=Object.getOwnPropertyDescriptor(i,e);n&&Object.defineProperty(t,e,n.get?n:{enumerable:!0,get:()=>i[e]})}}return Object.freeze(Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}))}function i(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}!function(){const t=document.createElement("link").relList;if(!(t&&t.supports&&t.supports("modulepreload"))){for(const t of document.querySelectorAll('link[rel="modulepreload"]'))e(t);new MutationObserver((t=>{for(const n of t)if("childList"===n.type)for(const t of n.addedNodes)"LINK"===t.tagName&&"modulepreload"===t.rel&&e(t)})).observe(document,{childList:!0,subtree:!0})}function e(t){if(t.ep)return;t.ep=!0;const e=function(t){const e={};return t.integrity&&(e.integrity=t.integrity),t.referrerPolicy&&(e.referrerPolicy=t.referrerPolicy),"use-credentials"===t.crossOrigin?e.credentials="include":"anonymous"===t.crossOrigin?e.credentials="omit":e.credentials="same-origin",e}(t);fetch(t.href,e)}}();var r={exports:{}},a={},s=Symbol.for("react.element"),o=Symbol.for("react.portal"),l=Symbol.for("react.fragment"),c=Symbol.for("react.strict_mode"),u=Symbol.for("react.profiler"),d=Symbol.for("react.provider"),h=Symbol.for("react.context"),f=Symbol.for("react.forward_ref"),p=Symbol.for("react.suspense"),g=Symbol.for("react.memo"),m=Symbol.for("react.lazy"),b=Symbol.iterator;var x={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},v=Object.assign,y={};function _(t,e,n){this.props=t,this.context=e,this.refs=y,this.updater=n||x}function w(){}function k(t,e,n){this.props=t,this.context=e,this.refs=y,this.updater=n||x}_.prototype.isReactComponent={},_.prototype.setState=function(t,e){if("object"!=typeof t&&"function"!=typeof t&&null!=t)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,t,e,"setState")},_.prototype.forceUpdate=function(t){this.updater.enqueueForceUpdate(this,t,"forceUpdate")},w.prototype=_.prototype;var S=k.prototype=new w;S.constructor=k,v(S,_.prototype),S.isPureReactComponent=!0;var C=Array.isArray,M=Object.prototype.hasOwnProperty,E={current:null},P={key:!0,ref:!0,__self:!0,__source:!0};function N(t,e,n){var i,r={},a=null,o=null;if(null!=e)for(i in void 0!==e.ref&&(o=e.ref),void 0!==e.key&&(a=""+e.key),e)M.call(e,i)&&!P.hasOwnProperty(i)&&(r[i]=e[i]);var l=arguments.length-2;if(1===l)r.children=n;else if(1<l){for(var c=Array(l),u=0;u<l;u++)c[u]=arguments[u+2];r.children=c}if(t&&t.defaultProps)for(i in l=t.defaultProps)void 0===r[i]&&(r[i]=l[i]);return{$$typeof:s,type:t,key:a,ref:o,props:r,_owner:E.current}}function D(t){return"object"==typeof t&&null!==t&&t.$$typeof===s}var T=/\/+/g;function O(t,e){return"object"==typeof t&&null!==t&&null!=t.key?function(t){var e={"=":"=0",":":"=2"};return"$"+t.replace(/[=:]/g,(function(t){return e[t]}))}(""+t.key):e.toString(36)}function L(t,e,n,i,r){var a=typeof t;"undefined"!==a&&"boolean"!==a||(t=null);var l=!1;if(null===t)l=!0;else switch(a){case"string":case"number":l=!0;break;case"object":switch(t.$$typeof){case s:case o:l=!0}}if(l)return r=r(l=t),t=""===i?"."+O(l,0):i,C(r)?(n="",null!=t&&(n=t.replace(T,"$&/")+"/"),L(r,e,n,"",(function(t){return t}))):null!=r&&(D(r)&&(r=function(t,e){return{$$typeof:s,type:t.type,key:e,ref:t.ref,props:t.props,_owner:t._owner}}(r,n+(!r.key||l&&l.key===r.key?"":(""+r.key).replace(T,"$&/")+"/")+t)),e.push(r)),1;if(l=0,i=""===i?".":i+":",C(t))for(var c=0;c<t.length;c++){var u=i+O(a=t[c],c);l+=L(a,e,n,u,r)}else if(u=function(t){return null===t||"object"!=typeof t?null:"function"==typeof(t=b&&t[b]||t["@@iterator"])?t:null}(t),"function"==typeof u)for(t=u.call(t),c=0;!(a=t.next()).done;)l+=L(a=a.value,e,n,u=i+O(a,c++),r);else if("object"===a)throw e=String(t),Error("Objects are not valid as a React child (found: "+("[object Object]"===e?"object with keys {"+Object.keys(t).join(", ")+"}":e)+"). If you meant to render a collection of children, use an array instead.");return l}function R(t,e,n){if(null==t)return t;var i=[],r=0;return L(t,i,"","",(function(t){return e.call(n,t,r++)})),i}function z(t){if(-1===t._status){var e=t._result;(e=e()).then((function(e){0!==t._status&&-1!==t._status||(t._status=1,t._result=e)}),(function(e){0!==t._status&&-1!==t._status||(t._status=2,t._result=e)})),-1===t._status&&(t._status=0,t._result=e)}if(1===t._status)return t._result.default;throw t._result}var j={current:null},A={transition:null},F={ReactCurrentDispatcher:j,ReactCurrentBatchConfig:A,ReactCurrentOwner:E};function I(){throw Error("act(...) is not supported in production builds of React.")}a.Children={map:R,forEach:function(t,e,n){R(t,(function(){e.apply(this,arguments)}),n)},count:function(t){var e=0;return R(t,(function(){e++})),e},toArray:function(t){return R(t,(function(t){return t}))||[]},only:function(t){if(!D(t))throw Error("React.Children.only expected to receive a single React element child.");return t}},a.Component=_,a.Fragment=l,a.Profiler=u,a.PureComponent=k,a.StrictMode=c,a.Suspense=p,a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=F,a.act=I,a.cloneElement=function(t,e,n){if(null==t)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+t+".");var i=v({},t.props),r=t.key,a=t.ref,o=t._owner;if(null!=e){if(void 0!==e.ref&&(a=e.ref,o=E.current),void 0!==e.key&&(r=""+e.key),t.type&&t.type.defaultProps)var l=t.type.defaultProps;for(c in e)M.call(e,c)&&!P.hasOwnProperty(c)&&(i[c]=void 0===e[c]&&void 0!==l?l[c]:e[c])}var c=arguments.length-2;if(1===c)i.children=n;else if(1<c){l=Array(c);for(var u=0;u<c;u++)l[u]=arguments[u+2];i.children=l}return{$$typeof:s,type:t.type,key:r,ref:a,props:i,_owner:o}},a.createContext=function(t){return(t={$$typeof:h,_currentValue:t,_currentValue2:t,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null}).Provider={$$typeof:d,_context:t},t.Consumer=t},a.createElement=N,a.createFactory=function(t){var e=N.bind(null,t);return e.type=t,e},a.createRef=function(){return{current:null}},a.forwardRef=function(t){return{$$typeof:f,render:t}},a.isValidElement=D,a.lazy=function(t){return{$$typeof:m,_payload:{_status:-1,_result:t},_init:z}},a.memo=function(t,e){return{$$typeof:g,type:t,compare:void 0===e?null:e}},a.startTransition=function(t){var e=A.transition;A.transition={};try{t()}finally{A.transition=e}},a.unstable_act=I,a.useCallback=function(t,e){return j.current.useCallback(t,e)},a.useContext=function(t){return j.current.useContext(t)},a.useDebugValue=function(){},a.useDeferredValue=function(t){return j.current.useDeferredValue(t)},a.useEffect=function(t,e){return j.current.useEffect(t,e)},a.useId=function(){return j.current.useId()},a.useImperativeHandle=function(t,e,n){return j.current.useImperativeHandle(t,e,n)},a.useInsertionEffect=function(t,e){return j.current.useInsertionEffect(t,e)},a.useLayoutEffect=function(t,e){return j.current.useLayoutEffect(t,e)},a.useMemo=function(t,e){return j.current.useMemo(t,e)},a.useReducer=function(t,e,n){return j.current.useReducer(t,e,n)},a.useRef=function(t){return j.current.useRef(t)},a.useState=function(t){return j.current.useState(t)},a.useSyncExternalStore=function(t,e,n){return j.current.useSyncExternalStore(t,e,n)},a.useTransition=function(){return j.current.useTransition()},a.version="18.3.1",r.exports=a;var V=r.exports;const B=n({__proto__:null,default:i(V)},[V]);var W={exports:{}},H={},$=V,U=Symbol.for("react.element"),Y=Symbol.for("react.fragment"),Q=Object.prototype.hasOwnProperty,q=$.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,X={key:!0,ref:!0,__self:!0,__source:!0};function K(t,e,n){var i,r={},a=null,s=null;for(i in void 0!==n&&(a=""+n),void 0!==e.key&&(a=""+e.key),void 0!==e.ref&&(s=e.ref),e)Q.call(e,i)&&!X.hasOwnProperty(i)&&(r[i]=e[i]);if(t&&t.defaultProps)for(i in e=t.defaultProps)void 0===r[i]&&(r[i]=e[i]);return{$$typeof:U,type:t,key:a,ref:s,props:r,_owner:q.current}}H.Fragment=Y,H.jsx=K,H.jsxs=K,W.exports=H;var G=W.exports,J={},Z={exports:{}},tt={},et={exports:{}},nt={};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
!function(t){function e(t,e){var n=t.length;t.push(e);t:for(;0<n;){var i=n-1>>>1,a=t[i];if(!(0<r(a,e)))break t;t[i]=e,t[n]=a,n=i}}function n(t){return 0===t.length?null:t[0]}function i(t){if(0===t.length)return null;var e=t[0],n=t.pop();if(n!==e){t[0]=n;t:for(var i=0,a=t.length,s=a>>>1;i<s;){var o=2*(i+1)-1,l=t[o],c=o+1,u=t[c];if(0>r(l,n))c<a&&0>r(u,l)?(t[i]=u,t[c]=n,i=c):(t[i]=l,t[o]=n,i=o);else{if(!(c<a&&0>r(u,n)))break t;t[i]=u,t[c]=n,i=c}}}return e}function r(t,e){var n=t.sortIndex-e.sortIndex;return 0!==n?n:t.id-e.id}if("object"==typeof performance&&"function"==typeof performance.now){var a=performance;t.unstable_now=function(){return a.now()}}else{var s=Date,o=s.now();t.unstable_now=function(){return s.now()-o}}var l=[],c=[],u=1,d=null,h=3,f=!1,p=!1,g=!1,m="function"==typeof setTimeout?setTimeout:null,b="function"==typeof clearTimeout?clearTimeout:null,x="undefined"!=typeof setImmediate?setImmediate:null;function v(t){for(var r=n(c);null!==r;){if(null===r.callback)i(c);else{if(!(r.startTime<=t))break;i(c),r.sortIndex=r.expirationTime,e(l,r)}r=n(c)}}function y(t){if(g=!1,v(t),!p)if(null!==n(l))p=!0,O(_);else{var e=n(c);null!==e&&L(y,e.startTime-t)}}function _(e,r){p=!1,g&&(g=!1,b(C),C=-1),f=!0;var a=h;try{for(v(r),d=n(l);null!==d&&(!(d.expirationTime>r)||e&&!P());){var s=d.callback;if("function"==typeof s){d.callback=null,h=d.priorityLevel;var o=s(d.expirationTime<=r);r=t.unstable_now(),"function"==typeof o?d.callback=o:d===n(l)&&i(l),v(r)}else i(l);d=n(l)}if(null!==d)var u=!0;else{var m=n(c);null!==m&&L(y,m.startTime-r),u=!1}return u}finally{d=null,h=a,f=!1}}"undefined"!=typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var w,k=!1,S=null,C=-1,M=5,E=-1;function P(){return!(t.unstable_now()-E<M)}function N(){if(null!==S){var e=t.unstable_now();E=e;var n=!0;try{n=S(!0,e)}finally{n?w():(k=!1,S=null)}}else k=!1}if("function"==typeof x)w=function(){x(N)};else if("undefined"!=typeof MessageChannel){var D=new MessageChannel,T=D.port2;D.port1.onmessage=N,w=function(){T.postMessage(null)}}else w=function(){m(N,0)};function O(t){S=t,k||(k=!0,w())}function L(e,n){C=m((function(){e(t.unstable_now())}),n)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(t){t.callback=null},t.unstable_continueExecution=function(){p||f||(p=!0,O(_))},t.unstable_forceFrameRate=function(t){0>t||125<t?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):M=0<t?Math.floor(1e3/t):5},t.unstable_getCurrentPriorityLevel=function(){return h},t.unstable_getFirstCallbackNode=function(){return n(l)},t.unstable_next=function(t){switch(h){case 1:case 2:case 3:var e=3;break;default:e=h}var n=h;h=e;try{return t()}finally{h=n}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=function(){},t.unstable_runWithPriority=function(t,e){switch(t){case 1:case 2:case 3:case 4:case 5:break;default:t=3}var n=h;h=t;try{return e()}finally{h=n}},t.unstable_scheduleCallback=function(i,r,a){var s=t.unstable_now();switch("object"==typeof a&&null!==a?a="number"==typeof(a=a.delay)&&0<a?s+a:s:a=s,i){case 1:var o=-1;break;case 2:o=250;break;case 5:o=1073741823;break;case 4:o=1e4;break;default:o=5e3}return i={id:u++,callback:r,priorityLevel:i,startTime:a,expirationTime:o=a+o,sortIndex:-1},a>s?(i.sortIndex=a,e(c,i),null===n(l)&&i===n(c)&&(g?(b(C),C=-1):g=!0,L(y,a-s))):(i.sortIndex=o,e(l,i),p||f||(p=!0,O(_))),i},t.unstable_shouldYield=P,t.unstable_wrapCallback=function(t){var e=h;return function(){var n=h;h=e;try{return t.apply(this,arguments)}finally{h=n}}}}(nt),et.exports=nt;var it=et.exports,rt=V,at=it;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */function st(t){for(var e="https://reactjs.org/docs/error-decoder.html?invariant="+t,n=1;n<arguments.length;n++)e+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+t+"; visit "+e+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var ot=new Set,lt={};function ct(t,e){ut(t,e),ut(t+"Capture",e)}function ut(t,e){for(lt[t]=e,t=0;t<e.length;t++)ot.add(e[t])}var dt=!("undefined"==typeof window||void 0===window.document||void 0===window.document.createElement),ht=Object.prototype.hasOwnProperty,ft=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,pt={},gt={};function mt(t,e,n,i,r,a,s){this.acceptsBooleans=2===e||3===e||4===e,this.attributeName=i,this.attributeNamespace=r,this.mustUseProperty=n,this.propertyName=t,this.type=e,this.sanitizeURL=a,this.removeEmptyString=s}var bt={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(t){bt[t]=new mt(t,0,!1,t,null,!1,!1)})),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach((function(t){var e=t[0];bt[e]=new mt(e,1,!1,t[1],null,!1,!1)})),["contentEditable","draggable","spellCheck","value"].forEach((function(t){bt[t]=new mt(t,2,!1,t.toLowerCase(),null,!1,!1)})),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach((function(t){bt[t]=new mt(t,2,!1,t,null,!1,!1)})),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(t){bt[t]=new mt(t,3,!1,t.toLowerCase(),null,!1,!1)})),["checked","multiple","muted","selected"].forEach((function(t){bt[t]=new mt(t,3,!0,t,null,!1,!1)})),["capture","download"].forEach((function(t){bt[t]=new mt(t,4,!1,t,null,!1,!1)})),["cols","rows","size","span"].forEach((function(t){bt[t]=new mt(t,6,!1,t,null,!1,!1)})),["rowSpan","start"].forEach((function(t){bt[t]=new mt(t,5,!1,t.toLowerCase(),null,!1,!1)}));var xt=/[\-:]([a-z])/g;function vt(t){return t[1].toUpperCase()}function yt(t,e,n,i){var r=bt.hasOwnProperty(e)?bt[e]:null;(null!==r?0!==r.type:i||!(2<e.length)||"o"!==e[0]&&"O"!==e[0]||"n"!==e[1]&&"N"!==e[1])&&(function(t,e,n,i){if(null==e||function(t,e,n,i){if(null!==n&&0===n.type)return!1;switch(typeof e){case"function":case"symbol":return!0;case"boolean":return!i&&(null!==n?!n.acceptsBooleans:"data-"!==(t=t.toLowerCase().slice(0,5))&&"aria-"!==t);default:return!1}}(t,e,n,i))return!0;if(i)return!1;if(null!==n)switch(n.type){case 3:return!e;case 4:return!1===e;case 5:return isNaN(e);case 6:return isNaN(e)||1>e}return!1}(e,n,r,i)&&(n=null),i||null===r?function(t){return!!ht.call(gt,t)||!ht.call(pt,t)&&(ft.test(t)?gt[t]=!0:(pt[t]=!0,!1))}(e)&&(null===n?t.removeAttribute(e):t.setAttribute(e,""+n)):r.mustUseProperty?t[r.propertyName]=null===n?3!==r.type&&"":n:(e=r.attributeName,i=r.attributeNamespace,null===n?t.removeAttribute(e):(n=3===(r=r.type)||4===r&&!0===n?"":""+n,i?t.setAttributeNS(i,e,n):t.setAttribute(e,n))))}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(t){var e=t.replace(xt,vt);bt[e]=new mt(e,1,!1,t,null,!1,!1)})),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(t){var e=t.replace(xt,vt);bt[e]=new mt(e,1,!1,t,"http://www.w3.org/1999/xlink",!1,!1)})),["xml:base","xml:lang","xml:space"].forEach((function(t){var e=t.replace(xt,vt);bt[e]=new mt(e,1,!1,t,"http://www.w3.org/XML/1998/namespace",!1,!1)})),["tabIndex","crossOrigin"].forEach((function(t){bt[t]=new mt(t,1,!1,t.toLowerCase(),null,!1,!1)})),bt.xlinkHref=new mt("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach((function(t){bt[t]=new mt(t,1,!1,t.toLowerCase(),null,!0,!0)}));var _t=rt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,wt=Symbol.for("react.element"),kt=Symbol.for("react.portal"),St=Symbol.for("react.fragment"),Ct=Symbol.for("react.strict_mode"),Mt=Symbol.for("react.profiler"),Et=Symbol.for("react.provider"),Pt=Symbol.for("react.context"),Nt=Symbol.for("react.forward_ref"),Dt=Symbol.for("react.suspense"),Tt=Symbol.for("react.suspense_list"),Ot=Symbol.for("react.memo"),Lt=Symbol.for("react.lazy"),Rt=Symbol.for("react.offscreen"),zt=Symbol.iterator;function jt(t){return null===t||"object"!=typeof t?null:"function"==typeof(t=zt&&t[zt]||t["@@iterator"])?t:null}var At,Ft=Object.assign;function It(t){if(void 0===At)try{throw Error()}catch(n){var e=n.stack.trim().match(/\n( *(at )?)/);At=e&&e[1]||""}return"\n"+At+t}var Vt=!1;function Bt(t,e){if(!t||Vt)return"";Vt=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(e)if(e=function(){throw Error()},Object.defineProperty(e.prototype,"props",{set:function(){throw Error()}}),"object"==typeof Reflect&&Reflect.construct){try{Reflect.construct(e,[])}catch(c){var i=c}Reflect.construct(t,[],e)}else{try{e.call()}catch(c){i=c}t.call(e.prototype)}else{try{throw Error()}catch(c){i=c}t()}}catch(c){if(c&&i&&"string"==typeof c.stack){for(var r=c.stack.split("\n"),a=i.stack.split("\n"),s=r.length-1,o=a.length-1;1<=s&&0<=o&&r[s]!==a[o];)o--;for(;1<=s&&0<=o;s--,o--)if(r[s]!==a[o]){if(1!==s||1!==o)do{if(s--,0>--o||r[s]!==a[o]){var l="\n"+r[s].replace(" at new "," at ");return t.displayName&&l.includes("<anonymous>")&&(l=l.replace("<anonymous>",t.displayName)),l}}while(1<=s&&0<=o);break}}}finally{Vt=!1,Error.prepareStackTrace=n}return(t=t?t.displayName||t.name:"")?It(t):""}function Wt(t){switch(t.tag){case 5:return It(t.type);case 16:return It("Lazy");case 13:return It("Suspense");case 19:return It("SuspenseList");case 0:case 2:case 15:return t=Bt(t.type,!1);case 11:return t=Bt(t.type.render,!1);case 1:return t=Bt(t.type,!0);default:return""}}function Ht(t){if(null==t)return null;if("function"==typeof t)return t.displayName||t.name||null;if("string"==typeof t)return t;switch(t){case St:return"Fragment";case kt:return"Portal";case Mt:return"Profiler";case Ct:return"StrictMode";case Dt:return"Suspense";case Tt:return"SuspenseList"}if("object"==typeof t)switch(t.$$typeof){case Pt:return(t.displayName||"Context")+".Consumer";case Et:return(t._context.displayName||"Context")+".Provider";case Nt:var e=t.render;return(t=t.displayName)||(t=""!==(t=e.displayName||e.name||"")?"ForwardRef("+t+")":"ForwardRef"),t;case Ot:return null!==(e=t.displayName||null)?e:Ht(t.type)||"Memo";case Lt:e=t._payload,t=t._init;try{return Ht(t(e))}catch(n){}}return null}function $t(t){var e=t.type;switch(t.tag){case 24:return"Cache";case 9:return(e.displayName||"Context")+".Consumer";case 10:return(e._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return t=(t=e.render).displayName||t.name||"",e.displayName||(""!==t?"ForwardRef("+t+")":"ForwardRef");case 7:return"Fragment";case 5:return e;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return Ht(e);case 8:return e===Ct?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"==typeof e)return e.displayName||e.name||null;if("string"==typeof e)return e}return null}function Ut(t){switch(typeof t){case"boolean":case"number":case"string":case"undefined":case"object":return t;default:return""}}function Yt(t){var e=t.type;return(t=t.nodeName)&&"input"===t.toLowerCase()&&("checkbox"===e||"radio"===e)}function Qt(t){t._valueTracker||(t._valueTracker=function(t){var e=Yt(t)?"checked":"value",n=Object.getOwnPropertyDescriptor(t.constructor.prototype,e),i=""+t[e];if(!t.hasOwnProperty(e)&&void 0!==n&&"function"==typeof n.get&&"function"==typeof n.set){var r=n.get,a=n.set;return Object.defineProperty(t,e,{configurable:!0,get:function(){return r.call(this)},set:function(t){i=""+t,a.call(this,t)}}),Object.defineProperty(t,e,{enumerable:n.enumerable}),{getValue:function(){return i},setValue:function(t){i=""+t},stopTracking:function(){t._valueTracker=null,delete t[e]}}}}(t))}function qt(t){if(!t)return!1;var e=t._valueTracker;if(!e)return!0;var n=e.getValue(),i="";return t&&(i=Yt(t)?t.checked?"true":"false":t.value),(t=i)!==n&&(e.setValue(t),!0)}function Xt(t){if(void 0===(t=t||("undefined"!=typeof document?document:void 0)))return null;try{return t.activeElement||t.body}catch(e){return t.body}}function Kt(t,e){var n=e.checked;return Ft({},e,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=n?n:t._wrapperState.initialChecked})}function Gt(t,e){var n=null==e.defaultValue?"":e.defaultValue,i=null!=e.checked?e.checked:e.defaultChecked;n=Ut(null!=e.value?e.value:n),t._wrapperState={initialChecked:i,initialValue:n,controlled:"checkbox"===e.type||"radio"===e.type?null!=e.checked:null!=e.value}}function Jt(t,e){null!=(e=e.checked)&&yt(t,"checked",e,!1)}function Zt(t,e){Jt(t,e);var n=Ut(e.value),i=e.type;if(null!=n)"number"===i?(0===n&&""===t.value||t.value!=n)&&(t.value=""+n):t.value!==""+n&&(t.value=""+n);else if("submit"===i||"reset"===i)return void t.removeAttribute("value");e.hasOwnProperty("value")?ee(t,e.type,n):e.hasOwnProperty("defaultValue")&&ee(t,e.type,Ut(e.defaultValue)),null==e.checked&&null!=e.defaultChecked&&(t.defaultChecked=!!e.defaultChecked)}function te(t,e,n){if(e.hasOwnProperty("value")||e.hasOwnProperty("defaultValue")){var i=e.type;if(!("submit"!==i&&"reset"!==i||void 0!==e.value&&null!==e.value))return;e=""+t._wrapperState.initialValue,n||e===t.value||(t.value=e),t.defaultValue=e}""!==(n=t.name)&&(t.name=""),t.defaultChecked=!!t._wrapperState.initialChecked,""!==n&&(t.name=n)}function ee(t,e,n){"number"===e&&Xt(t.ownerDocument)===t||(null==n?t.defaultValue=""+t._wrapperState.initialValue:t.defaultValue!==""+n&&(t.defaultValue=""+n))}var ne=Array.isArray;function ie(t,e,n,i){if(t=t.options,e){e={};for(var r=0;r<n.length;r++)e["$"+n[r]]=!0;for(n=0;n<t.length;n++)r=e.hasOwnProperty("$"+t[n].value),t[n].selected!==r&&(t[n].selected=r),r&&i&&(t[n].defaultSelected=!0)}else{for(n=""+Ut(n),e=null,r=0;r<t.length;r++){if(t[r].value===n)return t[r].selected=!0,void(i&&(t[r].defaultSelected=!0));null!==e||t[r].disabled||(e=t[r])}null!==e&&(e.selected=!0)}}function re(t,e){if(null!=e.dangerouslySetInnerHTML)throw Error(st(91));return Ft({},e,{value:void 0,defaultValue:void 0,children:""+t._wrapperState.initialValue})}function ae(t,e){var n=e.value;if(null==n){if(n=e.children,e=e.defaultValue,null!=n){if(null!=e)throw Error(st(92));if(ne(n)){if(1<n.length)throw Error(st(93));n=n[0]}e=n}null==e&&(e=""),n=e}t._wrapperState={initialValue:Ut(n)}}function se(t,e){var n=Ut(e.value),i=Ut(e.defaultValue);null!=n&&((n=""+n)!==t.value&&(t.value=n),null==e.defaultValue&&t.defaultValue!==n&&(t.defaultValue=n)),null!=i&&(t.defaultValue=""+i)}function oe(t){var e=t.textContent;e===t._wrapperState.initialValue&&""!==e&&null!==e&&(t.value=e)}function le(t){switch(t){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function ce(t,e){return null==t||"http://www.w3.org/1999/xhtml"===t?le(e):"http://www.w3.org/2000/svg"===t&&"foreignObject"===e?"http://www.w3.org/1999/xhtml":t}var ue,de,he=(de=function(t,e){if("http://www.w3.org/2000/svg"!==t.namespaceURI||"innerHTML"in t)t.innerHTML=e;else{for((ue=ue||document.createElement("div")).innerHTML="<svg>"+e.valueOf().toString()+"</svg>",e=ue.firstChild;t.firstChild;)t.removeChild(t.firstChild);for(;e.firstChild;)t.appendChild(e.firstChild)}},"undefined"!=typeof MSApp&&MSApp.execUnsafeLocalFunction?function(t,e,n,i){MSApp.execUnsafeLocalFunction((function(){return de(t,e)}))}:de);function fe(t,e){if(e){var n=t.firstChild;if(n&&n===t.lastChild&&3===n.nodeType)return void(n.nodeValue=e)}t.textContent=e}var pe={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},ge=["Webkit","ms","Moz","O"];function me(t,e,n){return null==e||"boolean"==typeof e||""===e?"":n||"number"!=typeof e||0===e||pe.hasOwnProperty(t)&&pe[t]?(""+e).trim():e+"px"}function be(t,e){for(var n in t=t.style,e)if(e.hasOwnProperty(n)){var i=0===n.indexOf("--"),r=me(n,e[n],i);"float"===n&&(n="cssFloat"),i?t.setProperty(n,r):t[n]=r}}Object.keys(pe).forEach((function(t){ge.forEach((function(e){e=e+t.charAt(0).toUpperCase()+t.substring(1),pe[e]=pe[t]}))}));var xe=Ft({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function ve(t,e){if(e){if(xe[t]&&(null!=e.children||null!=e.dangerouslySetInnerHTML))throw Error(st(137,t));if(null!=e.dangerouslySetInnerHTML){if(null!=e.children)throw Error(st(60));if("object"!=typeof e.dangerouslySetInnerHTML||!("__html"in e.dangerouslySetInnerHTML))throw Error(st(61))}if(null!=e.style&&"object"!=typeof e.style)throw Error(st(62))}}function ye(t,e){if(-1===t.indexOf("-"))return"string"==typeof e.is;switch(t){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var _e=null;function we(t){return(t=t.target||t.srcElement||window).correspondingUseElement&&(t=t.correspondingUseElement),3===t.nodeType?t.parentNode:t}var ke=null,Se=null,Ce=null;function Me(t){if(t=ya(t)){if("function"!=typeof ke)throw Error(st(280));var e=t.stateNode;e&&(e=wa(e),ke(t.stateNode,t.type,e))}}function Ee(t){Se?Ce?Ce.push(t):Ce=[t]:Se=t}function Pe(){if(Se){var t=Se,e=Ce;if(Ce=Se=null,Me(t),e)for(t=0;t<e.length;t++)Me(e[t])}}function Ne(t,e){return t(e)}function De(){}var Te=!1;function Oe(t,e,n){if(Te)return t(e,n);Te=!0;try{return Ne(t,e,n)}finally{Te=!1,(null!==Se||null!==Ce)&&(De(),Pe())}}function Le(t,e){var n=t.stateNode;if(null===n)return null;var i=wa(n);if(null===i)return null;n=i[e];t:switch(e){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(i=!i.disabled)||(i=!("button"===(t=t.type)||"input"===t||"select"===t||"textarea"===t)),t=!i;break t;default:t=!1}if(t)return null;if(n&&"function"!=typeof n)throw Error(st(231,e,typeof n));return n}var Re=!1;if(dt)try{var ze={};Object.defineProperty(ze,"passive",{get:function(){Re=!0}}),window.addEventListener("test",ze,ze),window.removeEventListener("test",ze,ze)}catch(de){Re=!1}function je(t,e,n,i,r,a,s,o,l){var c=Array.prototype.slice.call(arguments,3);try{e.apply(n,c)}catch(u){this.onError(u)}}var Ae=!1,Fe=null,Ie=!1,Ve=null,Be={onError:function(t){Ae=!0,Fe=t}};function We(t,e,n,i,r,a,s,o,l){Ae=!1,Fe=null,je.apply(Be,arguments)}function He(t){var e=t,n=t;if(t.alternate)for(;e.return;)e=e.return;else{t=e;do{!!(4098&(e=t).flags)&&(n=e.return),t=e.return}while(t)}return 3===e.tag?n:null}function $e(t){if(13===t.tag){var e=t.memoizedState;if(null===e&&(null!==(t=t.alternate)&&(e=t.memoizedState)),null!==e)return e.dehydrated}return null}function Ue(t){if(He(t)!==t)throw Error(st(188))}function Ye(t){return null!==(t=function(t){var e=t.alternate;if(!e){if(null===(e=He(t)))throw Error(st(188));return e!==t?null:t}for(var n=t,i=e;;){var r=n.return;if(null===r)break;var a=r.alternate;if(null===a){if(null!==(i=r.return)){n=i;continue}break}if(r.child===a.child){for(a=r.child;a;){if(a===n)return Ue(r),t;if(a===i)return Ue(r),e;a=a.sibling}throw Error(st(188))}if(n.return!==i.return)n=r,i=a;else{for(var s=!1,o=r.child;o;){if(o===n){s=!0,n=r,i=a;break}if(o===i){s=!0,i=r,n=a;break}o=o.sibling}if(!s){for(o=a.child;o;){if(o===n){s=!0,n=a,i=r;break}if(o===i){s=!0,i=a,n=r;break}o=o.sibling}if(!s)throw Error(st(189))}}if(n.alternate!==i)throw Error(st(190))}if(3!==n.tag)throw Error(st(188));return n.stateNode.current===n?t:e}(t))?Qe(t):null}function Qe(t){if(5===t.tag||6===t.tag)return t;for(t=t.child;null!==t;){var e=Qe(t);if(null!==e)return e;t=t.sibling}return null}var qe=at.unstable_scheduleCallback,Xe=at.unstable_cancelCallback,Ke=at.unstable_shouldYield,Ge=at.unstable_requestPaint,Je=at.unstable_now,Ze=at.unstable_getCurrentPriorityLevel,tn=at.unstable_ImmediatePriority,en=at.unstable_UserBlockingPriority,nn=at.unstable_NormalPriority,rn=at.unstable_LowPriority,an=at.unstable_IdlePriority,sn=null,on=null;var ln=Math.clz32?Math.clz32:function(t){return t>>>=0,0===t?32:31-(cn(t)/un|0)|0},cn=Math.log,un=Math.LN2;var dn=64,hn=4194304;function fn(t){switch(t&-t){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194240&t;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return 130023424&t;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return t}}function pn(t,e){var n=t.pendingLanes;if(0===n)return 0;var i=0,r=t.suspendedLanes,a=t.pingedLanes,s=268435455&n;if(0!==s){var o=s&~r;0!==o?i=fn(o):0!==(a&=s)&&(i=fn(a))}else 0!==(s=n&~r)?i=fn(s):0!==a&&(i=fn(a));if(0===i)return 0;if(0!==e&&e!==i&&!(e&r)&&((r=i&-i)>=(a=e&-e)||16===r&&4194240&a))return e;if(4&i&&(i|=16&n),0!==(e=t.entangledLanes))for(t=t.entanglements,e&=i;0<e;)r=1<<(n=31-ln(e)),i|=t[n],e&=~r;return i}function gn(t,e){switch(t){case 1:case 2:case 4:return e+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e+5e3;default:return-1}}function mn(t){return 0!==(t=-1073741825&t.pendingLanes)?t:1073741824&t?1073741824:0}function bn(){var t=dn;return!(4194240&(dn<<=1))&&(dn=64),t}function xn(t){for(var e=[],n=0;31>n;n++)e.push(t);return e}function vn(t,e,n){t.pendingLanes|=e,536870912!==e&&(t.suspendedLanes=0,t.pingedLanes=0),(t=t.eventTimes)[e=31-ln(e)]=n}function yn(t,e){var n=t.entangledLanes|=e;for(t=t.entanglements;n;){var i=31-ln(n),r=1<<i;r&e|t[i]&e&&(t[i]|=e),n&=~r}}var _n=0;function wn(t){return 1<(t&=-t)?4<t?268435455&t?16:536870912:4:1}var kn,Sn,Cn,Mn,En,Pn=!1,Nn=[],Dn=null,Tn=null,On=null,Ln=new Map,Rn=new Map,zn=[],jn="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function An(t,e){switch(t){case"focusin":case"focusout":Dn=null;break;case"dragenter":case"dragleave":Tn=null;break;case"mouseover":case"mouseout":On=null;break;case"pointerover":case"pointerout":Ln.delete(e.pointerId);break;case"gotpointercapture":case"lostpointercapture":Rn.delete(e.pointerId)}}function Fn(t,e,n,i,r,a){return null===t||t.nativeEvent!==a?(t={blockedOn:e,domEventName:n,eventSystemFlags:i,nativeEvent:a,targetContainers:[r]},null!==e&&(null!==(e=ya(e))&&Sn(e)),t):(t.eventSystemFlags|=i,e=t.targetContainers,null!==r&&-1===e.indexOf(r)&&e.push(r),t)}function In(t){var e=va(t.target);if(null!==e){var n=He(e);if(null!==n)if(13===(e=n.tag)){if(null!==(e=$e(n)))return t.blockedOn=e,void En(t.priority,(function(){Cn(n)}))}else if(3===e&&n.stateNode.current.memoizedState.isDehydrated)return void(t.blockedOn=3===n.tag?n.stateNode.containerInfo:null)}t.blockedOn=null}function Vn(t){if(null!==t.blockedOn)return!1;for(var e=t.targetContainers;0<e.length;){var n=Gn(t.domEventName,t.eventSystemFlags,e[0],t.nativeEvent);if(null!==n)return null!==(e=ya(n))&&Sn(e),t.blockedOn=n,!1;var i=new(n=t.nativeEvent).constructor(n.type,n);_e=i,n.target.dispatchEvent(i),_e=null,e.shift()}return!0}function Bn(t,e,n){Vn(t)&&n.delete(e)}function Wn(){Pn=!1,null!==Dn&&Vn(Dn)&&(Dn=null),null!==Tn&&Vn(Tn)&&(Tn=null),null!==On&&Vn(On)&&(On=null),Ln.forEach(Bn),Rn.forEach(Bn)}function Hn(t,e){t.blockedOn===e&&(t.blockedOn=null,Pn||(Pn=!0,at.unstable_scheduleCallback(at.unstable_NormalPriority,Wn)))}function $n(t){function e(e){return Hn(e,t)}if(0<Nn.length){Hn(Nn[0],t);for(var n=1;n<Nn.length;n++){var i=Nn[n];i.blockedOn===t&&(i.blockedOn=null)}}for(null!==Dn&&Hn(Dn,t),null!==Tn&&Hn(Tn,t),null!==On&&Hn(On,t),Ln.forEach(e),Rn.forEach(e),n=0;n<zn.length;n++)(i=zn[n]).blockedOn===t&&(i.blockedOn=null);for(;0<zn.length&&null===(n=zn[0]).blockedOn;)In(n),null===n.blockedOn&&zn.shift()}var Un=_t.ReactCurrentBatchConfig,Yn=!0;function Qn(t,e,n,i){var r=_n,a=Un.transition;Un.transition=null;try{_n=1,Xn(t,e,n,i)}finally{_n=r,Un.transition=a}}function qn(t,e,n,i){var r=_n,a=Un.transition;Un.transition=null;try{_n=4,Xn(t,e,n,i)}finally{_n=r,Un.transition=a}}function Xn(t,e,n,i){if(Yn){var r=Gn(t,e,n,i);if(null===r)Ur(t,e,i,Kn,n),An(t,i);else if(function(t,e,n,i,r){switch(e){case"focusin":return Dn=Fn(Dn,t,e,n,i,r),!0;case"dragenter":return Tn=Fn(Tn,t,e,n,i,r),!0;case"mouseover":return On=Fn(On,t,e,n,i,r),!0;case"pointerover":var a=r.pointerId;return Ln.set(a,Fn(Ln.get(a)||null,t,e,n,i,r)),!0;case"gotpointercapture":return a=r.pointerId,Rn.set(a,Fn(Rn.get(a)||null,t,e,n,i,r)),!0}return!1}(r,t,e,n,i))i.stopPropagation();else if(An(t,i),4&e&&-1<jn.indexOf(t)){for(;null!==r;){var a=ya(r);if(null!==a&&kn(a),null===(a=Gn(t,e,n,i))&&Ur(t,e,i,Kn,n),a===r)break;r=a}null!==r&&i.stopPropagation()}else Ur(t,e,i,null,n)}}var Kn=null;function Gn(t,e,n,i){if(Kn=null,null!==(t=va(t=we(i))))if(null===(e=He(t)))t=null;else if(13===(n=e.tag)){if(null!==(t=$e(e)))return t;t=null}else if(3===n){if(e.stateNode.current.memoizedState.isDehydrated)return 3===e.tag?e.stateNode.containerInfo:null;t=null}else e!==t&&(t=null);return Kn=t,null}function Jn(t){switch(t){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Ze()){case tn:return 1;case en:return 4;case nn:case rn:return 16;case an:return 536870912;default:return 16}default:return 16}}var Zn=null,ti=null,ei=null;function ni(){if(ei)return ei;var t,e,n=ti,i=n.length,r="value"in Zn?Zn.value:Zn.textContent,a=r.length;for(t=0;t<i&&n[t]===r[t];t++);var s=i-t;for(e=1;e<=s&&n[i-e]===r[a-e];e++);return ei=r.slice(t,1<e?1-e:void 0)}function ii(t){var e=t.keyCode;return"charCode"in t?0===(t=t.charCode)&&13===e&&(t=13):t=e,10===t&&(t=13),32<=t||13===t?t:0}function ri(){return!0}function ai(){return!1}function si(t){function e(e,n,i,r,a){for(var s in this._reactName=e,this._targetInst=i,this.type=n,this.nativeEvent=r,this.target=a,this.currentTarget=null,t)t.hasOwnProperty(s)&&(e=t[s],this[s]=e?e(r):r[s]);return this.isDefaultPrevented=(null!=r.defaultPrevented?r.defaultPrevented:!1===r.returnValue)?ri:ai,this.isPropagationStopped=ai,this}return Ft(e.prototype,{preventDefault:function(){this.defaultPrevented=!0;var t=this.nativeEvent;t&&(t.preventDefault?t.preventDefault():"unknown"!=typeof t.returnValue&&(t.returnValue=!1),this.isDefaultPrevented=ri)},stopPropagation:function(){var t=this.nativeEvent;t&&(t.stopPropagation?t.stopPropagation():"unknown"!=typeof t.cancelBubble&&(t.cancelBubble=!0),this.isPropagationStopped=ri)},persist:function(){},isPersistent:ri}),e}var oi,li,ci,ui={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(t){return t.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},di=si(ui),hi=Ft({},ui,{view:0,detail:0}),fi=si(hi),pi=Ft({},hi,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Mi,button:0,buttons:0,relatedTarget:function(t){return void 0===t.relatedTarget?t.fromElement===t.srcElement?t.toElement:t.fromElement:t.relatedTarget},movementX:function(t){return"movementX"in t?t.movementX:(t!==ci&&(ci&&"mousemove"===t.type?(oi=t.screenX-ci.screenX,li=t.screenY-ci.screenY):li=oi=0,ci=t),oi)},movementY:function(t){return"movementY"in t?t.movementY:li}}),gi=si(pi),mi=si(Ft({},pi,{dataTransfer:0})),bi=si(Ft({},hi,{relatedTarget:0})),xi=si(Ft({},ui,{animationName:0,elapsedTime:0,pseudoElement:0})),vi=Ft({},ui,{clipboardData:function(t){return"clipboardData"in t?t.clipboardData:window.clipboardData}}),yi=si(vi),_i=si(Ft({},ui,{data:0})),wi={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},ki={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Si={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Ci(t){var e=this.nativeEvent;return e.getModifierState?e.getModifierState(t):!!(t=Si[t])&&!!e[t]}function Mi(){return Ci}var Ei=Ft({},hi,{key:function(t){if(t.key){var e=wi[t.key]||t.key;if("Unidentified"!==e)return e}return"keypress"===t.type?13===(t=ii(t))?"Enter":String.fromCharCode(t):"keydown"===t.type||"keyup"===t.type?ki[t.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Mi,charCode:function(t){return"keypress"===t.type?ii(t):0},keyCode:function(t){return"keydown"===t.type||"keyup"===t.type?t.keyCode:0},which:function(t){return"keypress"===t.type?ii(t):"keydown"===t.type||"keyup"===t.type?t.keyCode:0}}),Pi=si(Ei),Ni=si(Ft({},pi,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),Di=si(Ft({},hi,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Mi})),Ti=si(Ft({},ui,{propertyName:0,elapsedTime:0,pseudoElement:0})),Oi=Ft({},pi,{deltaX:function(t){return"deltaX"in t?t.deltaX:"wheelDeltaX"in t?-t.wheelDeltaX:0},deltaY:function(t){return"deltaY"in t?t.deltaY:"wheelDeltaY"in t?-t.wheelDeltaY:"wheelDelta"in t?-t.wheelDelta:0},deltaZ:0,deltaMode:0}),Li=si(Oi),Ri=[9,13,27,32],zi=dt&&"CompositionEvent"in window,ji=null;dt&&"documentMode"in document&&(ji=document.documentMode);var Ai=dt&&"TextEvent"in window&&!ji,Fi=dt&&(!zi||ji&&8<ji&&11>=ji),Ii=String.fromCharCode(32),Vi=!1;function Bi(t,e){switch(t){case"keyup":return-1!==Ri.indexOf(e.keyCode);case"keydown":return 229!==e.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Wi(t){return"object"==typeof(t=t.detail)&&"data"in t?t.data:null}var Hi=!1;var $i={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Ui(t){var e=t&&t.nodeName&&t.nodeName.toLowerCase();return"input"===e?!!$i[t.type]:"textarea"===e}function Yi(t,e,n,i){Ee(i),0<(e=Qr(e,"onChange")).length&&(n=new di("onChange","change",null,n,i),t.push({event:n,listeners:e}))}var Qi=null,qi=null;function Xi(t){Ir(t,0)}function Ki(t){if(qt(_a(t)))return t}function Gi(t,e){if("change"===t)return e}var Ji=!1;if(dt){var Zi;if(dt){var tr="oninput"in document;if(!tr){var er=document.createElement("div");er.setAttribute("oninput","return;"),tr="function"==typeof er.oninput}Zi=tr}else Zi=!1;Ji=Zi&&(!document.documentMode||9<document.documentMode)}function nr(){Qi&&(Qi.detachEvent("onpropertychange",ir),qi=Qi=null)}function ir(t){if("value"===t.propertyName&&Ki(qi)){var e=[];Yi(e,qi,t,we(t)),Oe(Xi,e)}}function rr(t,e,n){"focusin"===t?(nr(),qi=n,(Qi=e).attachEvent("onpropertychange",ir)):"focusout"===t&&nr()}function ar(t){if("selectionchange"===t||"keyup"===t||"keydown"===t)return Ki(qi)}function sr(t,e){if("click"===t)return Ki(e)}function or(t,e){if("input"===t||"change"===t)return Ki(e)}var lr="function"==typeof Object.is?Object.is:function(t,e){return t===e&&(0!==t||1/t==1/e)||t!=t&&e!=e};function cr(t,e){if(lr(t,e))return!0;if("object"!=typeof t||null===t||"object"!=typeof e||null===e)return!1;var n=Object.keys(t),i=Object.keys(e);if(n.length!==i.length)return!1;for(i=0;i<n.length;i++){var r=n[i];if(!ht.call(e,r)||!lr(t[r],e[r]))return!1}return!0}function ur(t){for(;t&&t.firstChild;)t=t.firstChild;return t}function dr(t,e){var n,i=ur(t);for(t=0;i;){if(3===i.nodeType){if(n=t+i.textContent.length,t<=e&&n>=e)return{node:i,offset:e-t};t=n}t:{for(;i;){if(i.nextSibling){i=i.nextSibling;break t}i=i.parentNode}i=void 0}i=ur(i)}}function hr(t,e){return!(!t||!e)&&(t===e||(!t||3!==t.nodeType)&&(e&&3===e.nodeType?hr(t,e.parentNode):"contains"in t?t.contains(e):!!t.compareDocumentPosition&&!!(16&t.compareDocumentPosition(e))))}function fr(){for(var t=window,e=Xt();e instanceof t.HTMLIFrameElement;){try{var n="string"==typeof e.contentWindow.location.href}catch(i){n=!1}if(!n)break;e=Xt((t=e.contentWindow).document)}return e}function pr(t){var e=t&&t.nodeName&&t.nodeName.toLowerCase();return e&&("input"===e&&("text"===t.type||"search"===t.type||"tel"===t.type||"url"===t.type||"password"===t.type)||"textarea"===e||"true"===t.contentEditable)}function gr(t){var e=fr(),n=t.focusedElem,i=t.selectionRange;if(e!==n&&n&&n.ownerDocument&&hr(n.ownerDocument.documentElement,n)){if(null!==i&&pr(n))if(e=i.start,void 0===(t=i.end)&&(t=e),"selectionStart"in n)n.selectionStart=e,n.selectionEnd=Math.min(t,n.value.length);else if((t=(e=n.ownerDocument||document)&&e.defaultView||window).getSelection){t=t.getSelection();var r=n.textContent.length,a=Math.min(i.start,r);i=void 0===i.end?a:Math.min(i.end,r),!t.extend&&a>i&&(r=i,i=a,a=r),r=dr(n,a);var s=dr(n,i);r&&s&&(1!==t.rangeCount||t.anchorNode!==r.node||t.anchorOffset!==r.offset||t.focusNode!==s.node||t.focusOffset!==s.offset)&&((e=e.createRange()).setStart(r.node,r.offset),t.removeAllRanges(),a>i?(t.addRange(e),t.extend(s.node,s.offset)):(e.setEnd(s.node,s.offset),t.addRange(e)))}for(e=[],t=n;t=t.parentNode;)1===t.nodeType&&e.push({element:t,left:t.scrollLeft,top:t.scrollTop});for("function"==typeof n.focus&&n.focus(),n=0;n<e.length;n++)(t=e[n]).element.scrollLeft=t.left,t.element.scrollTop=t.top}}var mr=dt&&"documentMode"in document&&11>=document.documentMode,br=null,xr=null,vr=null,yr=!1;function _r(t,e,n){var i=n.window===n?n.document:9===n.nodeType?n:n.ownerDocument;yr||null==br||br!==Xt(i)||("selectionStart"in(i=br)&&pr(i)?i={start:i.selectionStart,end:i.selectionEnd}:i={anchorNode:(i=(i.ownerDocument&&i.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:i.anchorOffset,focusNode:i.focusNode,focusOffset:i.focusOffset},vr&&cr(vr,i)||(vr=i,0<(i=Qr(xr,"onSelect")).length&&(e=new di("onSelect","select",null,e,n),t.push({event:e,listeners:i}),e.target=br)))}function wr(t,e){var n={};return n[t.toLowerCase()]=e.toLowerCase(),n["Webkit"+t]="webkit"+e,n["Moz"+t]="moz"+e,n}var kr={animationend:wr("Animation","AnimationEnd"),animationiteration:wr("Animation","AnimationIteration"),animationstart:wr("Animation","AnimationStart"),transitionend:wr("Transition","TransitionEnd")},Sr={},Cr={};function Mr(t){if(Sr[t])return Sr[t];if(!kr[t])return t;var e,n=kr[t];for(e in n)if(n.hasOwnProperty(e)&&e in Cr)return Sr[t]=n[e];return t}dt&&(Cr=document.createElement("div").style,"AnimationEvent"in window||(delete kr.animationend.animation,delete kr.animationiteration.animation,delete kr.animationstart.animation),"TransitionEvent"in window||delete kr.transitionend.transition);var Er=Mr("animationend"),Pr=Mr("animationiteration"),Nr=Mr("animationstart"),Dr=Mr("transitionend"),Tr=new Map,Or="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Lr(t,e){Tr.set(t,e),ct(e,[t])}for(var Rr=0;Rr<Or.length;Rr++){var zr=Or[Rr];Lr(zr.toLowerCase(),"on"+(zr[0].toUpperCase()+zr.slice(1)))}Lr(Er,"onAnimationEnd"),Lr(Pr,"onAnimationIteration"),Lr(Nr,"onAnimationStart"),Lr("dblclick","onDoubleClick"),Lr("focusin","onFocus"),Lr("focusout","onBlur"),Lr(Dr,"onTransitionEnd"),ut("onMouseEnter",["mouseout","mouseover"]),ut("onMouseLeave",["mouseout","mouseover"]),ut("onPointerEnter",["pointerout","pointerover"]),ut("onPointerLeave",["pointerout","pointerover"]),ct("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),ct("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),ct("onBeforeInput",["compositionend","keypress","textInput","paste"]),ct("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),ct("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),ct("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var jr="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Ar=new Set("cancel close invalid load scroll toggle".split(" ").concat(jr));function Fr(t,e,n){var i=t.type||"unknown-event";t.currentTarget=n,function(t,e,n,i,r,a,s,o,l){if(We.apply(this,arguments),Ae){if(!Ae)throw Error(st(198));var c=Fe;Ae=!1,Fe=null,Ie||(Ie=!0,Ve=c)}}(i,e,void 0,t),t.currentTarget=null}function Ir(t,e){e=!!(4&e);for(var n=0;n<t.length;n++){var i=t[n],r=i.event;i=i.listeners;t:{var a=void 0;if(e)for(var s=i.length-1;0<=s;s--){var o=i[s],l=o.instance,c=o.currentTarget;if(o=o.listener,l!==a&&r.isPropagationStopped())break t;Fr(r,o,c),a=l}else for(s=0;s<i.length;s++){if(l=(o=i[s]).instance,c=o.currentTarget,o=o.listener,l!==a&&r.isPropagationStopped())break t;Fr(r,o,c),a=l}}}if(Ie)throw t=Ve,Ie=!1,Ve=null,t}function Vr(t,e){var n=e[ma];void 0===n&&(n=e[ma]=new Set);var i=t+"__bubble";n.has(i)||($r(e,t,2,!1),n.add(i))}function Br(t,e,n){var i=0;e&&(i|=4),$r(n,t,i,e)}var Wr="_reactListening"+Math.random().toString(36).slice(2);function Hr(t){if(!t[Wr]){t[Wr]=!0,ot.forEach((function(e){"selectionchange"!==e&&(Ar.has(e)||Br(e,!1,t),Br(e,!0,t))}));var e=9===t.nodeType?t:t.ownerDocument;null===e||e[Wr]||(e[Wr]=!0,Br("selectionchange",!1,e))}}function $r(t,e,n,i){switch(Jn(e)){case 1:var r=Qn;break;case 4:r=qn;break;default:r=Xn}n=r.bind(null,e,n,t),r=void 0,!Re||"touchstart"!==e&&"touchmove"!==e&&"wheel"!==e||(r=!0),i?void 0!==r?t.addEventListener(e,n,{capture:!0,passive:r}):t.addEventListener(e,n,!0):void 0!==r?t.addEventListener(e,n,{passive:r}):t.addEventListener(e,n,!1)}function Ur(t,e,n,i,r){var a=i;if(!(1&e||2&e||null===i))t:for(;;){if(null===i)return;var s=i.tag;if(3===s||4===s){var o=i.stateNode.containerInfo;if(o===r||8===o.nodeType&&o.parentNode===r)break;if(4===s)for(s=i.return;null!==s;){var l=s.tag;if((3===l||4===l)&&((l=s.stateNode.containerInfo)===r||8===l.nodeType&&l.parentNode===r))return;s=s.return}for(;null!==o;){if(null===(s=va(o)))return;if(5===(l=s.tag)||6===l){i=a=s;continue t}o=o.parentNode}}i=i.return}Oe((function(){var i=a,r=we(n),s=[];t:{var o=Tr.get(t);if(void 0!==o){var l=di,c=t;switch(t){case"keypress":if(0===ii(n))break t;case"keydown":case"keyup":l=Pi;break;case"focusin":c="focus",l=bi;break;case"focusout":c="blur",l=bi;break;case"beforeblur":case"afterblur":l=bi;break;case"click":if(2===n.button)break t;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":l=gi;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":l=mi;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":l=Di;break;case Er:case Pr:case Nr:l=xi;break;case Dr:l=Ti;break;case"scroll":l=fi;break;case"wheel":l=Li;break;case"copy":case"cut":case"paste":l=yi;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":l=Ni}var u=!!(4&e),d=!u&&"scroll"===t,h=u?null!==o?o+"Capture":null:o;u=[];for(var f,p=i;null!==p;){var g=(f=p).stateNode;if(5===f.tag&&null!==g&&(f=g,null!==h&&(null!=(g=Le(p,h))&&u.push(Yr(p,g,f)))),d)break;p=p.return}0<u.length&&(o=new l(o,c,null,n,r),s.push({event:o,listeners:u}))}}if(!(7&e)){if(l="mouseout"===t||"pointerout"===t,(!(o="mouseover"===t||"pointerover"===t)||n===_e||!(c=n.relatedTarget||n.fromElement)||!va(c)&&!c[ga])&&(l||o)&&(o=r.window===r?r:(o=r.ownerDocument)?o.defaultView||o.parentWindow:window,l?(l=i,null!==(c=(c=n.relatedTarget||n.toElement)?va(c):null)&&(c!==(d=He(c))||5!==c.tag&&6!==c.tag)&&(c=null)):(l=null,c=i),l!==c)){if(u=gi,g="onMouseLeave",h="onMouseEnter",p="mouse","pointerout"!==t&&"pointerover"!==t||(u=Ni,g="onPointerLeave",h="onPointerEnter",p="pointer"),d=null==l?o:_a(l),f=null==c?o:_a(c),(o=new u(g,p+"leave",l,n,r)).target=d,o.relatedTarget=f,g=null,va(r)===i&&((u=new u(h,p+"enter",c,n,r)).target=f,u.relatedTarget=d,g=u),d=g,l&&c)t:{for(h=c,p=0,f=u=l;f;f=qr(f))p++;for(f=0,g=h;g;g=qr(g))f++;for(;0<p-f;)u=qr(u),p--;for(;0<f-p;)h=qr(h),f--;for(;p--;){if(u===h||null!==h&&u===h.alternate)break t;u=qr(u),h=qr(h)}u=null}else u=null;null!==l&&Xr(s,o,l,u,!1),null!==c&&null!==d&&Xr(s,d,c,u,!0)}if("select"===(l=(o=i?_a(i):window).nodeName&&o.nodeName.toLowerCase())||"input"===l&&"file"===o.type)var m=Gi;else if(Ui(o))if(Ji)m=or;else{m=ar;var b=rr}else(l=o.nodeName)&&"input"===l.toLowerCase()&&("checkbox"===o.type||"radio"===o.type)&&(m=sr);switch(m&&(m=m(t,i))?Yi(s,m,n,r):(b&&b(t,o,i),"focusout"===t&&(b=o._wrapperState)&&b.controlled&&"number"===o.type&&ee(o,"number",o.value)),b=i?_a(i):window,t){case"focusin":(Ui(b)||"true"===b.contentEditable)&&(br=b,xr=i,vr=null);break;case"focusout":vr=xr=br=null;break;case"mousedown":yr=!0;break;case"contextmenu":case"mouseup":case"dragend":yr=!1,_r(s,n,r);break;case"selectionchange":if(mr)break;case"keydown":case"keyup":_r(s,n,r)}var x;if(zi)t:{switch(t){case"compositionstart":var v="onCompositionStart";break t;case"compositionend":v="onCompositionEnd";break t;case"compositionupdate":v="onCompositionUpdate";break t}v=void 0}else Hi?Bi(t,n)&&(v="onCompositionEnd"):"keydown"===t&&229===n.keyCode&&(v="onCompositionStart");v&&(Fi&&"ko"!==n.locale&&(Hi||"onCompositionStart"!==v?"onCompositionEnd"===v&&Hi&&(x=ni()):(ti="value"in(Zn=r)?Zn.value:Zn.textContent,Hi=!0)),0<(b=Qr(i,v)).length&&(v=new _i(v,t,null,n,r),s.push({event:v,listeners:b}),x?v.data=x:null!==(x=Wi(n))&&(v.data=x))),(x=Ai?function(t,e){switch(t){case"compositionend":return Wi(e);case"keypress":return 32!==e.which?null:(Vi=!0,Ii);case"textInput":return(t=e.data)===Ii&&Vi?null:t;default:return null}}(t,n):function(t,e){if(Hi)return"compositionend"===t||!zi&&Bi(t,e)?(t=ni(),ei=ti=Zn=null,Hi=!1,t):null;switch(t){case"paste":default:return null;case"keypress":if(!(e.ctrlKey||e.altKey||e.metaKey)||e.ctrlKey&&e.altKey){if(e.char&&1<e.char.length)return e.char;if(e.which)return String.fromCharCode(e.which)}return null;case"compositionend":return Fi&&"ko"!==e.locale?null:e.data}}(t,n))&&(0<(i=Qr(i,"onBeforeInput")).length&&(r=new _i("onBeforeInput","beforeinput",null,n,r),s.push({event:r,listeners:i}),r.data=x))}Ir(s,e)}))}function Yr(t,e,n){return{instance:t,listener:e,currentTarget:n}}function Qr(t,e){for(var n=e+"Capture",i=[];null!==t;){var r=t,a=r.stateNode;5===r.tag&&null!==a&&(r=a,null!=(a=Le(t,n))&&i.unshift(Yr(t,a,r)),null!=(a=Le(t,e))&&i.push(Yr(t,a,r))),t=t.return}return i}function qr(t){if(null===t)return null;do{t=t.return}while(t&&5!==t.tag);return t||null}function Xr(t,e,n,i,r){for(var a=e._reactName,s=[];null!==n&&n!==i;){var o=n,l=o.alternate,c=o.stateNode;if(null!==l&&l===i)break;5===o.tag&&null!==c&&(o=c,r?null!=(l=Le(n,a))&&s.unshift(Yr(n,l,o)):r||null!=(l=Le(n,a))&&s.push(Yr(n,l,o))),n=n.return}0!==s.length&&t.push({event:e,listeners:s})}var Kr=/\r\n?/g,Gr=/\u0000|\uFFFD/g;function Jr(t){return("string"==typeof t?t:""+t).replace(Kr,"\n").replace(Gr,"")}function Zr(t,e,n){if(e=Jr(e),Jr(t)!==e&&n)throw Error(st(425))}function ta(){}var ea=null,na=null;function ia(t,e){return"textarea"===t||"noscript"===t||"string"==typeof e.children||"number"==typeof e.children||"object"==typeof e.dangerouslySetInnerHTML&&null!==e.dangerouslySetInnerHTML&&null!=e.dangerouslySetInnerHTML.__html}var ra="function"==typeof setTimeout?setTimeout:void 0,aa="function"==typeof clearTimeout?clearTimeout:void 0,sa="function"==typeof Promise?Promise:void 0,oa="function"==typeof queueMicrotask?queueMicrotask:void 0!==sa?function(t){return sa.resolve(null).then(t).catch(la)}:ra;function la(t){setTimeout((function(){throw t}))}function ca(t,e){var n=e,i=0;do{var r=n.nextSibling;if(t.removeChild(n),r&&8===r.nodeType)if("/$"===(n=r.data)){if(0===i)return t.removeChild(r),void $n(e);i--}else"$"!==n&&"$?"!==n&&"$!"!==n||i++;n=r}while(n);$n(e)}function ua(t){for(;null!=t;t=t.nextSibling){var e=t.nodeType;if(1===e||3===e)break;if(8===e){if("$"===(e=t.data)||"$!"===e||"$?"===e)break;if("/$"===e)return null}}return t}function da(t){t=t.previousSibling;for(var e=0;t;){if(8===t.nodeType){var n=t.data;if("$"===n||"$!"===n||"$?"===n){if(0===e)return t;e--}else"/$"===n&&e++}t=t.previousSibling}return null}var ha=Math.random().toString(36).slice(2),fa="__reactFiber$"+ha,pa="__reactProps$"+ha,ga="__reactContainer$"+ha,ma="__reactEvents$"+ha,ba="__reactListeners$"+ha,xa="__reactHandles$"+ha;function va(t){var e=t[fa];if(e)return e;for(var n=t.parentNode;n;){if(e=n[ga]||n[fa]){if(n=e.alternate,null!==e.child||null!==n&&null!==n.child)for(t=da(t);null!==t;){if(n=t[fa])return n;t=da(t)}return e}n=(t=n).parentNode}return null}function ya(t){return!(t=t[fa]||t[ga])||5!==t.tag&&6!==t.tag&&13!==t.tag&&3!==t.tag?null:t}function _a(t){if(5===t.tag||6===t.tag)return t.stateNode;throw Error(st(33))}function wa(t){return t[pa]||null}var ka=[],Sa=-1;function Ca(t){return{current:t}}function Ma(t){0>Sa||(t.current=ka[Sa],ka[Sa]=null,Sa--)}function Ea(t,e){Sa++,ka[Sa]=t.current,t.current=e}var Pa={},Na=Ca(Pa),Da=Ca(!1),Ta=Pa;function Oa(t,e){var n=t.type.contextTypes;if(!n)return Pa;var i=t.stateNode;if(i&&i.__reactInternalMemoizedUnmaskedChildContext===e)return i.__reactInternalMemoizedMaskedChildContext;var r,a={};for(r in n)a[r]=e[r];return i&&((t=t.stateNode).__reactInternalMemoizedUnmaskedChildContext=e,t.__reactInternalMemoizedMaskedChildContext=a),a}function La(t){return null!=(t=t.childContextTypes)}function Ra(){Ma(Da),Ma(Na)}function za(t,e,n){if(Na.current!==Pa)throw Error(st(168));Ea(Na,e),Ea(Da,n)}function ja(t,e,n){var i=t.stateNode;if(e=e.childContextTypes,"function"!=typeof i.getChildContext)return n;for(var r in i=i.getChildContext())if(!(r in e))throw Error(st(108,$t(t)||"Unknown",r));return Ft({},n,i)}function Aa(t){return t=(t=t.stateNode)&&t.__reactInternalMemoizedMergedChildContext||Pa,Ta=Na.current,Ea(Na,t),Ea(Da,Da.current),!0}function Fa(t,e,n){var i=t.stateNode;if(!i)throw Error(st(169));n?(t=ja(t,e,Ta),i.__reactInternalMemoizedMergedChildContext=t,Ma(Da),Ma(Na),Ea(Na,t)):Ma(Da),Ea(Da,n)}var Ia=null,Va=!1,Ba=!1;function Wa(t){null===Ia?Ia=[t]:Ia.push(t)}function Ha(){if(!Ba&&null!==Ia){Ba=!0;var t=0,e=_n;try{var n=Ia;for(_n=1;t<n.length;t++){var i=n[t];do{i=i(!0)}while(null!==i)}Ia=null,Va=!1}catch(r){throw null!==Ia&&(Ia=Ia.slice(t+1)),qe(tn,Ha),r}finally{_n=e,Ba=!1}}return null}var $a=[],Ua=0,Ya=null,Qa=0,qa=[],Xa=0,Ka=null,Ga=1,Ja="";function Za(t,e){$a[Ua++]=Qa,$a[Ua++]=Ya,Ya=t,Qa=e}function ts(t,e,n){qa[Xa++]=Ga,qa[Xa++]=Ja,qa[Xa++]=Ka,Ka=t;var i=Ga;t=Ja;var r=32-ln(i)-1;i&=~(1<<r),n+=1;var a=32-ln(e)+r;if(30<a){var s=r-r%5;a=(i&(1<<s)-1).toString(32),i>>=s,r-=s,Ga=1<<32-ln(e)+r|n<<r|i,Ja=a+t}else Ga=1<<a|n<<r|i,Ja=t}function es(t){null!==t.return&&(Za(t,1),ts(t,1,0))}function ns(t){for(;t===Ya;)Ya=$a[--Ua],$a[Ua]=null,Qa=$a[--Ua],$a[Ua]=null;for(;t===Ka;)Ka=qa[--Xa],qa[Xa]=null,Ja=qa[--Xa],qa[Xa]=null,Ga=qa[--Xa],qa[Xa]=null}var is=null,rs=null,as=!1,ss=null;function os(t,e){var n=Ou(5,null,null,0);n.elementType="DELETED",n.stateNode=e,n.return=t,null===(e=t.deletions)?(t.deletions=[n],t.flags|=16):e.push(n)}function ls(t,e){switch(t.tag){case 5:var n=t.type;return null!==(e=1!==e.nodeType||n.toLowerCase()!==e.nodeName.toLowerCase()?null:e)&&(t.stateNode=e,is=t,rs=ua(e.firstChild),!0);case 6:return null!==(e=""===t.pendingProps||3!==e.nodeType?null:e)&&(t.stateNode=e,is=t,rs=null,!0);case 13:return null!==(e=8!==e.nodeType?null:e)&&(n=null!==Ka?{id:Ga,overflow:Ja}:null,t.memoizedState={dehydrated:e,treeContext:n,retryLane:1073741824},(n=Ou(18,null,null,0)).stateNode=e,n.return=t,t.child=n,is=t,rs=null,!0);default:return!1}}function cs(t){return!(!(1&t.mode)||128&t.flags)}function us(t){if(as){var e=rs;if(e){var n=e;if(!ls(t,e)){if(cs(t))throw Error(st(418));e=ua(n.nextSibling);var i=is;e&&ls(t,e)?os(i,n):(t.flags=-4097&t.flags|2,as=!1,is=t)}}else{if(cs(t))throw Error(st(418));t.flags=-4097&t.flags|2,as=!1,is=t}}}function ds(t){for(t=t.return;null!==t&&5!==t.tag&&3!==t.tag&&13!==t.tag;)t=t.return;is=t}function hs(t){if(t!==is)return!1;if(!as)return ds(t),as=!0,!1;var e;if((e=3!==t.tag)&&!(e=5!==t.tag)&&(e="head"!==(e=t.type)&&"body"!==e&&!ia(t.type,t.memoizedProps)),e&&(e=rs)){if(cs(t))throw fs(),Error(st(418));for(;e;)os(t,e),e=ua(e.nextSibling)}if(ds(t),13===t.tag){if(!(t=null!==(t=t.memoizedState)?t.dehydrated:null))throw Error(st(317));t:{for(t=t.nextSibling,e=0;t;){if(8===t.nodeType){var n=t.data;if("/$"===n){if(0===e){rs=ua(t.nextSibling);break t}e--}else"$"!==n&&"$!"!==n&&"$?"!==n||e++}t=t.nextSibling}rs=null}}else rs=is?ua(t.stateNode.nextSibling):null;return!0}function fs(){for(var t=rs;t;)t=ua(t.nextSibling)}function ps(){rs=is=null,as=!1}function gs(t){null===ss?ss=[t]:ss.push(t)}var ms=_t.ReactCurrentBatchConfig;function bs(t,e,n){if(null!==(t=n.ref)&&"function"!=typeof t&&"object"!=typeof t){if(n._owner){if(n=n._owner){if(1!==n.tag)throw Error(st(309));var i=n.stateNode}if(!i)throw Error(st(147,t));var r=i,a=""+t;return null!==e&&null!==e.ref&&"function"==typeof e.ref&&e.ref._stringRef===a?e.ref:((e=function(t){var e=r.refs;null===t?delete e[a]:e[a]=t})._stringRef=a,e)}if("string"!=typeof t)throw Error(st(284));if(!n._owner)throw Error(st(290,t))}return t}function xs(t,e){throw t=Object.prototype.toString.call(e),Error(st(31,"[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t))}function vs(t){return(0,t._init)(t._payload)}function ys(t){function e(e,n){if(t){var i=e.deletions;null===i?(e.deletions=[n],e.flags|=16):i.push(n)}}function n(n,i){if(!t)return null;for(;null!==i;)e(n,i),i=i.sibling;return null}function i(t,e){for(t=new Map;null!==e;)null!==e.key?t.set(e.key,e):t.set(e.index,e),e=e.sibling;return t}function r(t,e){return(t=Ru(t,e)).index=0,t.sibling=null,t}function a(e,n,i){return e.index=i,t?null!==(i=e.alternate)?(i=i.index)<n?(e.flags|=2,n):i:(e.flags|=2,n):(e.flags|=1048576,n)}function s(e){return t&&null===e.alternate&&(e.flags|=2),e}function o(t,e,n,i){return null===e||6!==e.tag?((e=Fu(n,t.mode,i)).return=t,e):((e=r(e,n)).return=t,e)}function l(t,e,n,i){var a=n.type;return a===St?u(t,e,n.props.children,i,n.key):null!==e&&(e.elementType===a||"object"==typeof a&&null!==a&&a.$$typeof===Lt&&vs(a)===e.type)?((i=r(e,n.props)).ref=bs(t,e,n),i.return=t,i):((i=zu(n.type,n.key,n.props,null,t.mode,i)).ref=bs(t,e,n),i.return=t,i)}function c(t,e,n,i){return null===e||4!==e.tag||e.stateNode.containerInfo!==n.containerInfo||e.stateNode.implementation!==n.implementation?((e=Iu(n,t.mode,i)).return=t,e):((e=r(e,n.children||[])).return=t,e)}function u(t,e,n,i,a){return null===e||7!==e.tag?((e=ju(n,t.mode,i,a)).return=t,e):((e=r(e,n)).return=t,e)}function d(t,e,n){if("string"==typeof e&&""!==e||"number"==typeof e)return(e=Fu(""+e,t.mode,n)).return=t,e;if("object"==typeof e&&null!==e){switch(e.$$typeof){case wt:return(n=zu(e.type,e.key,e.props,null,t.mode,n)).ref=bs(t,null,e),n.return=t,n;case kt:return(e=Iu(e,t.mode,n)).return=t,e;case Lt:return d(t,(0,e._init)(e._payload),n)}if(ne(e)||jt(e))return(e=ju(e,t.mode,n,null)).return=t,e;xs(t,e)}return null}function h(t,e,n,i){var r=null!==e?e.key:null;if("string"==typeof n&&""!==n||"number"==typeof n)return null!==r?null:o(t,e,""+n,i);if("object"==typeof n&&null!==n){switch(n.$$typeof){case wt:return n.key===r?l(t,e,n,i):null;case kt:return n.key===r?c(t,e,n,i):null;case Lt:return h(t,e,(r=n._init)(n._payload),i)}if(ne(n)||jt(n))return null!==r?null:u(t,e,n,i,null);xs(t,n)}return null}function f(t,e,n,i,r){if("string"==typeof i&&""!==i||"number"==typeof i)return o(e,t=t.get(n)||null,""+i,r);if("object"==typeof i&&null!==i){switch(i.$$typeof){case wt:return l(e,t=t.get(null===i.key?n:i.key)||null,i,r);case kt:return c(e,t=t.get(null===i.key?n:i.key)||null,i,r);case Lt:return f(t,e,n,(0,i._init)(i._payload),r)}if(ne(i)||jt(i))return u(e,t=t.get(n)||null,i,r,null);xs(e,i)}return null}return function o(l,c,u,p){if("object"==typeof u&&null!==u&&u.type===St&&null===u.key&&(u=u.props.children),"object"==typeof u&&null!==u){switch(u.$$typeof){case wt:t:{for(var g=u.key,m=c;null!==m;){if(m.key===g){if((g=u.type)===St){if(7===m.tag){n(l,m.sibling),(c=r(m,u.props.children)).return=l,l=c;break t}}else if(m.elementType===g||"object"==typeof g&&null!==g&&g.$$typeof===Lt&&vs(g)===m.type){n(l,m.sibling),(c=r(m,u.props)).ref=bs(l,m,u),c.return=l,l=c;break t}n(l,m);break}e(l,m),m=m.sibling}u.type===St?((c=ju(u.props.children,l.mode,p,u.key)).return=l,l=c):((p=zu(u.type,u.key,u.props,null,l.mode,p)).ref=bs(l,c,u),p.return=l,l=p)}return s(l);case kt:t:{for(m=u.key;null!==c;){if(c.key===m){if(4===c.tag&&c.stateNode.containerInfo===u.containerInfo&&c.stateNode.implementation===u.implementation){n(l,c.sibling),(c=r(c,u.children||[])).return=l,l=c;break t}n(l,c);break}e(l,c),c=c.sibling}(c=Iu(u,l.mode,p)).return=l,l=c}return s(l);case Lt:return o(l,c,(m=u._init)(u._payload),p)}if(ne(u))return function(r,s,o,l){for(var c=null,u=null,p=s,g=s=0,m=null;null!==p&&g<o.length;g++){p.index>g?(m=p,p=null):m=p.sibling;var b=h(r,p,o[g],l);if(null===b){null===p&&(p=m);break}t&&p&&null===b.alternate&&e(r,p),s=a(b,s,g),null===u?c=b:u.sibling=b,u=b,p=m}if(g===o.length)return n(r,p),as&&Za(r,g),c;if(null===p){for(;g<o.length;g++)null!==(p=d(r,o[g],l))&&(s=a(p,s,g),null===u?c=p:u.sibling=p,u=p);return as&&Za(r,g),c}for(p=i(r,p);g<o.length;g++)null!==(m=f(p,r,g,o[g],l))&&(t&&null!==m.alternate&&p.delete(null===m.key?g:m.key),s=a(m,s,g),null===u?c=m:u.sibling=m,u=m);return t&&p.forEach((function(t){return e(r,t)})),as&&Za(r,g),c}(l,c,u,p);if(jt(u))return function(r,s,o,l){var c=jt(o);if("function"!=typeof c)throw Error(st(150));if(null==(o=c.call(o)))throw Error(st(151));for(var u=c=null,p=s,g=s=0,m=null,b=o.next();null!==p&&!b.done;g++,b=o.next()){p.index>g?(m=p,p=null):m=p.sibling;var x=h(r,p,b.value,l);if(null===x){null===p&&(p=m);break}t&&p&&null===x.alternate&&e(r,p),s=a(x,s,g),null===u?c=x:u.sibling=x,u=x,p=m}if(b.done)return n(r,p),as&&Za(r,g),c;if(null===p){for(;!b.done;g++,b=o.next())null!==(b=d(r,b.value,l))&&(s=a(b,s,g),null===u?c=b:u.sibling=b,u=b);return as&&Za(r,g),c}for(p=i(r,p);!b.done;g++,b=o.next())null!==(b=f(p,r,g,b.value,l))&&(t&&null!==b.alternate&&p.delete(null===b.key?g:b.key),s=a(b,s,g),null===u?c=b:u.sibling=b,u=b);return t&&p.forEach((function(t){return e(r,t)})),as&&Za(r,g),c}(l,c,u,p);xs(l,u)}return"string"==typeof u&&""!==u||"number"==typeof u?(u=""+u,null!==c&&6===c.tag?(n(l,c.sibling),(c=r(c,u)).return=l,l=c):(n(l,c),(c=Fu(u,l.mode,p)).return=l,l=c),s(l)):n(l,c)}}var _s=ys(!0),ws=ys(!1),ks=Ca(null),Ss=null,Cs=null,Ms=null;function Es(){Ms=Cs=Ss=null}function Ps(t){var e=ks.current;Ma(ks),t._currentValue=e}function Ns(t,e,n){for(;null!==t;){var i=t.alternate;if((t.childLanes&e)!==e?(t.childLanes|=e,null!==i&&(i.childLanes|=e)):null!==i&&(i.childLanes&e)!==e&&(i.childLanes|=e),t===n)break;t=t.return}}function Ds(t,e){Ss=t,Ms=Cs=null,null!==(t=t.dependencies)&&null!==t.firstContext&&(!!(t.lanes&e)&&(yl=!0),t.firstContext=null)}function Ts(t){var e=t._currentValue;if(Ms!==t)if(t={context:t,memoizedValue:e,next:null},null===Cs){if(null===Ss)throw Error(st(308));Cs=t,Ss.dependencies={lanes:0,firstContext:t}}else Cs=Cs.next=t;return e}var Os=null;function Ls(t){null===Os?Os=[t]:Os.push(t)}function Rs(t,e,n,i){var r=e.interleaved;return null===r?(n.next=n,Ls(e)):(n.next=r.next,r.next=n),e.interleaved=n,zs(t,i)}function zs(t,e){t.lanes|=e;var n=t.alternate;for(null!==n&&(n.lanes|=e),n=t,t=t.return;null!==t;)t.childLanes|=e,null!==(n=t.alternate)&&(n.childLanes|=e),n=t,t=t.return;return 3===n.tag?n.stateNode:null}var js=!1;function As(t){t.updateQueue={baseState:t.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function Fs(t,e){t=t.updateQueue,e.updateQueue===t&&(e.updateQueue={baseState:t.baseState,firstBaseUpdate:t.firstBaseUpdate,lastBaseUpdate:t.lastBaseUpdate,shared:t.shared,effects:t.effects})}function Is(t,e){return{eventTime:t,lane:e,tag:0,payload:null,callback:null,next:null}}function Vs(t,e,n){var i=t.updateQueue;if(null===i)return null;if(i=i.shared,2&Nc){var r=i.pending;return null===r?e.next=e:(e.next=r.next,r.next=e),i.pending=e,zs(t,n)}return null===(r=i.interleaved)?(e.next=e,Ls(i)):(e.next=r.next,r.next=e),i.interleaved=e,zs(t,n)}function Bs(t,e,n){if(null!==(e=e.updateQueue)&&(e=e.shared,4194240&n)){var i=e.lanes;n|=i&=t.pendingLanes,e.lanes=n,yn(t,n)}}function Ws(t,e){var n=t.updateQueue,i=t.alternate;if(null!==i&&n===(i=i.updateQueue)){var r=null,a=null;if(null!==(n=n.firstBaseUpdate)){do{var s={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};null===a?r=a=s:a=a.next=s,n=n.next}while(null!==n);null===a?r=a=e:a=a.next=e}else r=a=e;return n={baseState:i.baseState,firstBaseUpdate:r,lastBaseUpdate:a,shared:i.shared,effects:i.effects},void(t.updateQueue=n)}null===(t=n.lastBaseUpdate)?n.firstBaseUpdate=e:t.next=e,n.lastBaseUpdate=e}function Hs(t,e,n,i){var r=t.updateQueue;js=!1;var a=r.firstBaseUpdate,s=r.lastBaseUpdate,o=r.shared.pending;if(null!==o){r.shared.pending=null;var l=o,c=l.next;l.next=null,null===s?a=c:s.next=c,s=l;var u=t.alternate;null!==u&&((o=(u=u.updateQueue).lastBaseUpdate)!==s&&(null===o?u.firstBaseUpdate=c:o.next=c,u.lastBaseUpdate=l))}if(null!==a){var d=r.baseState;for(s=0,u=c=l=null,o=a;;){var h=o.lane,f=o.eventTime;if((i&h)===h){null!==u&&(u=u.next={eventTime:f,lane:0,tag:o.tag,payload:o.payload,callback:o.callback,next:null});t:{var p=t,g=o;switch(h=e,f=n,g.tag){case 1:if("function"==typeof(p=g.payload)){d=p.call(f,d,h);break t}d=p;break t;case 3:p.flags=-65537&p.flags|128;case 0:if(null==(h="function"==typeof(p=g.payload)?p.call(f,d,h):p))break t;d=Ft({},d,h);break t;case 2:js=!0}}null!==o.callback&&0!==o.lane&&(t.flags|=64,null===(h=r.effects)?r.effects=[o]:h.push(o))}else f={eventTime:f,lane:h,tag:o.tag,payload:o.payload,callback:o.callback,next:null},null===u?(c=u=f,l=d):u=u.next=f,s|=h;if(null===(o=o.next)){if(null===(o=r.shared.pending))break;o=(h=o).next,h.next=null,r.lastBaseUpdate=h,r.shared.pending=null}}if(null===u&&(l=d),r.baseState=l,r.firstBaseUpdate=c,r.lastBaseUpdate=u,null!==(e=r.shared.interleaved)){r=e;do{s|=r.lane,r=r.next}while(r!==e)}else null===a&&(r.shared.lanes=0);Ac|=s,t.lanes=s,t.memoizedState=d}}function $s(t,e,n){if(t=e.effects,e.effects=null,null!==t)for(e=0;e<t.length;e++){var i=t[e],r=i.callback;if(null!==r){if(i.callback=null,i=n,"function"!=typeof r)throw Error(st(191,r));r.call(i)}}}var Us={},Ys=Ca(Us),Qs=Ca(Us),qs=Ca(Us);function Xs(t){if(t===Us)throw Error(st(174));return t}function Ks(t,e){switch(Ea(qs,e),Ea(Qs,t),Ea(Ys,Us),t=e.nodeType){case 9:case 11:e=(e=e.documentElement)?e.namespaceURI:ce(null,"");break;default:e=ce(e=(t=8===t?e.parentNode:e).namespaceURI||null,t=t.tagName)}Ma(Ys),Ea(Ys,e)}function Gs(){Ma(Ys),Ma(Qs),Ma(qs)}function Js(t){Xs(qs.current);var e=Xs(Ys.current),n=ce(e,t.type);e!==n&&(Ea(Qs,t),Ea(Ys,n))}function Zs(t){Qs.current===t&&(Ma(Ys),Ma(Qs))}var to=Ca(0);function eo(t){for(var e=t;null!==e;){if(13===e.tag){var n=e.memoizedState;if(null!==n&&(null===(n=n.dehydrated)||"$?"===n.data||"$!"===n.data))return e}else if(19===e.tag&&void 0!==e.memoizedProps.revealOrder){if(128&e.flags)return e}else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===t)break;for(;null===e.sibling;){if(null===e.return||e.return===t)return null;e=e.return}e.sibling.return=e.return,e=e.sibling}return null}var no=[];function io(){for(var t=0;t<no.length;t++)no[t]._workInProgressVersionPrimary=null;no.length=0}var ro=_t.ReactCurrentDispatcher,ao=_t.ReactCurrentBatchConfig,so=0,oo=null,lo=null,co=null,uo=!1,ho=!1,fo=0,po=0;function go(){throw Error(st(321))}function mo(t,e){if(null===e)return!1;for(var n=0;n<e.length&&n<t.length;n++)if(!lr(t[n],e[n]))return!1;return!0}function bo(t,e,n,i,r,a){if(so=a,oo=e,e.memoizedState=null,e.updateQueue=null,e.lanes=0,ro.current=null===t||null===t.memoizedState?tl:el,t=n(i,r),ho){a=0;do{if(ho=!1,fo=0,25<=a)throw Error(st(301));a+=1,co=lo=null,e.updateQueue=null,ro.current=nl,t=n(i,r)}while(ho)}if(ro.current=Zo,e=null!==lo&&null!==lo.next,so=0,co=lo=oo=null,uo=!1,e)throw Error(st(300));return t}function xo(){var t=0!==fo;return fo=0,t}function vo(){var t={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===co?oo.memoizedState=co=t:co=co.next=t,co}function yo(){if(null===lo){var t=oo.alternate;t=null!==t?t.memoizedState:null}else t=lo.next;var e=null===co?oo.memoizedState:co.next;if(null!==e)co=e,lo=t;else{if(null===t)throw Error(st(310));t={memoizedState:(lo=t).memoizedState,baseState:lo.baseState,baseQueue:lo.baseQueue,queue:lo.queue,next:null},null===co?oo.memoizedState=co=t:co=co.next=t}return co}function _o(t,e){return"function"==typeof e?e(t):e}function wo(t){var e=yo(),n=e.queue;if(null===n)throw Error(st(311));n.lastRenderedReducer=t;var i=lo,r=i.baseQueue,a=n.pending;if(null!==a){if(null!==r){var s=r.next;r.next=a.next,a.next=s}i.baseQueue=r=a,n.pending=null}if(null!==r){a=r.next,i=i.baseState;var o=s=null,l=null,c=a;do{var u=c.lane;if((so&u)===u)null!==l&&(l=l.next={lane:0,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null}),i=c.hasEagerState?c.eagerState:t(i,c.action);else{var d={lane:u,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null};null===l?(o=l=d,s=i):l=l.next=d,oo.lanes|=u,Ac|=u}c=c.next}while(null!==c&&c!==a);null===l?s=i:l.next=o,lr(i,e.memoizedState)||(yl=!0),e.memoizedState=i,e.baseState=s,e.baseQueue=l,n.lastRenderedState=i}if(null!==(t=n.interleaved)){r=t;do{a=r.lane,oo.lanes|=a,Ac|=a,r=r.next}while(r!==t)}else null===r&&(n.lanes=0);return[e.memoizedState,n.dispatch]}function ko(t){var e=yo(),n=e.queue;if(null===n)throw Error(st(311));n.lastRenderedReducer=t;var i=n.dispatch,r=n.pending,a=e.memoizedState;if(null!==r){n.pending=null;var s=r=r.next;do{a=t(a,s.action),s=s.next}while(s!==r);lr(a,e.memoizedState)||(yl=!0),e.memoizedState=a,null===e.baseQueue&&(e.baseState=a),n.lastRenderedState=a}return[a,i]}function So(){}function Co(t,e){var n=oo,i=yo(),r=e(),a=!lr(i.memoizedState,r);if(a&&(i.memoizedState=r,yl=!0),i=i.queue,Ao(Po.bind(null,n,i,t),[t]),i.getSnapshot!==e||a||null!==co&&1&co.memoizedState.tag){if(n.flags|=2048,Oo(9,Eo.bind(null,n,i,r,e),void 0,null),null===Dc)throw Error(st(349));30&so||Mo(n,e,r)}return r}function Mo(t,e,n){t.flags|=16384,t={getSnapshot:e,value:n},null===(e=oo.updateQueue)?(e={lastEffect:null,stores:null},oo.updateQueue=e,e.stores=[t]):null===(n=e.stores)?e.stores=[t]:n.push(t)}function Eo(t,e,n,i){e.value=n,e.getSnapshot=i,No(e)&&Do(t)}function Po(t,e,n){return n((function(){No(e)&&Do(t)}))}function No(t){var e=t.getSnapshot;t=t.value;try{var n=e();return!lr(t,n)}catch(i){return!0}}function Do(t){var e=zs(t,1);null!==e&&iu(e,t,1,-1)}function To(t){var e=vo();return"function"==typeof t&&(t=t()),e.memoizedState=e.baseState=t,t={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:_o,lastRenderedState:t},e.queue=t,t=t.dispatch=Xo.bind(null,oo,t),[e.memoizedState,t]}function Oo(t,e,n,i){return t={tag:t,create:e,destroy:n,deps:i,next:null},null===(e=oo.updateQueue)?(e={lastEffect:null,stores:null},oo.updateQueue=e,e.lastEffect=t.next=t):null===(n=e.lastEffect)?e.lastEffect=t.next=t:(i=n.next,n.next=t,t.next=i,e.lastEffect=t),t}function Lo(){return yo().memoizedState}function Ro(t,e,n,i){var r=vo();oo.flags|=t,r.memoizedState=Oo(1|e,n,void 0,void 0===i?null:i)}function zo(t,e,n,i){var r=yo();i=void 0===i?null:i;var a=void 0;if(null!==lo){var s=lo.memoizedState;if(a=s.destroy,null!==i&&mo(i,s.deps))return void(r.memoizedState=Oo(e,n,a,i))}oo.flags|=t,r.memoizedState=Oo(1|e,n,a,i)}function jo(t,e){return Ro(8390656,8,t,e)}function Ao(t,e){return zo(2048,8,t,e)}function Fo(t,e){return zo(4,2,t,e)}function Io(t,e){return zo(4,4,t,e)}function Vo(t,e){return"function"==typeof e?(t=t(),e(t),function(){e(null)}):null!=e?(t=t(),e.current=t,function(){e.current=null}):void 0}function Bo(t,e,n){return n=null!=n?n.concat([t]):null,zo(4,4,Vo.bind(null,e,t),n)}function Wo(){}function Ho(t,e){var n=yo();e=void 0===e?null:e;var i=n.memoizedState;return null!==i&&null!==e&&mo(e,i[1])?i[0]:(n.memoizedState=[t,e],t)}function $o(t,e){var n=yo();e=void 0===e?null:e;var i=n.memoizedState;return null!==i&&null!==e&&mo(e,i[1])?i[0]:(t=t(),n.memoizedState=[t,e],t)}function Uo(t,e,n){return 21&so?(lr(n,e)||(n=bn(),oo.lanes|=n,Ac|=n,t.baseState=!0),e):(t.baseState&&(t.baseState=!1,yl=!0),t.memoizedState=n)}function Yo(t,e){var n=_n;_n=0!==n&&4>n?n:4,t(!0);var i=ao.transition;ao.transition={};try{t(!1),e()}finally{_n=n,ao.transition=i}}function Qo(){return yo().memoizedState}function qo(t,e,n){var i=nu(t);if(n={lane:i,action:n,hasEagerState:!1,eagerState:null,next:null},Ko(t))Go(e,n);else if(null!==(n=Rs(t,e,n,i))){iu(n,t,i,eu()),Jo(n,e,i)}}function Xo(t,e,n){var i=nu(t),r={lane:i,action:n,hasEagerState:!1,eagerState:null,next:null};if(Ko(t))Go(e,r);else{var a=t.alternate;if(0===t.lanes&&(null===a||0===a.lanes)&&null!==(a=e.lastRenderedReducer))try{var s=e.lastRenderedState,o=a(s,n);if(r.hasEagerState=!0,r.eagerState=o,lr(o,s)){var l=e.interleaved;return null===l?(r.next=r,Ls(e)):(r.next=l.next,l.next=r),void(e.interleaved=r)}}catch(c){}null!==(n=Rs(t,e,r,i))&&(iu(n,t,i,r=eu()),Jo(n,e,i))}}function Ko(t){var e=t.alternate;return t===oo||null!==e&&e===oo}function Go(t,e){ho=uo=!0;var n=t.pending;null===n?e.next=e:(e.next=n.next,n.next=e),t.pending=e}function Jo(t,e,n){if(4194240&n){var i=e.lanes;n|=i&=t.pendingLanes,e.lanes=n,yn(t,n)}}var Zo={readContext:Ts,useCallback:go,useContext:go,useEffect:go,useImperativeHandle:go,useInsertionEffect:go,useLayoutEffect:go,useMemo:go,useReducer:go,useRef:go,useState:go,useDebugValue:go,useDeferredValue:go,useTransition:go,useMutableSource:go,useSyncExternalStore:go,useId:go,unstable_isNewReconciler:!1},tl={readContext:Ts,useCallback:function(t,e){return vo().memoizedState=[t,void 0===e?null:e],t},useContext:Ts,useEffect:jo,useImperativeHandle:function(t,e,n){return n=null!=n?n.concat([t]):null,Ro(4194308,4,Vo.bind(null,e,t),n)},useLayoutEffect:function(t,e){return Ro(4194308,4,t,e)},useInsertionEffect:function(t,e){return Ro(4,2,t,e)},useMemo:function(t,e){var n=vo();return e=void 0===e?null:e,t=t(),n.memoizedState=[t,e],t},useReducer:function(t,e,n){var i=vo();return e=void 0!==n?n(e):e,i.memoizedState=i.baseState=e,t={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:t,lastRenderedState:e},i.queue=t,t=t.dispatch=qo.bind(null,oo,t),[i.memoizedState,t]},useRef:function(t){return t={current:t},vo().memoizedState=t},useState:To,useDebugValue:Wo,useDeferredValue:function(t){return vo().memoizedState=t},useTransition:function(){var t=To(!1),e=t[0];return t=Yo.bind(null,t[1]),vo().memoizedState=t,[e,t]},useMutableSource:function(){},useSyncExternalStore:function(t,e,n){var i=oo,r=vo();if(as){if(void 0===n)throw Error(st(407));n=n()}else{if(n=e(),null===Dc)throw Error(st(349));30&so||Mo(i,e,n)}r.memoizedState=n;var a={value:n,getSnapshot:e};return r.queue=a,jo(Po.bind(null,i,a,t),[t]),i.flags|=2048,Oo(9,Eo.bind(null,i,a,n,e),void 0,null),n},useId:function(){var t=vo(),e=Dc.identifierPrefix;if(as){var n=Ja;e=":"+e+"R"+(n=(Ga&~(1<<32-ln(Ga)-1)).toString(32)+n),0<(n=fo++)&&(e+="H"+n.toString(32)),e+=":"}else e=":"+e+"r"+(n=po++).toString(32)+":";return t.memoizedState=e},unstable_isNewReconciler:!1},el={readContext:Ts,useCallback:Ho,useContext:Ts,useEffect:Ao,useImperativeHandle:Bo,useInsertionEffect:Fo,useLayoutEffect:Io,useMemo:$o,useReducer:wo,useRef:Lo,useState:function(){return wo(_o)},useDebugValue:Wo,useDeferredValue:function(t){return Uo(yo(),lo.memoizedState,t)},useTransition:function(){return[wo(_o)[0],yo().memoizedState]},useMutableSource:So,useSyncExternalStore:Co,useId:Qo,unstable_isNewReconciler:!1},nl={readContext:Ts,useCallback:Ho,useContext:Ts,useEffect:Ao,useImperativeHandle:Bo,useInsertionEffect:Fo,useLayoutEffect:Io,useMemo:$o,useReducer:ko,useRef:Lo,useState:function(){return ko(_o)},useDebugValue:Wo,useDeferredValue:function(t){var e=yo();return null===lo?e.memoizedState=t:Uo(e,lo.memoizedState,t)},useTransition:function(){return[ko(_o)[0],yo().memoizedState]},useMutableSource:So,useSyncExternalStore:Co,useId:Qo,unstable_isNewReconciler:!1};function il(t,e){if(t&&t.defaultProps){for(var n in e=Ft({},e),t=t.defaultProps)void 0===e[n]&&(e[n]=t[n]);return e}return e}function rl(t,e,n,i){n=null==(n=n(i,e=t.memoizedState))?e:Ft({},e,n),t.memoizedState=n,0===t.lanes&&(t.updateQueue.baseState=n)}var al={isMounted:function(t){return!!(t=t._reactInternals)&&He(t)===t},enqueueSetState:function(t,e,n){t=t._reactInternals;var i=eu(),r=nu(t),a=Is(i,r);a.payload=e,null!=n&&(a.callback=n),null!==(e=Vs(t,a,r))&&(iu(e,t,r,i),Bs(e,t,r))},enqueueReplaceState:function(t,e,n){t=t._reactInternals;var i=eu(),r=nu(t),a=Is(i,r);a.tag=1,a.payload=e,null!=n&&(a.callback=n),null!==(e=Vs(t,a,r))&&(iu(e,t,r,i),Bs(e,t,r))},enqueueForceUpdate:function(t,e){t=t._reactInternals;var n=eu(),i=nu(t),r=Is(n,i);r.tag=2,null!=e&&(r.callback=e),null!==(e=Vs(t,r,i))&&(iu(e,t,i,n),Bs(e,t,i))}};function sl(t,e,n,i,r,a,s){return"function"==typeof(t=t.stateNode).shouldComponentUpdate?t.shouldComponentUpdate(i,a,s):!e.prototype||!e.prototype.isPureReactComponent||(!cr(n,i)||!cr(r,a))}function ol(t,e,n){var i=!1,r=Pa,a=e.contextType;return"object"==typeof a&&null!==a?a=Ts(a):(r=La(e)?Ta:Na.current,a=(i=null!=(i=e.contextTypes))?Oa(t,r):Pa),e=new e(n,a),t.memoizedState=null!==e.state&&void 0!==e.state?e.state:null,e.updater=al,t.stateNode=e,e._reactInternals=t,i&&((t=t.stateNode).__reactInternalMemoizedUnmaskedChildContext=r,t.__reactInternalMemoizedMaskedChildContext=a),e}function ll(t,e,n,i){t=e.state,"function"==typeof e.componentWillReceiveProps&&e.componentWillReceiveProps(n,i),"function"==typeof e.UNSAFE_componentWillReceiveProps&&e.UNSAFE_componentWillReceiveProps(n,i),e.state!==t&&al.enqueueReplaceState(e,e.state,null)}function cl(t,e,n,i){var r=t.stateNode;r.props=n,r.state=t.memoizedState,r.refs={},As(t);var a=e.contextType;"object"==typeof a&&null!==a?r.context=Ts(a):(a=La(e)?Ta:Na.current,r.context=Oa(t,a)),r.state=t.memoizedState,"function"==typeof(a=e.getDerivedStateFromProps)&&(rl(t,e,a,n),r.state=t.memoizedState),"function"==typeof e.getDerivedStateFromProps||"function"==typeof r.getSnapshotBeforeUpdate||"function"!=typeof r.UNSAFE_componentWillMount&&"function"!=typeof r.componentWillMount||(e=r.state,"function"==typeof r.componentWillMount&&r.componentWillMount(),"function"==typeof r.UNSAFE_componentWillMount&&r.UNSAFE_componentWillMount(),e!==r.state&&al.enqueueReplaceState(r,r.state,null),Hs(t,n,r,i),r.state=t.memoizedState),"function"==typeof r.componentDidMount&&(t.flags|=4194308)}function ul(t,e){try{var n="",i=e;do{n+=Wt(i),i=i.return}while(i);var r=n}catch(a){r="\nError generating stack: "+a.message+"\n"+a.stack}return{value:t,source:e,stack:r,digest:null}}function dl(t,e,n){return{value:t,source:null,stack:null!=n?n:null,digest:null!=e?e:null}}function hl(t,e){try{console.error(e.value)}catch(n){setTimeout((function(){throw n}))}}var fl="function"==typeof WeakMap?WeakMap:Map;function pl(t,e,n){(n=Is(-1,n)).tag=3,n.payload={element:null};var i=e.value;return n.callback=function(){Uc||(Uc=!0,Yc=i),hl(0,e)},n}function gl(t,e,n){(n=Is(-1,n)).tag=3;var i=t.type.getDerivedStateFromError;if("function"==typeof i){var r=e.value;n.payload=function(){return i(r)},n.callback=function(){hl(0,e)}}var a=t.stateNode;return null!==a&&"function"==typeof a.componentDidCatch&&(n.callback=function(){hl(0,e),"function"!=typeof i&&(null===Qc?Qc=new Set([this]):Qc.add(this));var t=e.stack;this.componentDidCatch(e.value,{componentStack:null!==t?t:""})}),n}function ml(t,e,n){var i=t.pingCache;if(null===i){i=t.pingCache=new fl;var r=new Set;i.set(e,r)}else void 0===(r=i.get(e))&&(r=new Set,i.set(e,r));r.has(n)||(r.add(n),t=Mu.bind(null,t,e,n),e.then(t,t))}function bl(t){do{var e;if((e=13===t.tag)&&(e=null===(e=t.memoizedState)||null!==e.dehydrated),e)return t;t=t.return}while(null!==t);return null}function xl(t,e,n,i,r){return 1&t.mode?(t.flags|=65536,t.lanes=r,t):(t===e?t.flags|=65536:(t.flags|=128,n.flags|=131072,n.flags&=-52805,1===n.tag&&(null===n.alternate?n.tag=17:((e=Is(-1,1)).tag=2,Vs(n,e,1))),n.lanes|=1),t)}var vl=_t.ReactCurrentOwner,yl=!1;function _l(t,e,n,i){e.child=null===t?ws(e,null,n,i):_s(e,t.child,n,i)}function wl(t,e,n,i,r){n=n.render;var a=e.ref;return Ds(e,r),i=bo(t,e,n,i,a,r),n=xo(),null===t||yl?(as&&n&&es(e),e.flags|=1,_l(t,e,i,r),e.child):(e.updateQueue=t.updateQueue,e.flags&=-2053,t.lanes&=~r,Ul(t,e,r))}function kl(t,e,n,i,r){if(null===t){var a=n.type;return"function"!=typeof a||Lu(a)||void 0!==a.defaultProps||null!==n.compare||void 0!==n.defaultProps?((t=zu(n.type,null,i,e,e.mode,r)).ref=e.ref,t.return=e,e.child=t):(e.tag=15,e.type=a,Sl(t,e,a,i,r))}if(a=t.child,!(t.lanes&r)){var s=a.memoizedProps;if((n=null!==(n=n.compare)?n:cr)(s,i)&&t.ref===e.ref)return Ul(t,e,r)}return e.flags|=1,(t=Ru(a,i)).ref=e.ref,t.return=e,e.child=t}function Sl(t,e,n,i,r){if(null!==t){var a=t.memoizedProps;if(cr(a,i)&&t.ref===e.ref){if(yl=!1,e.pendingProps=i=a,!(t.lanes&r))return e.lanes=t.lanes,Ul(t,e,r);131072&t.flags&&(yl=!0)}}return El(t,e,n,i,r)}function Cl(t,e,n){var i=e.pendingProps,r=i.children,a=null!==t?t.memoizedState:null;if("hidden"===i.mode)if(1&e.mode){if(!(1073741824&n))return t=null!==a?a.baseLanes|n:n,e.lanes=e.childLanes=1073741824,e.memoizedState={baseLanes:t,cachePool:null,transitions:null},e.updateQueue=null,Ea(Rc,Lc),Lc|=t,null;e.memoizedState={baseLanes:0,cachePool:null,transitions:null},i=null!==a?a.baseLanes:n,Ea(Rc,Lc),Lc|=i}else e.memoizedState={baseLanes:0,cachePool:null,transitions:null},Ea(Rc,Lc),Lc|=n;else null!==a?(i=a.baseLanes|n,e.memoizedState=null):i=n,Ea(Rc,Lc),Lc|=i;return _l(t,e,r,n),e.child}function Ml(t,e){var n=e.ref;(null===t&&null!==n||null!==t&&t.ref!==n)&&(e.flags|=512,e.flags|=2097152)}function El(t,e,n,i,r){var a=La(n)?Ta:Na.current;return a=Oa(e,a),Ds(e,r),n=bo(t,e,n,i,a,r),i=xo(),null===t||yl?(as&&i&&es(e),e.flags|=1,_l(t,e,n,r),e.child):(e.updateQueue=t.updateQueue,e.flags&=-2053,t.lanes&=~r,Ul(t,e,r))}function Pl(t,e,n,i,r){if(La(n)){var a=!0;Aa(e)}else a=!1;if(Ds(e,r),null===e.stateNode)$l(t,e),ol(e,n,i),cl(e,n,i,r),i=!0;else if(null===t){var s=e.stateNode,o=e.memoizedProps;s.props=o;var l=s.context,c=n.contextType;"object"==typeof c&&null!==c?c=Ts(c):c=Oa(e,c=La(n)?Ta:Na.current);var u=n.getDerivedStateFromProps,d="function"==typeof u||"function"==typeof s.getSnapshotBeforeUpdate;d||"function"!=typeof s.UNSAFE_componentWillReceiveProps&&"function"!=typeof s.componentWillReceiveProps||(o!==i||l!==c)&&ll(e,s,i,c),js=!1;var h=e.memoizedState;s.state=h,Hs(e,i,s,r),l=e.memoizedState,o!==i||h!==l||Da.current||js?("function"==typeof u&&(rl(e,n,u,i),l=e.memoizedState),(o=js||sl(e,n,o,i,h,l,c))?(d||"function"!=typeof s.UNSAFE_componentWillMount&&"function"!=typeof s.componentWillMount||("function"==typeof s.componentWillMount&&s.componentWillMount(),"function"==typeof s.UNSAFE_componentWillMount&&s.UNSAFE_componentWillMount()),"function"==typeof s.componentDidMount&&(e.flags|=4194308)):("function"==typeof s.componentDidMount&&(e.flags|=4194308),e.memoizedProps=i,e.memoizedState=l),s.props=i,s.state=l,s.context=c,i=o):("function"==typeof s.componentDidMount&&(e.flags|=4194308),i=!1)}else{s=e.stateNode,Fs(t,e),o=e.memoizedProps,c=e.type===e.elementType?o:il(e.type,o),s.props=c,d=e.pendingProps,h=s.context,"object"==typeof(l=n.contextType)&&null!==l?l=Ts(l):l=Oa(e,l=La(n)?Ta:Na.current);var f=n.getDerivedStateFromProps;(u="function"==typeof f||"function"==typeof s.getSnapshotBeforeUpdate)||"function"!=typeof s.UNSAFE_componentWillReceiveProps&&"function"!=typeof s.componentWillReceiveProps||(o!==d||h!==l)&&ll(e,s,i,l),js=!1,h=e.memoizedState,s.state=h,Hs(e,i,s,r);var p=e.memoizedState;o!==d||h!==p||Da.current||js?("function"==typeof f&&(rl(e,n,f,i),p=e.memoizedState),(c=js||sl(e,n,c,i,h,p,l)||!1)?(u||"function"!=typeof s.UNSAFE_componentWillUpdate&&"function"!=typeof s.componentWillUpdate||("function"==typeof s.componentWillUpdate&&s.componentWillUpdate(i,p,l),"function"==typeof s.UNSAFE_componentWillUpdate&&s.UNSAFE_componentWillUpdate(i,p,l)),"function"==typeof s.componentDidUpdate&&(e.flags|=4),"function"==typeof s.getSnapshotBeforeUpdate&&(e.flags|=1024)):("function"!=typeof s.componentDidUpdate||o===t.memoizedProps&&h===t.memoizedState||(e.flags|=4),"function"!=typeof s.getSnapshotBeforeUpdate||o===t.memoizedProps&&h===t.memoizedState||(e.flags|=1024),e.memoizedProps=i,e.memoizedState=p),s.props=i,s.state=p,s.context=l,i=c):("function"!=typeof s.componentDidUpdate||o===t.memoizedProps&&h===t.memoizedState||(e.flags|=4),"function"!=typeof s.getSnapshotBeforeUpdate||o===t.memoizedProps&&h===t.memoizedState||(e.flags|=1024),i=!1)}return Nl(t,e,n,i,a,r)}function Nl(t,e,n,i,r,a){Ml(t,e);var s=!!(128&e.flags);if(!i&&!s)return r&&Fa(e,n,!1),Ul(t,e,a);i=e.stateNode,vl.current=e;var o=s&&"function"!=typeof n.getDerivedStateFromError?null:i.render();return e.flags|=1,null!==t&&s?(e.child=_s(e,t.child,null,a),e.child=_s(e,null,o,a)):_l(t,e,o,a),e.memoizedState=i.state,r&&Fa(e,n,!0),e.child}function Dl(t){var e=t.stateNode;e.pendingContext?za(0,e.pendingContext,e.pendingContext!==e.context):e.context&&za(0,e.context,!1),Ks(t,e.containerInfo)}function Tl(t,e,n,i,r){return ps(),gs(r),e.flags|=256,_l(t,e,n,i),e.child}var Ol,Ll,Rl,zl,jl={dehydrated:null,treeContext:null,retryLane:0};function Al(t){return{baseLanes:t,cachePool:null,transitions:null}}function Fl(t,e,n){var i,r=e.pendingProps,a=to.current,s=!1,o=!!(128&e.flags);if((i=o)||(i=(null===t||null!==t.memoizedState)&&!!(2&a)),i?(s=!0,e.flags&=-129):null!==t&&null===t.memoizedState||(a|=1),Ea(to,1&a),null===t)return us(e),null!==(t=e.memoizedState)&&null!==(t=t.dehydrated)?(1&e.mode?"$!"===t.data?e.lanes=8:e.lanes=1073741824:e.lanes=1,null):(o=r.children,t=r.fallback,s?(r=e.mode,s=e.child,o={mode:"hidden",children:o},1&r||null===s?s=Au(o,r,0,null):(s.childLanes=0,s.pendingProps=o),t=ju(t,r,n,null),s.return=e,t.return=e,s.sibling=t,e.child=s,e.child.memoizedState=Al(n),e.memoizedState=jl,t):Il(e,o));if(null!==(a=t.memoizedState)&&null!==(i=a.dehydrated))return function(t,e,n,i,r,a,s){if(n)return 256&e.flags?(e.flags&=-257,Vl(t,e,s,i=dl(Error(st(422))))):null!==e.memoizedState?(e.child=t.child,e.flags|=128,null):(a=i.fallback,r=e.mode,i=Au({mode:"visible",children:i.children},r,0,null),(a=ju(a,r,s,null)).flags|=2,i.return=e,a.return=e,i.sibling=a,e.child=i,1&e.mode&&_s(e,t.child,null,s),e.child.memoizedState=Al(s),e.memoizedState=jl,a);if(!(1&e.mode))return Vl(t,e,s,null);if("$!"===r.data){if(i=r.nextSibling&&r.nextSibling.dataset)var o=i.dgst;return i=o,Vl(t,e,s,i=dl(a=Error(st(419)),i,void 0))}if(o=!!(s&t.childLanes),yl||o){if(null!==(i=Dc)){switch(s&-s){case 4:r=2;break;case 16:r=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:r=32;break;case 536870912:r=268435456;break;default:r=0}0!==(r=r&(i.suspendedLanes|s)?0:r)&&r!==a.retryLane&&(a.retryLane=r,zs(t,r),iu(i,t,r,-1))}return mu(),Vl(t,e,s,i=dl(Error(st(421))))}return"$?"===r.data?(e.flags|=128,e.child=t.child,e=Pu.bind(null,t),r._reactRetry=e,null):(t=a.treeContext,rs=ua(r.nextSibling),is=e,as=!0,ss=null,null!==t&&(qa[Xa++]=Ga,qa[Xa++]=Ja,qa[Xa++]=Ka,Ga=t.id,Ja=t.overflow,Ka=e),e=Il(e,i.children),e.flags|=4096,e)}(t,e,o,r,i,a,n);if(s){s=r.fallback,o=e.mode,i=(a=t.child).sibling;var l={mode:"hidden",children:r.children};return 1&o||e.child===a?(r=Ru(a,l)).subtreeFlags=14680064&a.subtreeFlags:((r=e.child).childLanes=0,r.pendingProps=l,e.deletions=null),null!==i?s=Ru(i,s):(s=ju(s,o,n,null)).flags|=2,s.return=e,r.return=e,r.sibling=s,e.child=r,r=s,s=e.child,o=null===(o=t.child.memoizedState)?Al(n):{baseLanes:o.baseLanes|n,cachePool:null,transitions:o.transitions},s.memoizedState=o,s.childLanes=t.childLanes&~n,e.memoizedState=jl,r}return t=(s=t.child).sibling,r=Ru(s,{mode:"visible",children:r.children}),!(1&e.mode)&&(r.lanes=n),r.return=e,r.sibling=null,null!==t&&(null===(n=e.deletions)?(e.deletions=[t],e.flags|=16):n.push(t)),e.child=r,e.memoizedState=null,r}function Il(t,e){return(e=Au({mode:"visible",children:e},t.mode,0,null)).return=t,t.child=e}function Vl(t,e,n,i){return null!==i&&gs(i),_s(e,t.child,null,n),(t=Il(e,e.pendingProps.children)).flags|=2,e.memoizedState=null,t}function Bl(t,e,n){t.lanes|=e;var i=t.alternate;null!==i&&(i.lanes|=e),Ns(t.return,e,n)}function Wl(t,e,n,i,r){var a=t.memoizedState;null===a?t.memoizedState={isBackwards:e,rendering:null,renderingStartTime:0,last:i,tail:n,tailMode:r}:(a.isBackwards=e,a.rendering=null,a.renderingStartTime=0,a.last=i,a.tail=n,a.tailMode=r)}function Hl(t,e,n){var i=e.pendingProps,r=i.revealOrder,a=i.tail;if(_l(t,e,i.children,n),2&(i=to.current))i=1&i|2,e.flags|=128;else{if(null!==t&&128&t.flags)t:for(t=e.child;null!==t;){if(13===t.tag)null!==t.memoizedState&&Bl(t,n,e);else if(19===t.tag)Bl(t,n,e);else if(null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break t;for(;null===t.sibling;){if(null===t.return||t.return===e)break t;t=t.return}t.sibling.return=t.return,t=t.sibling}i&=1}if(Ea(to,i),1&e.mode)switch(r){case"forwards":for(n=e.child,r=null;null!==n;)null!==(t=n.alternate)&&null===eo(t)&&(r=n),n=n.sibling;null===(n=r)?(r=e.child,e.child=null):(r=n.sibling,n.sibling=null),Wl(e,!1,r,n,a);break;case"backwards":for(n=null,r=e.child,e.child=null;null!==r;){if(null!==(t=r.alternate)&&null===eo(t)){e.child=r;break}t=r.sibling,r.sibling=n,n=r,r=t}Wl(e,!0,n,null,a);break;case"together":Wl(e,!1,null,null,void 0);break;default:e.memoizedState=null}else e.memoizedState=null;return e.child}function $l(t,e){!(1&e.mode)&&null!==t&&(t.alternate=null,e.alternate=null,e.flags|=2)}function Ul(t,e,n){if(null!==t&&(e.dependencies=t.dependencies),Ac|=e.lanes,!(n&e.childLanes))return null;if(null!==t&&e.child!==t.child)throw Error(st(153));if(null!==e.child){for(n=Ru(t=e.child,t.pendingProps),e.child=n,n.return=e;null!==t.sibling;)t=t.sibling,(n=n.sibling=Ru(t,t.pendingProps)).return=e;n.sibling=null}return e.child}function Yl(t,e){if(!as)switch(t.tailMode){case"hidden":e=t.tail;for(var n=null;null!==e;)null!==e.alternate&&(n=e),e=e.sibling;null===n?t.tail=null:n.sibling=null;break;case"collapsed":n=t.tail;for(var i=null;null!==n;)null!==n.alternate&&(i=n),n=n.sibling;null===i?e||null===t.tail?t.tail=null:t.tail.sibling=null:i.sibling=null}}function Ql(t){var e=null!==t.alternate&&t.alternate.child===t.child,n=0,i=0;if(e)for(var r=t.child;null!==r;)n|=r.lanes|r.childLanes,i|=14680064&r.subtreeFlags,i|=14680064&r.flags,r.return=t,r=r.sibling;else for(r=t.child;null!==r;)n|=r.lanes|r.childLanes,i|=r.subtreeFlags,i|=r.flags,r.return=t,r=r.sibling;return t.subtreeFlags|=i,t.childLanes=n,e}function ql(t,e,n){var i=e.pendingProps;switch(ns(e),e.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Ql(e),null;case 1:case 17:return La(e.type)&&Ra(),Ql(e),null;case 3:return i=e.stateNode,Gs(),Ma(Da),Ma(Na),io(),i.pendingContext&&(i.context=i.pendingContext,i.pendingContext=null),null!==t&&null!==t.child||(hs(e)?e.flags|=4:null===t||t.memoizedState.isDehydrated&&!(256&e.flags)||(e.flags|=1024,null!==ss&&(ou(ss),ss=null))),Ll(t,e),Ql(e),null;case 5:Zs(e);var r=Xs(qs.current);if(n=e.type,null!==t&&null!=e.stateNode)Rl(t,e,n,i,r),t.ref!==e.ref&&(e.flags|=512,e.flags|=2097152);else{if(!i){if(null===e.stateNode)throw Error(st(166));return Ql(e),null}if(t=Xs(Ys.current),hs(e)){i=e.stateNode,n=e.type;var a=e.memoizedProps;switch(i[fa]=e,i[pa]=a,t=!!(1&e.mode),n){case"dialog":Vr("cancel",i),Vr("close",i);break;case"iframe":case"object":case"embed":Vr("load",i);break;case"video":case"audio":for(r=0;r<jr.length;r++)Vr(jr[r],i);break;case"source":Vr("error",i);break;case"img":case"image":case"link":Vr("error",i),Vr("load",i);break;case"details":Vr("toggle",i);break;case"input":Gt(i,a),Vr("invalid",i);break;case"select":i._wrapperState={wasMultiple:!!a.multiple},Vr("invalid",i);break;case"textarea":ae(i,a),Vr("invalid",i)}for(var s in ve(n,a),r=null,a)if(a.hasOwnProperty(s)){var o=a[s];"children"===s?"string"==typeof o?i.textContent!==o&&(!0!==a.suppressHydrationWarning&&Zr(i.textContent,o,t),r=["children",o]):"number"==typeof o&&i.textContent!==""+o&&(!0!==a.suppressHydrationWarning&&Zr(i.textContent,o,t),r=["children",""+o]):lt.hasOwnProperty(s)&&null!=o&&"onScroll"===s&&Vr("scroll",i)}switch(n){case"input":Qt(i),te(i,a,!0);break;case"textarea":Qt(i),oe(i);break;case"select":case"option":break;default:"function"==typeof a.onClick&&(i.onclick=ta)}i=r,e.updateQueue=i,null!==i&&(e.flags|=4)}else{s=9===r.nodeType?r:r.ownerDocument,"http://www.w3.org/1999/xhtml"===t&&(t=le(n)),"http://www.w3.org/1999/xhtml"===t?"script"===n?((t=s.createElement("div")).innerHTML="<script><\/script>",t=t.removeChild(t.firstChild)):"string"==typeof i.is?t=s.createElement(n,{is:i.is}):(t=s.createElement(n),"select"===n&&(s=t,i.multiple?s.multiple=!0:i.size&&(s.size=i.size))):t=s.createElementNS(t,n),t[fa]=e,t[pa]=i,Ol(t,e,!1,!1),e.stateNode=t;t:{switch(s=ye(n,i),n){case"dialog":Vr("cancel",t),Vr("close",t),r=i;break;case"iframe":case"object":case"embed":Vr("load",t),r=i;break;case"video":case"audio":for(r=0;r<jr.length;r++)Vr(jr[r],t);r=i;break;case"source":Vr("error",t),r=i;break;case"img":case"image":case"link":Vr("error",t),Vr("load",t),r=i;break;case"details":Vr("toggle",t),r=i;break;case"input":Gt(t,i),r=Kt(t,i),Vr("invalid",t);break;case"option":default:r=i;break;case"select":t._wrapperState={wasMultiple:!!i.multiple},r=Ft({},i,{value:void 0}),Vr("invalid",t);break;case"textarea":ae(t,i),r=re(t,i),Vr("invalid",t)}for(a in ve(n,r),o=r)if(o.hasOwnProperty(a)){var l=o[a];"style"===a?be(t,l):"dangerouslySetInnerHTML"===a?null!=(l=l?l.__html:void 0)&&he(t,l):"children"===a?"string"==typeof l?("textarea"!==n||""!==l)&&fe(t,l):"number"==typeof l&&fe(t,""+l):"suppressContentEditableWarning"!==a&&"suppressHydrationWarning"!==a&&"autoFocus"!==a&&(lt.hasOwnProperty(a)?null!=l&&"onScroll"===a&&Vr("scroll",t):null!=l&&yt(t,a,l,s))}switch(n){case"input":Qt(t),te(t,i,!1);break;case"textarea":Qt(t),oe(t);break;case"option":null!=i.value&&t.setAttribute("value",""+Ut(i.value));break;case"select":t.multiple=!!i.multiple,null!=(a=i.value)?ie(t,!!i.multiple,a,!1):null!=i.defaultValue&&ie(t,!!i.multiple,i.defaultValue,!0);break;default:"function"==typeof r.onClick&&(t.onclick=ta)}switch(n){case"button":case"input":case"select":case"textarea":i=!!i.autoFocus;break t;case"img":i=!0;break t;default:i=!1}}i&&(e.flags|=4)}null!==e.ref&&(e.flags|=512,e.flags|=2097152)}return Ql(e),null;case 6:if(t&&null!=e.stateNode)zl(t,e,t.memoizedProps,i);else{if("string"!=typeof i&&null===e.stateNode)throw Error(st(166));if(n=Xs(qs.current),Xs(Ys.current),hs(e)){if(i=e.stateNode,n=e.memoizedProps,i[fa]=e,(a=i.nodeValue!==n)&&null!==(t=is))switch(t.tag){case 3:Zr(i.nodeValue,n,!!(1&t.mode));break;case 5:!0!==t.memoizedProps.suppressHydrationWarning&&Zr(i.nodeValue,n,!!(1&t.mode))}a&&(e.flags|=4)}else(i=(9===n.nodeType?n:n.ownerDocument).createTextNode(i))[fa]=e,e.stateNode=i}return Ql(e),null;case 13:if(Ma(to),i=e.memoizedState,null===t||null!==t.memoizedState&&null!==t.memoizedState.dehydrated){if(as&&null!==rs&&1&e.mode&&!(128&e.flags))fs(),ps(),e.flags|=98560,a=!1;else if(a=hs(e),null!==i&&null!==i.dehydrated){if(null===t){if(!a)throw Error(st(318));if(!(a=null!==(a=e.memoizedState)?a.dehydrated:null))throw Error(st(317));a[fa]=e}else ps(),!(128&e.flags)&&(e.memoizedState=null),e.flags|=4;Ql(e),a=!1}else null!==ss&&(ou(ss),ss=null),a=!0;if(!a)return 65536&e.flags?e:null}return 128&e.flags?(e.lanes=n,e):((i=null!==i)!==(null!==t&&null!==t.memoizedState)&&i&&(e.child.flags|=8192,1&e.mode&&(null===t||1&to.current?0===zc&&(zc=3):mu())),null!==e.updateQueue&&(e.flags|=4),Ql(e),null);case 4:return Gs(),Ll(t,e),null===t&&Hr(e.stateNode.containerInfo),Ql(e),null;case 10:return Ps(e.type._context),Ql(e),null;case 19:if(Ma(to),null===(a=e.memoizedState))return Ql(e),null;if(i=!!(128&e.flags),null===(s=a.rendering))if(i)Yl(a,!1);else{if(0!==zc||null!==t&&128&t.flags)for(t=e.child;null!==t;){if(null!==(s=eo(t))){for(e.flags|=128,Yl(a,!1),null!==(i=s.updateQueue)&&(e.updateQueue=i,e.flags|=4),e.subtreeFlags=0,i=n,n=e.child;null!==n;)t=i,(a=n).flags&=14680066,null===(s=a.alternate)?(a.childLanes=0,a.lanes=t,a.child=null,a.subtreeFlags=0,a.memoizedProps=null,a.memoizedState=null,a.updateQueue=null,a.dependencies=null,a.stateNode=null):(a.childLanes=s.childLanes,a.lanes=s.lanes,a.child=s.child,a.subtreeFlags=0,a.deletions=null,a.memoizedProps=s.memoizedProps,a.memoizedState=s.memoizedState,a.updateQueue=s.updateQueue,a.type=s.type,t=s.dependencies,a.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext}),n=n.sibling;return Ea(to,1&to.current|2),e.child}t=t.sibling}null!==a.tail&&Je()>Hc&&(e.flags|=128,i=!0,Yl(a,!1),e.lanes=4194304)}else{if(!i)if(null!==(t=eo(s))){if(e.flags|=128,i=!0,null!==(n=t.updateQueue)&&(e.updateQueue=n,e.flags|=4),Yl(a,!0),null===a.tail&&"hidden"===a.tailMode&&!s.alternate&&!as)return Ql(e),null}else 2*Je()-a.renderingStartTime>Hc&&1073741824!==n&&(e.flags|=128,i=!0,Yl(a,!1),e.lanes=4194304);a.isBackwards?(s.sibling=e.child,e.child=s):(null!==(n=a.last)?n.sibling=s:e.child=s,a.last=s)}return null!==a.tail?(e=a.tail,a.rendering=e,a.tail=e.sibling,a.renderingStartTime=Je(),e.sibling=null,n=to.current,Ea(to,i?1&n|2:1&n),e):(Ql(e),null);case 22:case 23:return hu(),i=null!==e.memoizedState,null!==t&&null!==t.memoizedState!==i&&(e.flags|=8192),i&&1&e.mode?!!(1073741824&Lc)&&(Ql(e),6&e.subtreeFlags&&(e.flags|=8192)):Ql(e),null;case 24:case 25:return null}throw Error(st(156,e.tag))}function Xl(t,e){switch(ns(e),e.tag){case 1:return La(e.type)&&Ra(),65536&(t=e.flags)?(e.flags=-65537&t|128,e):null;case 3:return Gs(),Ma(Da),Ma(Na),io(),65536&(t=e.flags)&&!(128&t)?(e.flags=-65537&t|128,e):null;case 5:return Zs(e),null;case 13:if(Ma(to),null!==(t=e.memoizedState)&&null!==t.dehydrated){if(null===e.alternate)throw Error(st(340));ps()}return 65536&(t=e.flags)?(e.flags=-65537&t|128,e):null;case 19:return Ma(to),null;case 4:return Gs(),null;case 10:return Ps(e.type._context),null;case 22:case 23:return hu(),null;default:return null}}Ol=function(t,e){for(var n=e.child;null!==n;){if(5===n.tag||6===n.tag)t.appendChild(n.stateNode);else if(4!==n.tag&&null!==n.child){n.child.return=n,n=n.child;continue}if(n===e)break;for(;null===n.sibling;){if(null===n.return||n.return===e)return;n=n.return}n.sibling.return=n.return,n=n.sibling}},Ll=function(){},Rl=function(t,e,n,i){var r=t.memoizedProps;if(r!==i){t=e.stateNode,Xs(Ys.current);var a,s=null;switch(n){case"input":r=Kt(t,r),i=Kt(t,i),s=[];break;case"select":r=Ft({},r,{value:void 0}),i=Ft({},i,{value:void 0}),s=[];break;case"textarea":r=re(t,r),i=re(t,i),s=[];break;default:"function"!=typeof r.onClick&&"function"==typeof i.onClick&&(t.onclick=ta)}for(c in ve(n,i),n=null,r)if(!i.hasOwnProperty(c)&&r.hasOwnProperty(c)&&null!=r[c])if("style"===c){var o=r[c];for(a in o)o.hasOwnProperty(a)&&(n||(n={}),n[a]="")}else"dangerouslySetInnerHTML"!==c&&"children"!==c&&"suppressContentEditableWarning"!==c&&"suppressHydrationWarning"!==c&&"autoFocus"!==c&&(lt.hasOwnProperty(c)?s||(s=[]):(s=s||[]).push(c,null));for(c in i){var l=i[c];if(o=null!=r?r[c]:void 0,i.hasOwnProperty(c)&&l!==o&&(null!=l||null!=o))if("style"===c)if(o){for(a in o)!o.hasOwnProperty(a)||l&&l.hasOwnProperty(a)||(n||(n={}),n[a]="");for(a in l)l.hasOwnProperty(a)&&o[a]!==l[a]&&(n||(n={}),n[a]=l[a])}else n||(s||(s=[]),s.push(c,n)),n=l;else"dangerouslySetInnerHTML"===c?(l=l?l.__html:void 0,o=o?o.__html:void 0,null!=l&&o!==l&&(s=s||[]).push(c,l)):"children"===c?"string"!=typeof l&&"number"!=typeof l||(s=s||[]).push(c,""+l):"suppressContentEditableWarning"!==c&&"suppressHydrationWarning"!==c&&(lt.hasOwnProperty(c)?(null!=l&&"onScroll"===c&&Vr("scroll",t),s||o===l||(s=[])):(s=s||[]).push(c,l))}n&&(s=s||[]).push("style",n);var c=s;(e.updateQueue=c)&&(e.flags|=4)}},zl=function(t,e,n,i){n!==i&&(e.flags|=4)};var Kl=!1,Gl=!1,Jl="function"==typeof WeakSet?WeakSet:Set,Zl=null;function tc(t,e){var n=t.ref;if(null!==n)if("function"==typeof n)try{n(null)}catch(i){Cu(t,e,i)}else n.current=null}function ec(t,e,n){try{n()}catch(i){Cu(t,e,i)}}var nc=!1;function ic(t,e,n){var i=e.updateQueue;if(null!==(i=null!==i?i.lastEffect:null)){var r=i=i.next;do{if((r.tag&t)===t){var a=r.destroy;r.destroy=void 0,void 0!==a&&ec(e,n,a)}r=r.next}while(r!==i)}}function rc(t,e){if(null!==(e=null!==(e=e.updateQueue)?e.lastEffect:null)){var n=e=e.next;do{if((n.tag&t)===t){var i=n.create;n.destroy=i()}n=n.next}while(n!==e)}}function ac(t){var e=t.ref;if(null!==e){var n=t.stateNode;t.tag,t=n,"function"==typeof e?e(t):e.current=t}}function sc(t){var e=t.alternate;null!==e&&(t.alternate=null,sc(e)),t.child=null,t.deletions=null,t.sibling=null,5===t.tag&&(null!==(e=t.stateNode)&&(delete e[fa],delete e[pa],delete e[ma],delete e[ba],delete e[xa])),t.stateNode=null,t.return=null,t.dependencies=null,t.memoizedProps=null,t.memoizedState=null,t.pendingProps=null,t.stateNode=null,t.updateQueue=null}function oc(t){return 5===t.tag||3===t.tag||4===t.tag}function lc(t){t:for(;;){for(;null===t.sibling;){if(null===t.return||oc(t.return))return null;t=t.return}for(t.sibling.return=t.return,t=t.sibling;5!==t.tag&&6!==t.tag&&18!==t.tag;){if(2&t.flags)continue t;if(null===t.child||4===t.tag)continue t;t.child.return=t,t=t.child}if(!(2&t.flags))return t.stateNode}}function cc(t,e,n){var i=t.tag;if(5===i||6===i)t=t.stateNode,e?8===n.nodeType?n.parentNode.insertBefore(t,e):n.insertBefore(t,e):(8===n.nodeType?(e=n.parentNode).insertBefore(t,n):(e=n).appendChild(t),null!=(n=n._reactRootContainer)||null!==e.onclick||(e.onclick=ta));else if(4!==i&&null!==(t=t.child))for(cc(t,e,n),t=t.sibling;null!==t;)cc(t,e,n),t=t.sibling}function uc(t,e,n){var i=t.tag;if(5===i||6===i)t=t.stateNode,e?n.insertBefore(t,e):n.appendChild(t);else if(4!==i&&null!==(t=t.child))for(uc(t,e,n),t=t.sibling;null!==t;)uc(t,e,n),t=t.sibling}var dc=null,hc=!1;function fc(t,e,n){for(n=n.child;null!==n;)pc(t,e,n),n=n.sibling}function pc(t,e,n){if(on&&"function"==typeof on.onCommitFiberUnmount)try{on.onCommitFiberUnmount(sn,n)}catch(o){}switch(n.tag){case 5:Gl||tc(n,e);case 6:var i=dc,r=hc;dc=null,fc(t,e,n),hc=r,null!==(dc=i)&&(hc?(t=dc,n=n.stateNode,8===t.nodeType?t.parentNode.removeChild(n):t.removeChild(n)):dc.removeChild(n.stateNode));break;case 18:null!==dc&&(hc?(t=dc,n=n.stateNode,8===t.nodeType?ca(t.parentNode,n):1===t.nodeType&&ca(t,n),$n(t)):ca(dc,n.stateNode));break;case 4:i=dc,r=hc,dc=n.stateNode.containerInfo,hc=!0,fc(t,e,n),dc=i,hc=r;break;case 0:case 11:case 14:case 15:if(!Gl&&(null!==(i=n.updateQueue)&&null!==(i=i.lastEffect))){r=i=i.next;do{var a=r,s=a.destroy;a=a.tag,void 0!==s&&(2&a||4&a)&&ec(n,e,s),r=r.next}while(r!==i)}fc(t,e,n);break;case 1:if(!Gl&&(tc(n,e),"function"==typeof(i=n.stateNode).componentWillUnmount))try{i.props=n.memoizedProps,i.state=n.memoizedState,i.componentWillUnmount()}catch(o){Cu(n,e,o)}fc(t,e,n);break;case 21:fc(t,e,n);break;case 22:1&n.mode?(Gl=(i=Gl)||null!==n.memoizedState,fc(t,e,n),Gl=i):fc(t,e,n);break;default:fc(t,e,n)}}function gc(t){var e=t.updateQueue;if(null!==e){t.updateQueue=null;var n=t.stateNode;null===n&&(n=t.stateNode=new Jl),e.forEach((function(e){var i=Nu.bind(null,t,e);n.has(e)||(n.add(e),e.then(i,i))}))}}function mc(t,e){var n=e.deletions;if(null!==n)for(var i=0;i<n.length;i++){var r=n[i];try{var a=t,s=e,o=s;t:for(;null!==o;){switch(o.tag){case 5:dc=o.stateNode,hc=!1;break t;case 3:case 4:dc=o.stateNode.containerInfo,hc=!0;break t}o=o.return}if(null===dc)throw Error(st(160));pc(a,s,r),dc=null,hc=!1;var l=r.alternate;null!==l&&(l.return=null),r.return=null}catch(c){Cu(r,e,c)}}if(12854&e.subtreeFlags)for(e=e.child;null!==e;)bc(e,t),e=e.sibling}function bc(t,e){var n=t.alternate,i=t.flags;switch(t.tag){case 0:case 11:case 14:case 15:if(mc(e,t),xc(t),4&i){try{ic(3,t,t.return),rc(3,t)}catch(g){Cu(t,t.return,g)}try{ic(5,t,t.return)}catch(g){Cu(t,t.return,g)}}break;case 1:mc(e,t),xc(t),512&i&&null!==n&&tc(n,n.return);break;case 5:if(mc(e,t),xc(t),512&i&&null!==n&&tc(n,n.return),32&t.flags){var r=t.stateNode;try{fe(r,"")}catch(g){Cu(t,t.return,g)}}if(4&i&&null!=(r=t.stateNode)){var a=t.memoizedProps,s=null!==n?n.memoizedProps:a,o=t.type,l=t.updateQueue;if(t.updateQueue=null,null!==l)try{"input"===o&&"radio"===a.type&&null!=a.name&&Jt(r,a),ye(o,s);var c=ye(o,a);for(s=0;s<l.length;s+=2){var u=l[s],d=l[s+1];"style"===u?be(r,d):"dangerouslySetInnerHTML"===u?he(r,d):"children"===u?fe(r,d):yt(r,u,d,c)}switch(o){case"input":Zt(r,a);break;case"textarea":se(r,a);break;case"select":var h=r._wrapperState.wasMultiple;r._wrapperState.wasMultiple=!!a.multiple;var f=a.value;null!=f?ie(r,!!a.multiple,f,!1):h!==!!a.multiple&&(null!=a.defaultValue?ie(r,!!a.multiple,a.defaultValue,!0):ie(r,!!a.multiple,a.multiple?[]:"",!1))}r[pa]=a}catch(g){Cu(t,t.return,g)}}break;case 6:if(mc(e,t),xc(t),4&i){if(null===t.stateNode)throw Error(st(162));r=t.stateNode,a=t.memoizedProps;try{r.nodeValue=a}catch(g){Cu(t,t.return,g)}}break;case 3:if(mc(e,t),xc(t),4&i&&null!==n&&n.memoizedState.isDehydrated)try{$n(e.containerInfo)}catch(g){Cu(t,t.return,g)}break;case 4:default:mc(e,t),xc(t);break;case 13:mc(e,t),xc(t),8192&(r=t.child).flags&&(a=null!==r.memoizedState,r.stateNode.isHidden=a,!a||null!==r.alternate&&null!==r.alternate.memoizedState||(Wc=Je())),4&i&&gc(t);break;case 22:if(u=null!==n&&null!==n.memoizedState,1&t.mode?(Gl=(c=Gl)||u,mc(e,t),Gl=c):mc(e,t),xc(t),8192&i){if(c=null!==t.memoizedState,(t.stateNode.isHidden=c)&&!u&&1&t.mode)for(Zl=t,u=t.child;null!==u;){for(d=Zl=u;null!==Zl;){switch(f=(h=Zl).child,h.tag){case 0:case 11:case 14:case 15:ic(4,h,h.return);break;case 1:tc(h,h.return);var p=h.stateNode;if("function"==typeof p.componentWillUnmount){i=h,n=h.return;try{e=i,p.props=e.memoizedProps,p.state=e.memoizedState,p.componentWillUnmount()}catch(g){Cu(i,n,g)}}break;case 5:tc(h,h.return);break;case 22:if(null!==h.memoizedState){wc(d);continue}}null!==f?(f.return=h,Zl=f):wc(d)}u=u.sibling}t:for(u=null,d=t;;){if(5===d.tag){if(null===u){u=d;try{r=d.stateNode,c?"function"==typeof(a=r.style).setProperty?a.setProperty("display","none","important"):a.display="none":(o=d.stateNode,s=null!=(l=d.memoizedProps.style)&&l.hasOwnProperty("display")?l.display:null,o.style.display=me("display",s))}catch(g){Cu(t,t.return,g)}}}else if(6===d.tag){if(null===u)try{d.stateNode.nodeValue=c?"":d.memoizedProps}catch(g){Cu(t,t.return,g)}}else if((22!==d.tag&&23!==d.tag||null===d.memoizedState||d===t)&&null!==d.child){d.child.return=d,d=d.child;continue}if(d===t)break t;for(;null===d.sibling;){if(null===d.return||d.return===t)break t;u===d&&(u=null),d=d.return}u===d&&(u=null),d.sibling.return=d.return,d=d.sibling}}break;case 19:mc(e,t),xc(t),4&i&&gc(t);case 21:}}function xc(t){var e=t.flags;if(2&e){try{t:{for(var n=t.return;null!==n;){if(oc(n)){var i=n;break t}n=n.return}throw Error(st(160))}switch(i.tag){case 5:var r=i.stateNode;32&i.flags&&(fe(r,""),i.flags&=-33),uc(t,lc(t),r);break;case 3:case 4:var a=i.stateNode.containerInfo;cc(t,lc(t),a);break;default:throw Error(st(161))}}catch(s){Cu(t,t.return,s)}t.flags&=-3}4096&e&&(t.flags&=-4097)}function vc(t,e,n){Zl=t,yc(t)}function yc(t,e,n){for(var i=!!(1&t.mode);null!==Zl;){var r=Zl,a=r.child;if(22===r.tag&&i){var s=null!==r.memoizedState||Kl;if(!s){var o=r.alternate,l=null!==o&&null!==o.memoizedState||Gl;o=Kl;var c=Gl;if(Kl=s,(Gl=l)&&!c)for(Zl=r;null!==Zl;)l=(s=Zl).child,22===s.tag&&null!==s.memoizedState?kc(r):null!==l?(l.return=s,Zl=l):kc(r);for(;null!==a;)Zl=a,yc(a),a=a.sibling;Zl=r,Kl=o,Gl=c}_c(t)}else 8772&r.subtreeFlags&&null!==a?(a.return=r,Zl=a):_c(t)}}function _c(t){for(;null!==Zl;){var e=Zl;if(8772&e.flags){var n=e.alternate;try{if(8772&e.flags)switch(e.tag){case 0:case 11:case 15:Gl||rc(5,e);break;case 1:var i=e.stateNode;if(4&e.flags&&!Gl)if(null===n)i.componentDidMount();else{var r=e.elementType===e.type?n.memoizedProps:il(e.type,n.memoizedProps);i.componentDidUpdate(r,n.memoizedState,i.__reactInternalSnapshotBeforeUpdate)}var a=e.updateQueue;null!==a&&$s(e,a,i);break;case 3:var s=e.updateQueue;if(null!==s){if(n=null,null!==e.child)switch(e.child.tag){case 5:case 1:n=e.child.stateNode}$s(e,s,n)}break;case 5:var o=e.stateNode;if(null===n&&4&e.flags){n=o;var l=e.memoizedProps;switch(e.type){case"button":case"input":case"select":case"textarea":l.autoFocus&&n.focus();break;case"img":l.src&&(n.src=l.src)}}break;case 6:case 4:case 12:case 19:case 17:case 21:case 22:case 23:case 25:break;case 13:if(null===e.memoizedState){var c=e.alternate;if(null!==c){var u=c.memoizedState;if(null!==u){var d=u.dehydrated;null!==d&&$n(d)}}}break;default:throw Error(st(163))}Gl||512&e.flags&&ac(e)}catch(h){Cu(e,e.return,h)}}if(e===t){Zl=null;break}if(null!==(n=e.sibling)){n.return=e.return,Zl=n;break}Zl=e.return}}function wc(t){for(;null!==Zl;){var e=Zl;if(e===t){Zl=null;break}var n=e.sibling;if(null!==n){n.return=e.return,Zl=n;break}Zl=e.return}}function kc(t){for(;null!==Zl;){var e=Zl;try{switch(e.tag){case 0:case 11:case 15:var n=e.return;try{rc(4,e)}catch(l){Cu(e,n,l)}break;case 1:var i=e.stateNode;if("function"==typeof i.componentDidMount){var r=e.return;try{i.componentDidMount()}catch(l){Cu(e,r,l)}}var a=e.return;try{ac(e)}catch(l){Cu(e,a,l)}break;case 5:var s=e.return;try{ac(e)}catch(l){Cu(e,s,l)}}}catch(l){Cu(e,e.return,l)}if(e===t){Zl=null;break}var o=e.sibling;if(null!==o){o.return=e.return,Zl=o;break}Zl=e.return}}var Sc,Cc=Math.ceil,Mc=_t.ReactCurrentDispatcher,Ec=_t.ReactCurrentOwner,Pc=_t.ReactCurrentBatchConfig,Nc=0,Dc=null,Tc=null,Oc=0,Lc=0,Rc=Ca(0),zc=0,jc=null,Ac=0,Fc=0,Ic=0,Vc=null,Bc=null,Wc=0,Hc=1/0,$c=null,Uc=!1,Yc=null,Qc=null,qc=!1,Xc=null,Kc=0,Gc=0,Jc=null,Zc=-1,tu=0;function eu(){return 6&Nc?Je():-1!==Zc?Zc:Zc=Je()}function nu(t){return 1&t.mode?2&Nc&&0!==Oc?Oc&-Oc:null!==ms.transition?(0===tu&&(tu=bn()),tu):0!==(t=_n)?t:t=void 0===(t=window.event)?16:Jn(t.type):1}function iu(t,e,n,i){if(50<Gc)throw Gc=0,Jc=null,Error(st(185));vn(t,n,i),2&Nc&&t===Dc||(t===Dc&&(!(2&Nc)&&(Fc|=n),4===zc&&lu(t,Oc)),ru(t,i),1===n&&0===Nc&&!(1&e.mode)&&(Hc=Je()+500,Va&&Ha()))}function ru(t,e){var n=t.callbackNode;!function(t,e){for(var n=t.suspendedLanes,i=t.pingedLanes,r=t.expirationTimes,a=t.pendingLanes;0<a;){var s=31-ln(a),o=1<<s,l=r[s];-1===l?o&n&&!(o&i)||(r[s]=gn(o,e)):l<=e&&(t.expiredLanes|=o),a&=~o}}(t,e);var i=pn(t,t===Dc?Oc:0);if(0===i)null!==n&&Xe(n),t.callbackNode=null,t.callbackPriority=0;else if(e=i&-i,t.callbackPriority!==e){if(null!=n&&Xe(n),1===e)0===t.tag?function(t){Va=!0,Wa(t)}(cu.bind(null,t)):Wa(cu.bind(null,t)),oa((function(){!(6&Nc)&&Ha()})),n=null;else{switch(wn(i)){case 1:n=tn;break;case 4:n=en;break;case 16:default:n=nn;break;case 536870912:n=an}n=Du(n,au.bind(null,t))}t.callbackPriority=e,t.callbackNode=n}}function au(t,e){if(Zc=-1,tu=0,6&Nc)throw Error(st(327));var n=t.callbackNode;if(ku()&&t.callbackNode!==n)return null;var i=pn(t,t===Dc?Oc:0);if(0===i)return null;if(30&i||i&t.expiredLanes||e)e=bu(t,i);else{e=i;var r=Nc;Nc|=2;var a=gu();for(Dc===t&&Oc===e||($c=null,Hc=Je()+500,fu(t,e));;)try{vu();break}catch(o){pu(t,o)}Es(),Mc.current=a,Nc=r,null!==Tc?e=0:(Dc=null,Oc=0,e=zc)}if(0!==e){if(2===e&&(0!==(r=mn(t))&&(i=r,e=su(t,r))),1===e)throw n=jc,fu(t,0),lu(t,i),ru(t,Je()),n;if(6===e)lu(t,i);else{if(r=t.current.alternate,!(30&i||function(t){for(var e=t;;){if(16384&e.flags){var n=e.updateQueue;if(null!==n&&null!==(n=n.stores))for(var i=0;i<n.length;i++){var r=n[i],a=r.getSnapshot;r=r.value;try{if(!lr(a(),r))return!1}catch(s){return!1}}}if(n=e.child,16384&e.subtreeFlags&&null!==n)n.return=e,e=n;else{if(e===t)break;for(;null===e.sibling;){if(null===e.return||e.return===t)return!0;e=e.return}e.sibling.return=e.return,e=e.sibling}}return!0}(r)||(e=bu(t,i),2===e&&(a=mn(t),0!==a&&(i=a,e=su(t,a))),1!==e)))throw n=jc,fu(t,0),lu(t,i),ru(t,Je()),n;switch(t.finishedWork=r,t.finishedLanes=i,e){case 0:case 1:throw Error(st(345));case 2:case 5:wu(t,Bc,$c);break;case 3:if(lu(t,i),(130023424&i)===i&&10<(e=Wc+500-Je())){if(0!==pn(t,0))break;if(((r=t.suspendedLanes)&i)!==i){eu(),t.pingedLanes|=t.suspendedLanes&r;break}t.timeoutHandle=ra(wu.bind(null,t,Bc,$c),e);break}wu(t,Bc,$c);break;case 4:if(lu(t,i),(4194240&i)===i)break;for(e=t.eventTimes,r=-1;0<i;){var s=31-ln(i);a=1<<s,(s=e[s])>r&&(r=s),i&=~a}if(i=r,10<(i=(120>(i=Je()-i)?120:480>i?480:1080>i?1080:1920>i?1920:3e3>i?3e3:4320>i?4320:1960*Cc(i/1960))-i)){t.timeoutHandle=ra(wu.bind(null,t,Bc,$c),i);break}wu(t,Bc,$c);break;default:throw Error(st(329))}}}return ru(t,Je()),t.callbackNode===n?au.bind(null,t):null}function su(t,e){var n=Vc;return t.current.memoizedState.isDehydrated&&(fu(t,e).flags|=256),2!==(t=bu(t,e))&&(e=Bc,Bc=n,null!==e&&ou(e)),t}function ou(t){null===Bc?Bc=t:Bc.push.apply(Bc,t)}function lu(t,e){for(e&=~Ic,e&=~Fc,t.suspendedLanes|=e,t.pingedLanes&=~e,t=t.expirationTimes;0<e;){var n=31-ln(e),i=1<<n;t[n]=-1,e&=~i}}function cu(t){if(6&Nc)throw Error(st(327));ku();var e=pn(t,0);if(!(1&e))return ru(t,Je()),null;var n=bu(t,e);if(0!==t.tag&&2===n){var i=mn(t);0!==i&&(e=i,n=su(t,i))}if(1===n)throw n=jc,fu(t,0),lu(t,e),ru(t,Je()),n;if(6===n)throw Error(st(345));return t.finishedWork=t.current.alternate,t.finishedLanes=e,wu(t,Bc,$c),ru(t,Je()),null}function uu(t,e){var n=Nc;Nc|=1;try{return t(e)}finally{0===(Nc=n)&&(Hc=Je()+500,Va&&Ha())}}function du(t){null!==Xc&&0===Xc.tag&&!(6&Nc)&&ku();var e=Nc;Nc|=1;var n=Pc.transition,i=_n;try{if(Pc.transition=null,_n=1,t)return t()}finally{_n=i,Pc.transition=n,!(6&(Nc=e))&&Ha()}}function hu(){Lc=Rc.current,Ma(Rc)}function fu(t,e){t.finishedWork=null,t.finishedLanes=0;var n=t.timeoutHandle;if(-1!==n&&(t.timeoutHandle=-1,aa(n)),null!==Tc)for(n=Tc.return;null!==n;){var i=n;switch(ns(i),i.tag){case 1:null!=(i=i.type.childContextTypes)&&Ra();break;case 3:Gs(),Ma(Da),Ma(Na),io();break;case 5:Zs(i);break;case 4:Gs();break;case 13:case 19:Ma(to);break;case 10:Ps(i.type._context);break;case 22:case 23:hu()}n=n.return}if(Dc=t,Tc=t=Ru(t.current,null),Oc=Lc=e,zc=0,jc=null,Ic=Fc=Ac=0,Bc=Vc=null,null!==Os){for(e=0;e<Os.length;e++)if(null!==(i=(n=Os[e]).interleaved)){n.interleaved=null;var r=i.next,a=n.pending;if(null!==a){var s=a.next;a.next=r,i.next=s}n.pending=i}Os=null}return t}function pu(t,e){for(;;){var n=Tc;try{if(Es(),ro.current=Zo,uo){for(var i=oo.memoizedState;null!==i;){var r=i.queue;null!==r&&(r.pending=null),i=i.next}uo=!1}if(so=0,co=lo=oo=null,ho=!1,fo=0,Ec.current=null,null===n||null===n.return){zc=1,jc=e,Tc=null;break}t:{var a=t,s=n.return,o=n,l=e;if(e=Oc,o.flags|=32768,null!==l&&"object"==typeof l&&"function"==typeof l.then){var c=l,u=o,d=u.tag;if(!(1&u.mode||0!==d&&11!==d&&15!==d)){var h=u.alternate;h?(u.updateQueue=h.updateQueue,u.memoizedState=h.memoizedState,u.lanes=h.lanes):(u.updateQueue=null,u.memoizedState=null)}var f=bl(s);if(null!==f){f.flags&=-257,xl(f,s,o,0,e),1&f.mode&&ml(a,c,e),l=c;var p=(e=f).updateQueue;if(null===p){var g=new Set;g.add(l),e.updateQueue=g}else p.add(l);break t}if(!(1&e)){ml(a,c,e),mu();break t}l=Error(st(426))}else if(as&&1&o.mode){var m=bl(s);if(null!==m){!(65536&m.flags)&&(m.flags|=256),xl(m,s,o,0,e),gs(ul(l,o));break t}}a=l=ul(l,o),4!==zc&&(zc=2),null===Vc?Vc=[a]:Vc.push(a),a=s;do{switch(a.tag){case 3:a.flags|=65536,e&=-e,a.lanes|=e,Ws(a,pl(0,l,e));break t;case 1:o=l;var b=a.type,x=a.stateNode;if(!(128&a.flags||"function"!=typeof b.getDerivedStateFromError&&(null===x||"function"!=typeof x.componentDidCatch||null!==Qc&&Qc.has(x)))){a.flags|=65536,e&=-e,a.lanes|=e,Ws(a,gl(a,o,e));break t}}a=a.return}while(null!==a)}_u(n)}catch(v){e=v,Tc===n&&null!==n&&(Tc=n=n.return);continue}break}}function gu(){var t=Mc.current;return Mc.current=Zo,null===t?Zo:t}function mu(){0!==zc&&3!==zc&&2!==zc||(zc=4),null===Dc||!(268435455&Ac)&&!(268435455&Fc)||lu(Dc,Oc)}function bu(t,e){var n=Nc;Nc|=2;var i=gu();for(Dc===t&&Oc===e||($c=null,fu(t,e));;)try{xu();break}catch(r){pu(t,r)}if(Es(),Nc=n,Mc.current=i,null!==Tc)throw Error(st(261));return Dc=null,Oc=0,zc}function xu(){for(;null!==Tc;)yu(Tc)}function vu(){for(;null!==Tc&&!Ke();)yu(Tc)}function yu(t){var e=Sc(t.alternate,t,Lc);t.memoizedProps=t.pendingProps,null===e?_u(t):Tc=e,Ec.current=null}function _u(t){var e=t;do{var n=e.alternate;if(t=e.return,32768&e.flags){if(null!==(n=Xl(n,e)))return n.flags&=32767,void(Tc=n);if(null===t)return zc=6,void(Tc=null);t.flags|=32768,t.subtreeFlags=0,t.deletions=null}else if(null!==(n=ql(n,e,Lc)))return void(Tc=n);if(null!==(e=e.sibling))return void(Tc=e);Tc=e=t}while(null!==e);0===zc&&(zc=5)}function wu(t,e,n){var i=_n,r=Pc.transition;try{Pc.transition=null,_n=1,function(t,e,n,i){do{ku()}while(null!==Xc);if(6&Nc)throw Error(st(327));n=t.finishedWork;var r=t.finishedLanes;if(null===n)return null;if(t.finishedWork=null,t.finishedLanes=0,n===t.current)throw Error(st(177));t.callbackNode=null,t.callbackPriority=0;var a=n.lanes|n.childLanes;if(function(t,e){var n=t.pendingLanes&~e;t.pendingLanes=e,t.suspendedLanes=0,t.pingedLanes=0,t.expiredLanes&=e,t.mutableReadLanes&=e,t.entangledLanes&=e,e=t.entanglements;var i=t.eventTimes;for(t=t.expirationTimes;0<n;){var r=31-ln(n),a=1<<r;e[r]=0,i[r]=-1,t[r]=-1,n&=~a}}(t,a),t===Dc&&(Tc=Dc=null,Oc=0),!(2064&n.subtreeFlags)&&!(2064&n.flags)||qc||(qc=!0,Du(nn,(function(){return ku(),null}))),a=!!(15990&n.flags),!!(15990&n.subtreeFlags)||a){a=Pc.transition,Pc.transition=null;var s=_n;_n=1;var o=Nc;Nc|=4,Ec.current=null,function(t,e){if(ea=Yn,pr(t=fr())){if("selectionStart"in t)var n={start:t.selectionStart,end:t.selectionEnd};else t:{var i=(n=(n=t.ownerDocument)&&n.defaultView||window).getSelection&&n.getSelection();if(i&&0!==i.rangeCount){n=i.anchorNode;var r=i.anchorOffset,a=i.focusNode;i=i.focusOffset;try{n.nodeType,a.nodeType}catch(y){n=null;break t}var s=0,o=-1,l=-1,c=0,u=0,d=t,h=null;e:for(;;){for(var f;d!==n||0!==r&&3!==d.nodeType||(o=s+r),d!==a||0!==i&&3!==d.nodeType||(l=s+i),3===d.nodeType&&(s+=d.nodeValue.length),null!==(f=d.firstChild);)h=d,d=f;for(;;){if(d===t)break e;if(h===n&&++c===r&&(o=s),h===a&&++u===i&&(l=s),null!==(f=d.nextSibling))break;h=(d=h).parentNode}d=f}n=-1===o||-1===l?null:{start:o,end:l}}else n=null}n=n||{start:0,end:0}}else n=null;for(na={focusedElem:t,selectionRange:n},Yn=!1,Zl=e;null!==Zl;)if(t=(e=Zl).child,1028&e.subtreeFlags&&null!==t)t.return=e,Zl=t;else for(;null!==Zl;){e=Zl;try{var p=e.alternate;if(1024&e.flags)switch(e.tag){case 0:case 11:case 15:case 5:case 6:case 4:case 17:break;case 1:if(null!==p){var g=p.memoizedProps,m=p.memoizedState,b=e.stateNode,x=b.getSnapshotBeforeUpdate(e.elementType===e.type?g:il(e.type,g),m);b.__reactInternalSnapshotBeforeUpdate=x}break;case 3:var v=e.stateNode.containerInfo;1===v.nodeType?v.textContent="":9===v.nodeType&&v.documentElement&&v.removeChild(v.documentElement);break;default:throw Error(st(163))}}catch(y){Cu(e,e.return,y)}if(null!==(t=e.sibling)){t.return=e.return,Zl=t;break}Zl=e.return}p=nc,nc=!1}(t,n),bc(n,t),gr(na),Yn=!!ea,na=ea=null,t.current=n,vc(n),Ge(),Nc=o,_n=s,Pc.transition=a}else t.current=n;if(qc&&(qc=!1,Xc=t,Kc=r),a=t.pendingLanes,0===a&&(Qc=null),function(t){if(on&&"function"==typeof on.onCommitFiberRoot)try{on.onCommitFiberRoot(sn,t,void 0,!(128&~t.current.flags))}catch(e){}}(n.stateNode),ru(t,Je()),null!==e)for(i=t.onRecoverableError,n=0;n<e.length;n++)r=e[n],i(r.value,{componentStack:r.stack,digest:r.digest});if(Uc)throw Uc=!1,t=Yc,Yc=null,t;!!(1&Kc)&&0!==t.tag&&ku(),a=t.pendingLanes,1&a?t===Jc?Gc++:(Gc=0,Jc=t):Gc=0,Ha()}(t,e,n,i)}finally{Pc.transition=r,_n=i}return null}function ku(){if(null!==Xc){var t=wn(Kc),e=Pc.transition,n=_n;try{if(Pc.transition=null,_n=16>t?16:t,null===Xc)var i=!1;else{if(t=Xc,Xc=null,Kc=0,6&Nc)throw Error(st(331));var r=Nc;for(Nc|=4,Zl=t.current;null!==Zl;){var a=Zl,s=a.child;if(16&Zl.flags){var o=a.deletions;if(null!==o){for(var l=0;l<o.length;l++){var c=o[l];for(Zl=c;null!==Zl;){var u=Zl;switch(u.tag){case 0:case 11:case 15:ic(8,u,a)}var d=u.child;if(null!==d)d.return=u,Zl=d;else for(;null!==Zl;){var h=(u=Zl).sibling,f=u.return;if(sc(u),u===c){Zl=null;break}if(null!==h){h.return=f,Zl=h;break}Zl=f}}}var p=a.alternate;if(null!==p){var g=p.child;if(null!==g){p.child=null;do{var m=g.sibling;g.sibling=null,g=m}while(null!==g)}}Zl=a}}if(2064&a.subtreeFlags&&null!==s)s.return=a,Zl=s;else t:for(;null!==Zl;){if(2048&(a=Zl).flags)switch(a.tag){case 0:case 11:case 15:ic(9,a,a.return)}var b=a.sibling;if(null!==b){b.return=a.return,Zl=b;break t}Zl=a.return}}var x=t.current;for(Zl=x;null!==Zl;){var v=(s=Zl).child;if(2064&s.subtreeFlags&&null!==v)v.return=s,Zl=v;else t:for(s=x;null!==Zl;){if(2048&(o=Zl).flags)try{switch(o.tag){case 0:case 11:case 15:rc(9,o)}}catch(_){Cu(o,o.return,_)}if(o===s){Zl=null;break t}var y=o.sibling;if(null!==y){y.return=o.return,Zl=y;break t}Zl=o.return}}if(Nc=r,Ha(),on&&"function"==typeof on.onPostCommitFiberRoot)try{on.onPostCommitFiberRoot(sn,t)}catch(_){}i=!0}return i}finally{_n=n,Pc.transition=e}}return!1}function Su(t,e,n){t=Vs(t,e=pl(0,e=ul(n,e),1),1),e=eu(),null!==t&&(vn(t,1,e),ru(t,e))}function Cu(t,e,n){if(3===t.tag)Su(t,t,n);else for(;null!==e;){if(3===e.tag){Su(e,t,n);break}if(1===e.tag){var i=e.stateNode;if("function"==typeof e.type.getDerivedStateFromError||"function"==typeof i.componentDidCatch&&(null===Qc||!Qc.has(i))){e=Vs(e,t=gl(e,t=ul(n,t),1),1),t=eu(),null!==e&&(vn(e,1,t),ru(e,t));break}}e=e.return}}function Mu(t,e,n){var i=t.pingCache;null!==i&&i.delete(e),e=eu(),t.pingedLanes|=t.suspendedLanes&n,Dc===t&&(Oc&n)===n&&(4===zc||3===zc&&(130023424&Oc)===Oc&&500>Je()-Wc?fu(t,0):Ic|=n),ru(t,e)}function Eu(t,e){0===e&&(1&t.mode?(e=hn,!(130023424&(hn<<=1))&&(hn=4194304)):e=1);var n=eu();null!==(t=zs(t,e))&&(vn(t,e,n),ru(t,n))}function Pu(t){var e=t.memoizedState,n=0;null!==e&&(n=e.retryLane),Eu(t,n)}function Nu(t,e){var n=0;switch(t.tag){case 13:var i=t.stateNode,r=t.memoizedState;null!==r&&(n=r.retryLane);break;case 19:i=t.stateNode;break;default:throw Error(st(314))}null!==i&&i.delete(e),Eu(t,n)}function Du(t,e){return qe(t,e)}function Tu(t,e,n,i){this.tag=t,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=e,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=i,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Ou(t,e,n,i){return new Tu(t,e,n,i)}function Lu(t){return!(!(t=t.prototype)||!t.isReactComponent)}function Ru(t,e){var n=t.alternate;return null===n?((n=Ou(t.tag,e,t.key,t.mode)).elementType=t.elementType,n.type=t.type,n.stateNode=t.stateNode,n.alternate=t,t.alternate=n):(n.pendingProps=e,n.type=t.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=14680064&t.flags,n.childLanes=t.childLanes,n.lanes=t.lanes,n.child=t.child,n.memoizedProps=t.memoizedProps,n.memoizedState=t.memoizedState,n.updateQueue=t.updateQueue,e=t.dependencies,n.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext},n.sibling=t.sibling,n.index=t.index,n.ref=t.ref,n}function zu(t,e,n,i,r,a){var s=2;if(i=t,"function"==typeof t)Lu(t)&&(s=1);else if("string"==typeof t)s=5;else t:switch(t){case St:return ju(n.children,r,a,e);case Ct:s=8,r|=8;break;case Mt:return(t=Ou(12,n,e,2|r)).elementType=Mt,t.lanes=a,t;case Dt:return(t=Ou(13,n,e,r)).elementType=Dt,t.lanes=a,t;case Tt:return(t=Ou(19,n,e,r)).elementType=Tt,t.lanes=a,t;case Rt:return Au(n,r,a,e);default:if("object"==typeof t&&null!==t)switch(t.$$typeof){case Et:s=10;break t;case Pt:s=9;break t;case Nt:s=11;break t;case Ot:s=14;break t;case Lt:s=16,i=null;break t}throw Error(st(130,null==t?t:typeof t,""))}return(e=Ou(s,n,e,r)).elementType=t,e.type=i,e.lanes=a,e}function ju(t,e,n,i){return(t=Ou(7,t,i,e)).lanes=n,t}function Au(t,e,n,i){return(t=Ou(22,t,i,e)).elementType=Rt,t.lanes=n,t.stateNode={isHidden:!1},t}function Fu(t,e,n){return(t=Ou(6,t,null,e)).lanes=n,t}function Iu(t,e,n){return(e=Ou(4,null!==t.children?t.children:[],t.key,e)).lanes=n,e.stateNode={containerInfo:t.containerInfo,pendingChildren:null,implementation:t.implementation},e}function Vu(t,e,n,i,r){this.tag=e,this.containerInfo=t,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=xn(0),this.expirationTimes=xn(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=xn(0),this.identifierPrefix=i,this.onRecoverableError=r,this.mutableSourceEagerHydrationData=null}function Bu(t,e,n,i,r,a,s,o,l){return t=new Vu(t,e,n,o,l),1===e?(e=1,!0===a&&(e|=8)):e=0,a=Ou(3,null,null,e),t.current=a,a.stateNode=t,a.memoizedState={element:i,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},As(a),t}function Wu(t){if(!t)return Pa;t:{if(He(t=t._reactInternals)!==t||1!==t.tag)throw Error(st(170));var e=t;do{switch(e.tag){case 3:e=e.stateNode.context;break t;case 1:if(La(e.type)){e=e.stateNode.__reactInternalMemoizedMergedChildContext;break t}}e=e.return}while(null!==e);throw Error(st(171))}if(1===t.tag){var n=t.type;if(La(n))return ja(t,n,e)}return e}function Hu(t,e,n,i,r,a,s,o,l){return(t=Bu(n,i,!0,t,0,a,0,o,l)).context=Wu(null),n=t.current,(a=Is(i=eu(),r=nu(n))).callback=null!=e?e:null,Vs(n,a,r),t.current.lanes=r,vn(t,r,i),ru(t,i),t}function $u(t,e,n,i){var r=e.current,a=eu(),s=nu(r);return n=Wu(n),null===e.context?e.context=n:e.pendingContext=n,(e=Is(a,s)).payload={element:t},null!==(i=void 0===i?null:i)&&(e.callback=i),null!==(t=Vs(r,e,s))&&(iu(t,r,s,a),Bs(t,r,s)),s}function Uu(t){return(t=t.current).child?(t.child.tag,t.child.stateNode):null}function Yu(t,e){if(null!==(t=t.memoizedState)&&null!==t.dehydrated){var n=t.retryLane;t.retryLane=0!==n&&n<e?n:e}}function Qu(t,e){Yu(t,e),(t=t.alternate)&&Yu(t,e)}Sc=function(t,e,n){if(null!==t)if(t.memoizedProps!==e.pendingProps||Da.current)yl=!0;else{if(!(t.lanes&n||128&e.flags))return yl=!1,function(t,e,n){switch(e.tag){case 3:Dl(e),ps();break;case 5:Js(e);break;case 1:La(e.type)&&Aa(e);break;case 4:Ks(e,e.stateNode.containerInfo);break;case 10:var i=e.type._context,r=e.memoizedProps.value;Ea(ks,i._currentValue),i._currentValue=r;break;case 13:if(null!==(i=e.memoizedState))return null!==i.dehydrated?(Ea(to,1&to.current),e.flags|=128,null):n&e.child.childLanes?Fl(t,e,n):(Ea(to,1&to.current),null!==(t=Ul(t,e,n))?t.sibling:null);Ea(to,1&to.current);break;case 19:if(i=!!(n&e.childLanes),128&t.flags){if(i)return Hl(t,e,n);e.flags|=128}if(null!==(r=e.memoizedState)&&(r.rendering=null,r.tail=null,r.lastEffect=null),Ea(to,to.current),i)break;return null;case 22:case 23:return e.lanes=0,Cl(t,e,n)}return Ul(t,e,n)}(t,e,n);yl=!!(131072&t.flags)}else yl=!1,as&&1048576&e.flags&&ts(e,Qa,e.index);switch(e.lanes=0,e.tag){case 2:var i=e.type;$l(t,e),t=e.pendingProps;var r=Oa(e,Na.current);Ds(e,n),r=bo(null,e,i,t,r,n);var a=xo();return e.flags|=1,"object"==typeof r&&null!==r&&"function"==typeof r.render&&void 0===r.$$typeof?(e.tag=1,e.memoizedState=null,e.updateQueue=null,La(i)?(a=!0,Aa(e)):a=!1,e.memoizedState=null!==r.state&&void 0!==r.state?r.state:null,As(e),r.updater=al,e.stateNode=r,r._reactInternals=e,cl(e,i,t,n),e=Nl(null,e,i,!0,a,n)):(e.tag=0,as&&a&&es(e),_l(null,e,r,n),e=e.child),e;case 16:i=e.elementType;t:{switch($l(t,e),t=e.pendingProps,i=(r=i._init)(i._payload),e.type=i,r=e.tag=function(t){if("function"==typeof t)return Lu(t)?1:0;if(null!=t){if((t=t.$$typeof)===Nt)return 11;if(t===Ot)return 14}return 2}(i),t=il(i,t),r){case 0:e=El(null,e,i,t,n);break t;case 1:e=Pl(null,e,i,t,n);break t;case 11:e=wl(null,e,i,t,n);break t;case 14:e=kl(null,e,i,il(i.type,t),n);break t}throw Error(st(306,i,""))}return e;case 0:return i=e.type,r=e.pendingProps,El(t,e,i,r=e.elementType===i?r:il(i,r),n);case 1:return i=e.type,r=e.pendingProps,Pl(t,e,i,r=e.elementType===i?r:il(i,r),n);case 3:t:{if(Dl(e),null===t)throw Error(st(387));i=e.pendingProps,r=(a=e.memoizedState).element,Fs(t,e),Hs(e,i,null,n);var s=e.memoizedState;if(i=s.element,a.isDehydrated){if(a={element:i,isDehydrated:!1,cache:s.cache,pendingSuspenseBoundaries:s.pendingSuspenseBoundaries,transitions:s.transitions},e.updateQueue.baseState=a,e.memoizedState=a,256&e.flags){e=Tl(t,e,i,n,r=ul(Error(st(423)),e));break t}if(i!==r){e=Tl(t,e,i,n,r=ul(Error(st(424)),e));break t}for(rs=ua(e.stateNode.containerInfo.firstChild),is=e,as=!0,ss=null,n=ws(e,null,i,n),e.child=n;n;)n.flags=-3&n.flags|4096,n=n.sibling}else{if(ps(),i===r){e=Ul(t,e,n);break t}_l(t,e,i,n)}e=e.child}return e;case 5:return Js(e),null===t&&us(e),i=e.type,r=e.pendingProps,a=null!==t?t.memoizedProps:null,s=r.children,ia(i,r)?s=null:null!==a&&ia(i,a)&&(e.flags|=32),Ml(t,e),_l(t,e,s,n),e.child;case 6:return null===t&&us(e),null;case 13:return Fl(t,e,n);case 4:return Ks(e,e.stateNode.containerInfo),i=e.pendingProps,null===t?e.child=_s(e,null,i,n):_l(t,e,i,n),e.child;case 11:return i=e.type,r=e.pendingProps,wl(t,e,i,r=e.elementType===i?r:il(i,r),n);case 7:return _l(t,e,e.pendingProps,n),e.child;case 8:case 12:return _l(t,e,e.pendingProps.children,n),e.child;case 10:t:{if(i=e.type._context,r=e.pendingProps,a=e.memoizedProps,s=r.value,Ea(ks,i._currentValue),i._currentValue=s,null!==a)if(lr(a.value,s)){if(a.children===r.children&&!Da.current){e=Ul(t,e,n);break t}}else for(null!==(a=e.child)&&(a.return=e);null!==a;){var o=a.dependencies;if(null!==o){s=a.child;for(var l=o.firstContext;null!==l;){if(l.context===i){if(1===a.tag){(l=Is(-1,n&-n)).tag=2;var c=a.updateQueue;if(null!==c){var u=(c=c.shared).pending;null===u?l.next=l:(l.next=u.next,u.next=l),c.pending=l}}a.lanes|=n,null!==(l=a.alternate)&&(l.lanes|=n),Ns(a.return,n,e),o.lanes|=n;break}l=l.next}}else if(10===a.tag)s=a.type===e.type?null:a.child;else if(18===a.tag){if(null===(s=a.return))throw Error(st(341));s.lanes|=n,null!==(o=s.alternate)&&(o.lanes|=n),Ns(s,n,e),s=a.sibling}else s=a.child;if(null!==s)s.return=a;else for(s=a;null!==s;){if(s===e){s=null;break}if(null!==(a=s.sibling)){a.return=s.return,s=a;break}s=s.return}a=s}_l(t,e,r.children,n),e=e.child}return e;case 9:return r=e.type,i=e.pendingProps.children,Ds(e,n),i=i(r=Ts(r)),e.flags|=1,_l(t,e,i,n),e.child;case 14:return r=il(i=e.type,e.pendingProps),kl(t,e,i,r=il(i.type,r),n);case 15:return Sl(t,e,e.type,e.pendingProps,n);case 17:return i=e.type,r=e.pendingProps,r=e.elementType===i?r:il(i,r),$l(t,e),e.tag=1,La(i)?(t=!0,Aa(e)):t=!1,Ds(e,n),ol(e,i,r),cl(e,i,r,n),Nl(null,e,i,!0,t,n);case 19:return Hl(t,e,n);case 22:return Cl(t,e,n)}throw Error(st(156,e.tag))};var qu="function"==typeof reportError?reportError:function(t){console.error(t)};function Xu(t){this._internalRoot=t}function Ku(t){this._internalRoot=t}function Gu(t){return!(!t||1!==t.nodeType&&9!==t.nodeType&&11!==t.nodeType)}function Ju(t){return!(!t||1!==t.nodeType&&9!==t.nodeType&&11!==t.nodeType&&(8!==t.nodeType||" react-mount-point-unstable "!==t.nodeValue))}function Zu(){}function td(t,e,n,i,r){var a=n._reactRootContainer;if(a){var s=a;if("function"==typeof r){var o=r;r=function(){var t=Uu(s);o.call(t)}}$u(e,s,t,r)}else s=function(t,e,n,i,r){if(r){if("function"==typeof i){var a=i;i=function(){var t=Uu(s);a.call(t)}}var s=Hu(e,i,t,0,null,!1,0,"",Zu);return t._reactRootContainer=s,t[ga]=s.current,Hr(8===t.nodeType?t.parentNode:t),du(),s}for(;r=t.lastChild;)t.removeChild(r);if("function"==typeof i){var o=i;i=function(){var t=Uu(l);o.call(t)}}var l=Bu(t,0,!1,null,0,!1,0,"",Zu);return t._reactRootContainer=l,t[ga]=l.current,Hr(8===t.nodeType?t.parentNode:t),du((function(){$u(e,l,n,i)})),l}(n,e,t,r,i);return Uu(s)}Ku.prototype.render=Xu.prototype.render=function(t){var e=this._internalRoot;if(null===e)throw Error(st(409));$u(t,e,null,null)},Ku.prototype.unmount=Xu.prototype.unmount=function(){var t=this._internalRoot;if(null!==t){this._internalRoot=null;var e=t.containerInfo;du((function(){$u(null,t,null,null)})),e[ga]=null}},Ku.prototype.unstable_scheduleHydration=function(t){if(t){var e=Mn();t={blockedOn:null,target:t,priority:e};for(var n=0;n<zn.length&&0!==e&&e<zn[n].priority;n++);zn.splice(n,0,t),0===n&&In(t)}},kn=function(t){switch(t.tag){case 3:var e=t.stateNode;if(e.current.memoizedState.isDehydrated){var n=fn(e.pendingLanes);0!==n&&(yn(e,1|n),ru(e,Je()),!(6&Nc)&&(Hc=Je()+500,Ha()))}break;case 13:du((function(){var e=zs(t,1);if(null!==e){var n=eu();iu(e,t,1,n)}})),Qu(t,1)}},Sn=function(t){if(13===t.tag){var e=zs(t,134217728);if(null!==e)iu(e,t,134217728,eu());Qu(t,134217728)}},Cn=function(t){if(13===t.tag){var e=nu(t),n=zs(t,e);if(null!==n)iu(n,t,e,eu());Qu(t,e)}},Mn=function(){return _n},En=function(t,e){var n=_n;try{return _n=t,e()}finally{_n=n}},ke=function(t,e,n){switch(e){case"input":if(Zt(t,n),e=n.name,"radio"===n.type&&null!=e){for(n=t;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+e)+'][type="radio"]'),e=0;e<n.length;e++){var i=n[e];if(i!==t&&i.form===t.form){var r=wa(i);if(!r)throw Error(st(90));qt(i),Zt(i,r)}}}break;case"textarea":se(t,n);break;case"select":null!=(e=n.value)&&ie(t,!!n.multiple,e,!1)}},Ne=uu,De=du;var ed={usingClientEntryPoint:!1,Events:[ya,_a,wa,Ee,Pe,uu]},nd={findFiberByHostInstance:va,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},id={bundleType:nd.bundleType,version:nd.version,rendererPackageName:nd.rendererPackageName,rendererConfig:nd.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:_t.ReactCurrentDispatcher,findHostInstanceByFiber:function(t){return null===(t=Ye(t))?null:t.stateNode},findFiberByHostInstance:nd.findFiberByHostInstance||function(){return null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if("undefined"!=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var rd=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!rd.isDisabled&&rd.supportsFiber)try{sn=rd.inject(id),on=rd}catch(de){}}tt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=ed,tt.createPortal=function(t,e){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!Gu(e))throw Error(st(200));return function(t,e,n){var i=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:kt,key:null==i?null:""+i,children:t,containerInfo:e,implementation:n}}(t,e,null,n)},tt.createRoot=function(t,e){if(!Gu(t))throw Error(st(299));var n=!1,i="",r=qu;return null!=e&&(!0===e.unstable_strictMode&&(n=!0),void 0!==e.identifierPrefix&&(i=e.identifierPrefix),void 0!==e.onRecoverableError&&(r=e.onRecoverableError)),e=Bu(t,1,!1,null,0,n,0,i,r),t[ga]=e.current,Hr(8===t.nodeType?t.parentNode:t),new Xu(e)},tt.findDOMNode=function(t){if(null==t)return null;if(1===t.nodeType)return t;var e=t._reactInternals;if(void 0===e){if("function"==typeof t.render)throw Error(st(188));throw t=Object.keys(t).join(","),Error(st(268,t))}return t=null===(t=Ye(e))?null:t.stateNode},tt.flushSync=function(t){return du(t)},tt.hydrate=function(t,e,n){if(!Ju(e))throw Error(st(200));return td(null,t,e,!0,n)},tt.hydrateRoot=function(t,e,n){if(!Gu(t))throw Error(st(405));var i=null!=n&&n.hydratedSources||null,r=!1,a="",s=qu;if(null!=n&&(!0===n.unstable_strictMode&&(r=!0),void 0!==n.identifierPrefix&&(a=n.identifierPrefix),void 0!==n.onRecoverableError&&(s=n.onRecoverableError)),e=Hu(e,null,t,1,null!=n?n:null,r,0,a,s),t[ga]=e.current,Hr(t),i)for(t=0;t<i.length;t++)r=(r=(n=i[t])._getVersion)(n._source),null==e.mutableSourceEagerHydrationData?e.mutableSourceEagerHydrationData=[n,r]:e.mutableSourceEagerHydrationData.push(n,r);return new Ku(e)},tt.render=function(t,e,n){if(!Ju(e))throw Error(st(200));return td(null,t,e,!1,n)},tt.unmountComponentAtNode=function(t){if(!Ju(t))throw Error(st(40));return!!t._reactRootContainer&&(du((function(){td(null,null,t,!1,(function(){t._reactRootContainer=null,t[ga]=null}))})),!0)},tt.unstable_batchedUpdates=uu,tt.unstable_renderSubtreeIntoContainer=function(t,e,n,i){if(!Ju(n))throw Error(st(200));if(null==t||void 0===t._reactInternals)throw Error(st(38));return td(t,e,n,!1,i)},tt.version="18.3.1-next-f1338f8080-20240426",function t(){if("undefined"!=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t)}catch(e){console.error(e)}}(),Z.exports=tt;var ad,sd,od=Z.exports;
/**
 * @remix-run/router v1.23.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function ld(){return ld=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(t[i]=n[i])}return t},ld.apply(this,arguments)}J.createRoot=od.createRoot,J.hydrateRoot=od.hydrateRoot,(sd=ad||(ad={})).Pop="POP",sd.Push="PUSH",sd.Replace="REPLACE";const cd="popstate";function ud(t){return void 0===t&&(t={}),function(t,e,n,i){void 0===i&&(i={});let{window:r=document.defaultView,v5Compat:a=!1}=i,s=r.history,o=ad.Pop,l=null,c=u();null==c&&(c=0,s.replaceState(ld({},s.state,{idx:c}),""));function u(){return(s.state||{idx:null}).idx}function d(){o=ad.Pop;let t=u(),e=null==t?null:t-c;c=t,l&&l({action:o,location:g.location,delta:e})}function h(t,e){o=ad.Push;let i=pd(g.location,t,e);n&&n(i,t),c=u()+1;let d=fd(i,c),h=g.createHref(i);try{s.pushState(d,"",h)}catch(f){if(f instanceof DOMException&&"DataCloneError"===f.name)throw f;r.location.assign(h)}a&&l&&l({action:o,location:g.location,delta:1})}function f(t,e){o=ad.Replace;let i=pd(g.location,t,e);n&&n(i,t),c=u();let r=fd(i,c),d=g.createHref(i);s.replaceState(r,"",d),a&&l&&l({action:o,location:g.location,delta:0})}function p(t){let e="null"!==r.location.origin?r.location.origin:r.location.href,n="string"==typeof t?t:gd(t);return n=n.replace(/ $/,"%20"),dd(e,"No window.location.(origin|href) available to create URL for href: "+n),new URL(n,e)}let g={get action(){return o},get location(){return t(r,s)},listen(t){if(l)throw new Error("A history only accepts one active listener");return r.addEventListener(cd,d),l=t,()=>{r.removeEventListener(cd,d),l=null}},createHref:t=>e(r,t),createURL:p,encodeLocation(t){let e=p(t);return{pathname:e.pathname,search:e.search,hash:e.hash}},push:h,replace:f,go:t=>s.go(t)};return g}((function(t,e){let{pathname:n,search:i,hash:r}=t.location;return pd("",{pathname:n,search:i,hash:r},e.state&&e.state.usr||null,e.state&&e.state.key||"default")}),(function(t,e){return"string"==typeof e?e:gd(e)}),null,t)}function dd(t,e){if(!1===t||null==t)throw new Error(e)}function hd(t,e){if(!t){"undefined"!=typeof console&&console.warn(e);try{throw new Error(e)}catch(n){}}}function fd(t,e){return{usr:t.state,key:t.key,idx:e}}function pd(t,e,n,i){return void 0===n&&(n=null),ld({pathname:"string"==typeof t?t:t.pathname,search:"",hash:""},"string"==typeof e?md(e):e,{state:n,key:e&&e.key||i||Math.random().toString(36).substr(2,8)})}function gd(t){let{pathname:e="/",search:n="",hash:i=""}=t;return n&&"?"!==n&&(e+="?"===n.charAt(0)?n:"?"+n),i&&"#"!==i&&(e+="#"===i.charAt(0)?i:"#"+i),e}function md(t){let e={};if(t){let n=t.indexOf("#");n>=0&&(e.hash=t.substr(n),t=t.substr(0,n));let i=t.indexOf("?");i>=0&&(e.search=t.substr(i),t=t.substr(0,i)),t&&(e.pathname=t)}return e}var bd,xd;function vd(t,e,n){return void 0===n&&(n="/"),function(t,e,n,i){let r="string"==typeof e?md(e):e,a=Ld(r.pathname||"/",n);if(null==a)return null;let s=yd(t);!function(t){t.sort(((t,e)=>t.score!==e.score?e.score-t.score:function(t,e){let n=t.length===e.length&&t.slice(0,-1).every(((t,n)=>t===e[n]));return n?t[t.length-1]-e[e.length-1]:0}(t.routesMeta.map((t=>t.childrenIndex)),e.routesMeta.map((t=>t.childrenIndex)))))}(s);let o=null;for(let l=0;null==o&&l<s.length;++l){let t=Od(a);o=Dd(s[l],t,i)}return o}(t,e,n,!1)}function yd(t,e,n,i){void 0===e&&(e=[]),void 0===n&&(n=[]),void 0===i&&(i="");let r=(t,r,a)=>{let s={relativePath:void 0===a?t.path||"":a,caseSensitive:!0===t.caseSensitive,childrenIndex:r,route:t};s.relativePath.startsWith("/")&&(dd(s.relativePath.startsWith(i),'Absolute route path "'+s.relativePath+'" nested under path "'+i+'" is not valid. An absolute child route path must start with the combined path of all its parent routes.'),s.relativePath=s.relativePath.slice(i.length));let o=Ad([i,s.relativePath]),l=n.concat(s);t.children&&t.children.length>0&&(dd(!0!==t.index,'Index routes must not have child routes. Please remove all child routes from route path "'+o+'".'),yd(t.children,e,l,o)),(null!=t.path||t.index)&&e.push({path:o,score:Nd(o,t.index),routesMeta:l})};return t.forEach(((t,e)=>{var n;if(""!==t.path&&null!=(n=t.path)&&n.includes("?"))for(let i of _d(t.path))r(t,e,i);else r(t,e)})),e}function _d(t){let e=t.split("/");if(0===e.length)return[];let[n,...i]=e,r=n.endsWith("?"),a=n.replace(/\?$/,"");if(0===i.length)return r?[a,""]:[a];let s=_d(i.join("/")),o=[];return o.push(...s.map((t=>""===t?a:[a,t].join("/")))),r&&o.push(...s),o.map((e=>t.startsWith("/")&&""===e?"/":e))}(xd=bd||(bd={})).data="data",xd.deferred="deferred",xd.redirect="redirect",xd.error="error";const wd=/^:[\w-]+$/,kd=3,Sd=2,Cd=1,Md=10,Ed=-2,Pd=t=>"*"===t;function Nd(t,e){let n=t.split("/"),i=n.length;return n.some(Pd)&&(i+=Ed),e&&(i+=Sd),n.filter((t=>!Pd(t))).reduce(((t,e)=>t+(wd.test(e)?kd:""===e?Cd:Md)),i)}function Dd(t,e,n){void 0===n&&(n=!1);let{routesMeta:i}=t,r={},a="/",s=[];for(let o=0;o<i.length;++o){let t=i[o],l=o===i.length-1,c="/"===a?e:e.slice(a.length)||"/",u=Td({path:t.relativePath,caseSensitive:t.caseSensitive,end:l},c),d=t.route;if(!u&&l&&n&&!i[i.length-1].route.index&&(u=Td({path:t.relativePath,caseSensitive:t.caseSensitive,end:!1},c)),!u)return null;Object.assign(r,u.params),s.push({params:r,pathname:Ad([a,u.pathname]),pathnameBase:Fd(Ad([a,u.pathnameBase])),route:d}),"/"!==u.pathnameBase&&(a=Ad([a,u.pathnameBase]))}return s}function Td(t,e){"string"==typeof t&&(t={path:t,caseSensitive:!1,end:!0});let[n,i]=function(t,e,n){void 0===e&&(e=!1);void 0===n&&(n=!0);hd("*"===t||!t.endsWith("*")||t.endsWith("/*"),'Route path "'+t+'" will be treated as if it were "'+t.replace(/\*$/,"/*")+'" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "'+t.replace(/\*$/,"/*")+'".');let i=[],r="^"+t.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,((t,e,n)=>(i.push({paramName:e,isOptional:null!=n}),n?"/?([^\\/]+)?":"/([^\\/]+)")));t.endsWith("*")?(i.push({paramName:"*"}),r+="*"===t||"/*"===t?"(.*)$":"(?:\\/(.+)|\\/*)$"):n?r+="\\/*$":""!==t&&"/"!==t&&(r+="(?:(?=\\/|$))");let a=new RegExp(r,e?void 0:"i");return[a,i]}(t.path,t.caseSensitive,t.end),r=e.match(n);if(!r)return null;let a=r[0],s=a.replace(/(.)\/+$/,"$1"),o=r.slice(1);return{params:i.reduce(((t,e,n)=>{let{paramName:i,isOptional:r}=e;if("*"===i){let t=o[n]||"";s=a.slice(0,a.length-t.length).replace(/(.)\/+$/,"$1")}const l=o[n];return t[i]=r&&!l?void 0:(l||"").replace(/%2F/g,"/"),t}),{}),pathname:a,pathnameBase:s,pattern:t}}function Od(t){try{return t.split("/").map((t=>decodeURIComponent(t).replace(/\//g,"%2F"))).join("/")}catch(e){return hd(!1,'The URL path "'+t+'" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent encoding ('+e+")."),t}}function Ld(t,e){if("/"===e)return t;if(!t.toLowerCase().startsWith(e.toLowerCase()))return null;let n=e.endsWith("/")?e.length-1:e.length,i=t.charAt(n);return i&&"/"!==i?null:t.slice(n)||"/"}function Rd(t,e,n,i){return"Cannot include a '"+t+"' character in a manually specified `to."+e+"` field ["+JSON.stringify(i)+"].  Please separate it out to the `to."+n+'` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.'}function zd(t,e){let n=function(t){return t.filter(((t,e)=>0===e||t.route.path&&t.route.path.length>0))}(t);return e?n.map(((t,e)=>e===n.length-1?t.pathname:t.pathnameBase)):n.map((t=>t.pathnameBase))}function jd(t,e,n,i){let r;void 0===i&&(i=!1),"string"==typeof t?r=md(t):(r=ld({},t),dd(!r.pathname||!r.pathname.includes("?"),Rd("?","pathname","search",r)),dd(!r.pathname||!r.pathname.includes("#"),Rd("#","pathname","hash",r)),dd(!r.search||!r.search.includes("#"),Rd("#","search","hash",r)));let a,s=""===t||""===r.pathname,o=s?"/":r.pathname;if(null==o)a=n;else{let t=e.length-1;if(!i&&o.startsWith("..")){let e=o.split("/");for(;".."===e[0];)e.shift(),t-=1;r.pathname=e.join("/")}a=t>=0?e[t]:"/"}let l=function(t,e){void 0===e&&(e="/");let{pathname:n,search:i="",hash:r=""}="string"==typeof t?md(t):t,a=n?n.startsWith("/")?n:function(t,e){let n=e.replace(/\/+$/,"").split("/");return t.split("/").forEach((t=>{".."===t?n.length>1&&n.pop():"."!==t&&n.push(t)})),n.length>1?n.join("/"):"/"}(n,e):e;return{pathname:a,search:Id(i),hash:Vd(r)}}(r,a),c=o&&"/"!==o&&o.endsWith("/"),u=(s||"."===o)&&n.endsWith("/");return l.pathname.endsWith("/")||!c&&!u||(l.pathname+="/"),l}const Ad=t=>t.join("/").replace(/\/\/+/g,"/"),Fd=t=>t.replace(/\/+$/,"").replace(/^\/*/,"/"),Id=t=>t&&"?"!==t?t.startsWith("?")?t:"?"+t:"",Vd=t=>t&&"#"!==t?t.startsWith("#")?t:"#"+t:"";const Bd=["post","put","patch","delete"];new Set(Bd);const Wd=["get",...Bd];
/**
 * React Router v6.30.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function Hd(){return Hd=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(t[i]=n[i])}return t},Hd.apply(this,arguments)}new Set(Wd);const $d=V.createContext(null),Ud=V.createContext(null),Yd=V.createContext(null),Qd=V.createContext(null),qd=V.createContext({outlet:null,matches:[],isDataRoute:!1}),Xd=V.createContext(null);function Kd(){return null!=V.useContext(Qd)}function Gd(){return Kd()||dd(!1),V.useContext(Qd).location}function Jd(t){V.useContext(Yd).static||V.useLayoutEffect(t)}function Zd(){let{isDataRoute:t}=V.useContext(qd);return t?function(){let{router:t}=function(){let t=V.useContext($d);return t||dd(!1),t}(oh.UseNavigateStable),e=ch(lh.UseNavigateStable),n=V.useRef(!1);return Jd((()=>{n.current=!0})),V.useCallback((function(i,r){void 0===r&&(r={}),n.current&&("number"==typeof i?t.navigate(i):t.navigate(i,Hd({fromRouteId:e},r)))}),[t,e])}():function(){Kd()||dd(!1);let t=V.useContext($d),{basename:e,future:n,navigator:i}=V.useContext(Yd),{matches:r}=V.useContext(qd),{pathname:a}=Gd(),s=JSON.stringify(zd(r,n.v7_relativeSplatPath)),o=V.useRef(!1);return Jd((()=>{o.current=!0})),V.useCallback((function(n,r){if(void 0===r&&(r={}),!o.current)return;if("number"==typeof n)return void i.go(n);let l=jd(n,JSON.parse(s),a,"path"===r.relative);null==t&&"/"!==e&&(l.pathname="/"===l.pathname?e:Ad([e,l.pathname])),(r.replace?i.replace:i.push)(l,r.state,r)}),[e,i,s,a,t])}()}const th=V.createContext(null);function eh(t,e){let{relative:n}=void 0===e?{}:e,{future:i}=V.useContext(Yd),{matches:r}=V.useContext(qd),{pathname:a}=Gd(),s=JSON.stringify(zd(r,i.v7_relativeSplatPath));return V.useMemo((()=>jd(t,JSON.parse(s),a,"path"===n)),[t,s,a,n])}function nh(t,e){return function(t,e,n,i){Kd()||dd(!1);let{navigator:r,static:a}=V.useContext(Yd),{matches:s}=V.useContext(qd),o=s[s.length-1],l=o?o.params:{};!o||o.pathname;let c=o?o.pathnameBase:"/";o&&o.route;let u,d=Gd();if(e){var h;let t="string"==typeof e?md(e):e;"/"===c||(null==(h=t.pathname)?void 0:h.startsWith(c))||dd(!1),u=t}else u=d;let f=u.pathname||"/",p=f;if("/"!==c){let t=c.replace(/^\//,"").split("/");p="/"+f.replace(/^\//,"").split("/").slice(t.length).join("/")}let g=!a&&n&&n.matches&&n.matches.length>0?n.matches:vd(t,{pathname:p}),m=function(t,e,n,i){var r;void 0===e&&(e=[]);void 0===n&&(n=null);void 0===i&&(i=null);if(null==t){var a;if(!n)return null;if(n.errors)t=n.matches;else{if(!(null!=(a=i)&&a.v7_partialHydration&&0===e.length&&!n.initialized&&n.matches.length>0))return null;t=n.matches}}let s=t,o=null==(r=n)?void 0:r.errors;if(null!=o){let t=s.findIndex((t=>t.route.id&&void 0!==(null==o?void 0:o[t.route.id])));t>=0||dd(!1),s=s.slice(0,Math.min(s.length,t+1))}let l=!1,c=-1;if(n&&i&&i.v7_partialHydration)for(let u=0;u<s.length;u++){let t=s[u];if((t.route.HydrateFallback||t.route.hydrateFallbackElement)&&(c=u),t.route.id){let{loaderData:e,errors:i}=n,r=t.route.loader&&void 0===e[t.route.id]&&(!i||void 0===i[t.route.id]);if(t.route.lazy||r){l=!0,s=c>=0?s.slice(0,c+1):[s[0]];break}}}return s.reduceRight(((t,i,r)=>{let a,u=!1,d=null,h=null;var f;n&&(a=o&&i.route.id?o[i.route.id]:void 0,d=i.route.errorElement||rh,l&&(c<0&&0===r?(f="route-fallback",!1||uh[f]||(uh[f]=!0),u=!0,h=null):c===r&&(u=!0,h=i.route.hydrateFallbackElement||null)));let p=e.concat(s.slice(0,r+1)),g=()=>{let e;return e=a?d:u?h:i.route.Component?V.createElement(i.route.Component,null):i.route.element?i.route.element:t,V.createElement(sh,{match:i,routeContext:{outlet:t,matches:p,isDataRoute:null!=n},children:e})};return n&&(i.route.ErrorBoundary||i.route.errorElement||0===r)?V.createElement(ah,{location:n.location,revalidation:n.revalidation,component:d,error:a,children:g(),routeContext:{outlet:null,matches:p,isDataRoute:!0}}):g()}),null)}(g&&g.map((t=>Object.assign({},t,{params:Object.assign({},l,t.params),pathname:Ad([c,r.encodeLocation?r.encodeLocation(t.pathname).pathname:t.pathname]),pathnameBase:"/"===t.pathnameBase?c:Ad([c,r.encodeLocation?r.encodeLocation(t.pathnameBase).pathname:t.pathnameBase])}))),s,n,i);if(e&&m)return V.createElement(Qd.Provider,{value:{location:Hd({pathname:"/",search:"",hash:"",state:null,key:"default"},u),navigationType:ad.Pop}},m);return m}(t,e)}function ih(){let t=function(){var t;let e=V.useContext(Xd),n=function(){let t=V.useContext(Ud);return t||dd(!1),t}(lh.UseRouteError),i=ch(lh.UseRouteError);if(void 0!==e)return e;return null==(t=n.errors)?void 0:t[i]}(),e=function(t){return null!=t&&"number"==typeof t.status&&"string"==typeof t.statusText&&"boolean"==typeof t.internal&&"data"in t}(t)?t.status+" "+t.statusText:t instanceof Error?t.message:JSON.stringify(t),n=t instanceof Error?t.stack:null,i={padding:"0.5rem",backgroundColor:"rgba(200,200,200, 0.5)"};return V.createElement(V.Fragment,null,V.createElement("h2",null,"Unexpected Application Error!"),V.createElement("h3",{style:{fontStyle:"italic"}},e),n?V.createElement("pre",{style:i},n):null,null)}const rh=V.createElement(ih,null);class ah extends V.Component{constructor(t){super(t),this.state={location:t.location,revalidation:t.revalidation,error:t.error}}static getDerivedStateFromError(t){return{error:t}}static getDerivedStateFromProps(t,e){return e.location!==t.location||"idle"!==e.revalidation&&"idle"===t.revalidation?{error:t.error,location:t.location,revalidation:t.revalidation}:{error:void 0!==t.error?t.error:e.error,location:e.location,revalidation:t.revalidation||e.revalidation}}componentDidCatch(t,e){console.error("React Router caught the following error during render",t,e)}render(){return void 0!==this.state.error?V.createElement(qd.Provider,{value:this.props.routeContext},V.createElement(Xd.Provider,{value:this.state.error,children:this.props.component})):this.props.children}}function sh(t){let{routeContext:e,match:n,children:i}=t,r=V.useContext($d);return r&&r.static&&r.staticContext&&(n.route.errorElement||n.route.ErrorBoundary)&&(r.staticContext._deepestRenderedBoundaryId=n.route.id),V.createElement(qd.Provider,{value:e},i)}var oh=function(t){return t.UseBlocker="useBlocker",t.UseRevalidator="useRevalidator",t.UseNavigateStable="useNavigate",t}(oh||{}),lh=function(t){return t.UseBlocker="useBlocker",t.UseLoaderData="useLoaderData",t.UseActionData="useActionData",t.UseRouteError="useRouteError",t.UseNavigation="useNavigation",t.UseRouteLoaderData="useRouteLoaderData",t.UseMatches="useMatches",t.UseRevalidator="useRevalidator",t.UseNavigateStable="useNavigate",t.UseRouteId="useRouteId",t}(lh||{});function ch(t){let e=function(){let t=V.useContext(qd);return t||dd(!1),t}(),n=e.matches[e.matches.length-1];return n.route.id||dd(!1),n.route.id}const uh={};function dh(t){return function(t){let e=V.useContext(qd).outlet;return e?V.createElement(th.Provider,{value:t},e):e}(t.context)}function hh(t){dd(!1)}function fh(t){let{basename:e="/",children:n=null,location:i,navigationType:r=ad.Pop,navigator:a,static:s=!1,future:o}=t;Kd()&&dd(!1);let l=e.replace(/^\/*/,"/"),c=V.useMemo((()=>({basename:l,navigator:a,static:s,future:Hd({v7_relativeSplatPath:!1},o)})),[l,o,a,s]);"string"==typeof i&&(i=md(i));let{pathname:u="/",search:d="",hash:h="",state:f=null,key:p="default"}=i,g=V.useMemo((()=>{let t=Ld(u,l);return null==t?null:{location:{pathname:t,search:d,hash:h,state:f,key:p},navigationType:r}}),[l,u,d,h,f,p,r]);return null==g?null:V.createElement(Yd.Provider,{value:c},V.createElement(Qd.Provider,{children:n,value:g}))}function ph(t){let{children:e,location:n}=t;return nh(gh(e),n)}function gh(t,e){void 0===e&&(e=[]);let n=[];return V.Children.forEach(t,((t,i)=>{if(!V.isValidElement(t))return;let r=[...e,i];if(t.type===V.Fragment)return void n.push.apply(n,gh(t.props.children,r));t.type!==hh&&dd(!1),t.props.index&&t.props.children&&dd(!1);let a={id:t.props.id||r.join("-"),caseSensitive:t.props.caseSensitive,element:t.props.element,Component:t.props.Component,index:t.props.index,path:t.props.path,loader:t.props.loader,action:t.props.action,errorElement:t.props.errorElement,ErrorBoundary:t.props.ErrorBoundary,hasErrorBoundary:null!=t.props.ErrorBoundary||null!=t.props.errorElement,shouldRevalidate:t.props.shouldRevalidate,handle:t.props.handle,lazy:t.props.lazy};t.props.children&&(a.children=gh(t.props.children,r)),n.push(a)})),n}
/**
 * React Router DOM v6.30.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function mh(){return mh=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(t[i]=n[i])}return t},mh.apply(this,arguments)}function bh(t,e){if(null==t)return{};var n,i,r={},a=Object.keys(t);for(i=0;i<a.length;i++)n=a[i],e.indexOf(n)>=0||(r[n]=t[n]);return r}new Promise((()=>{}));const xh=["onClick","relative","reloadDocument","replace","state","target","to","preventScrollReset","viewTransition"],vh=["aria-current","caseSensitive","className","end","style","to","viewTransition","children"];try{window.__reactRouterVersion="6"}catch(Ay){}const yh=V.createContext({isTransitioning:!1}),_h=B.startTransition;function wh(t){let{basename:e,children:n,future:i,window:r}=t,a=V.useRef();null==a.current&&(a.current=ud({window:r,v5Compat:!0}));let s=a.current,[o,l]=V.useState({action:s.action,location:s.location}),{v7_startTransition:c}=i||{},u=V.useCallback((t=>{c&&_h?_h((()=>l(t))):l(t)}),[l,c]);return V.useLayoutEffect((()=>s.listen(u)),[s,u]),V.useEffect((()=>{return null==(t=i)||t.v7_startTransition,void 0!==(null==t?void 0:t.v7_relativeSplatPath)||e&&e.v7_relativeSplatPath,void(e&&(e.v7_fetcherPersist,e.v7_normalizeFormMethod,e.v7_partialHydration,e.v7_skipActionErrorRevalidation));var t,e}),[i]),V.createElement(fh,{basename:e,children:n,location:o.location,navigationType:o.action,navigator:s,future:i})}const kh="undefined"!=typeof window&&void 0!==window.document&&void 0!==window.document.createElement,Sh=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,Ch=V.forwardRef((function(t,e){let n,{onClick:i,relative:r,reloadDocument:a,replace:s,state:o,target:l,to:c,preventScrollReset:u,viewTransition:d}=t,h=bh(t,xh),{basename:f}=V.useContext(Yd),p=!1;if("string"==typeof c&&Sh.test(c)&&(n=c,kh))try{let t=new URL(window.location.href),e=c.startsWith("//")?new URL(t.protocol+c):new URL(c),n=Ld(e.pathname,f);e.origin===t.origin&&null!=n?c=n+e.search+e.hash:p=!0}catch(Ay){}let g=function(t,e){let{relative:n}=void 0===e?{}:e;Kd()||dd(!1);let{basename:i,navigator:r}=V.useContext(Yd),{hash:a,pathname:s,search:o}=eh(t,{relative:n}),l=s;return"/"!==i&&(l="/"===s?i:Ad([i,s])),r.createHref({pathname:l,search:o,hash:a})}(c,{relative:r}),m=function(t,e){let{target:n,replace:i,state:r,preventScrollReset:a,relative:s,viewTransition:o}=void 0===e?{}:e,l=Zd(),c=Gd(),u=eh(t,{relative:s});return V.useCallback((e=>{if(function(t,e){return!(0!==t.button||e&&"_self"!==e||function(t){return!!(t.metaKey||t.altKey||t.ctrlKey||t.shiftKey)}(t))}(e,n)){e.preventDefault();let n=void 0!==i?i:gd(c)===gd(u);l(t,{replace:n,state:r,preventScrollReset:a,relative:s,viewTransition:o})}}),[c,l,u,i,r,n,t,a,s,o])}(c,{replace:s,state:o,target:l,preventScrollReset:u,relative:r,viewTransition:d});return V.createElement("a",mh({},h,{href:n||g,onClick:p||a?i:function(t){i&&i(t),t.defaultPrevented||m(t)},ref:e,target:l}))})),Mh=V.forwardRef((function(t,e){let{"aria-current":n="page",caseSensitive:i=!1,className:r="",end:a=!1,style:s,to:o,viewTransition:l,children:c}=t,u=bh(t,vh),d=eh(o,{relative:u.relative}),h=Gd(),f=V.useContext(Ud),{navigator:p,basename:g}=V.useContext(Yd),m=null!=f&&function(t,e){void 0===e&&(e={});let n=V.useContext(yh);null==n&&dd(!1);let{basename:i}=function(){let t=V.useContext($d);return t||dd(!1),t}(Eh.useViewTransitionState),r=eh(t,{relative:e.relative});if(!n.isTransitioning)return!1;let a=Ld(n.currentLocation.pathname,i)||n.currentLocation.pathname,s=Ld(n.nextLocation.pathname,i)||n.nextLocation.pathname;return null!=Td(r.pathname,s)||null!=Td(r.pathname,a)}(d)&&!0===l,b=p.encodeLocation?p.encodeLocation(d).pathname:d.pathname,x=h.pathname,v=f&&f.navigation&&f.navigation.location?f.navigation.location.pathname:null;i||(x=x.toLowerCase(),v=v?v.toLowerCase():null,b=b.toLowerCase()),v&&g&&(v=Ld(v,g)||v);const y="/"!==b&&b.endsWith("/")?b.length-1:b.length;let _,w=x===b||!a&&x.startsWith(b)&&"/"===x.charAt(y),k=null!=v&&(v===b||!a&&v.startsWith(b)&&"/"===v.charAt(b.length)),S={isActive:w,isPending:k,isTransitioning:m},C=w?n:void 0;_="function"==typeof r?r(S):[r,w?"active":null,k?"pending":null,m?"transitioning":null].filter(Boolean).join(" ");let M="function"==typeof s?s(S):s;return V.createElement(Ch,mh({},u,{"aria-current":C,className:_,ref:e,style:M,to:o,viewTransition:l}),"function"==typeof c?c(S):c)}));var Eh,Ph,Nh,Dh;(Ph=Eh||(Eh={})).UseScrollRestoration="useScrollRestoration",Ph.UseSubmit="useSubmit",Ph.UseSubmitFetcher="useSubmitFetcher",Ph.UseFetcher="useFetcher",Ph.useViewTransitionState="useViewTransitionState",(Dh=Nh||(Nh={})).UseFetcher="useFetcher",Dh.UseFetchers="useFetchers",Dh.UseScrollRestoration="useScrollRestoration";const Th=()=>G.jsxs("div",{className:"w-64 bg-white border-r border-slate-200 flex flex-col",children:[G.jsx("div",{className:"p-4 border-b border-slate-200",children:G.jsx("h1",{className:"text-2xl font-semibold text-slate-900",children:"SQLite Visualizer"})}),G.jsx("nav",{className:"flex-1 p-4",children:G.jsxs("ul",{className:"space-y-1",children:[G.jsx("li",{children:G.jsx(Mh,{to:"/",className:({isActive:t})=>"block px-4 py-2 rounded text-sm "+(t?"bg-primary-light text-primary font-medium":"text-slate-700 hover:bg-slate-100"),end:!0,children:"Connections"})}),G.jsx("li",{children:G.jsx(Mh,{to:"/visualize",className:({isActive:t})=>"block px-4 py-2 rounded text-sm "+(t?"bg-primary-light text-primary font-medium":"text-slate-700 hover:bg-slate-100"),children:"Visualization Builder"})}),G.jsx("li",{children:G.jsx(Mh,{to:"/gallery",className:({isActive:t})=>"block px-4 py-2 rounded text-sm "+(t?"bg-primary-light text-primary font-medium":"text-slate-700 hover:bg-slate-100"),children:"Saved Visualizations"})}),G.jsx("li",{children:G.jsx(Mh,{to:"/templates",className:({isActive:t})=>"block px-4 py-2 rounded text-sm "+(t?"bg-primary-light text-primary font-medium":"text-slate-700 hover:bg-slate-100"),children:"Insight Templates"})})]})}),G.jsx("div",{className:"p-4 border-t border-slate-200",children:G.jsx("div",{className:"text-xs text-slate-500",children:"SQLite Visualizer v0.1.0"})})]}),Oh=()=>G.jsxs("div",{className:"h-screen flex overflow-hidden bg-slate-50",children:[G.jsx(Th,{}),G.jsx("div",{className:"flex-1 overflow-auto",children:G.jsx("main",{className:"p-6",children:G.jsx(dh,{})})})]}),Lh=({onAddConnection:t})=>{const[e,n]=V.useState(""),[i,r]=V.useState(""),[a,s]=V.useState(!1),[o,l]=V.useState(null);return G.jsxs("div",{className:"bg-white p-6 rounded-md border border-slate-200",children:[G.jsx("h2",{className:"text-xl font-medium text-slate-900 mb-4",children:"Add New Connection"}),G.jsxs("form",{onSubmit:async a=>{if(a.preventDefault(),e&&i)try{s(!0),l(null),await t({name:e,path:i}),n(""),r("")}catch(o){l(o instanceof Error?o.message:"Failed to add connection")}finally{s(!1)}else l("Name and path are required")},className:"space-y-4",children:[o&&G.jsx("div",{className:"p-3 bg-red-50 border border-red-200 rounded-md text-red-700 text-sm",children:o}),G.jsxs("div",{className:"space-y-1",children:[G.jsx("label",{className:"block text-sm font-medium text-slate-700",children:"Connection Name"}),G.jsx("input",{type:"text",value:e,onChange:t=>n(t.target.value),className:"w-full px-3 py-2 border border-slate-300 rounded-sm text-sm placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-primary focus:border-primary",placeholder:"My Database"})]}),G.jsxs("div",{className:"space-y-1",children:[G.jsx("label",{className:"block text-sm font-medium text-slate-700",children:"Database Path"}),G.jsx("input",{type:"text",value:i,onChange:t=>r(t.target.value),className:"w-full px-3 py-2 border border-slate-300 rounded-sm text-sm placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-primary focus:border-primary",placeholder:"/path/to/database.sqlite"}),G.jsx("p",{className:"text-xs text-slate-500",children:"Absolute path to the SQLite database file"})]}),G.jsx("button",{type:"submit",className:"w-full px-4 py-2 bg-primary text-white rounded text-sm font-medium hover:bg-primary-dark transition-colors disabled:opacity-50 disabled:cursor-not-allowed",disabled:a,children:a?"Connecting...":"Connect Database"})]})]})},Rh=({connections:t=[],loading:e=!1,error:n=null,onDeleteConnection:i})=>e?G.jsx("div",{className:"bg-white p-6 rounded-md border border-slate-200 text-center",children:G.jsx("p",{className:"text-slate-500",children:"Loading connections..."})}):n?G.jsx("div",{className:"p-4 bg-red-50 border border-red-200 rounded-md text-red-700",children:G.jsxs("p",{children:["Error: ",n]})}):e||0!==t.length?G.jsxs("div",{className:"bg-white rounded-md border border-slate-200",children:[G.jsx("div",{className:"p-4 border-b border-slate-200",children:G.jsx("h2",{className:"text-lg font-medium text-slate-900",children:"Your Connections"})}),G.jsx("ul",{className:"divide-y divide-slate-200",children:t.map((t=>G.jsx("li",{className:"p-4",children:G.jsxs("div",{className:"flex justify-between items-center",children:[G.jsxs("div",{children:[G.jsx("h3",{className:"text-base font-medium text-slate-900",children:t.name}),G.jsx("p",{className:"text-sm text-slate-500",children:t.path}),G.jsxs("div",{className:"mt-1 flex items-center space-x-2",children:[G.jsx("span",{className:"inline-block px-2 py-0.5 bg-green-50 text-green-700 rounded-full text-xs",children:t.is_valid?"Connected":"Disconnected"}),G.jsxs("span",{className:"text-xs text-slate-400",children:["Last accessed: ",t.last_accessed?new Date(t.last_accessed).toLocaleString():"Never"]})]})]}),G.jsxs("div",{className:"flex items-center space-x-2",children:[G.jsx(Ch,{to:`/connections/${t.id}/tables`,className:"px-3 py-1.5 bg-primary-light text-primary rounded text-xs hover:bg-blue-100",children:"Open"}),G.jsx("button",{className:"px-3 py-1.5 bg-red-50 text-red-700 rounded text-xs hover:bg-red-100",onClick:()=>i(t.id),children:"Delete"})]})]})},t.id)))})]}):G.jsx("div",{className:"bg-white p-6 rounded-md border border-slate-200 text-center",children:G.jsx("p",{className:"text-slate-500",children:"No connections yet. Add your first database connection."})});async function zh(t,e={}){const n=`/api${t}`;console.log(`Making API request to: ${n}`);const i={...e,headers:{"Content-Type":"application/json",...e.headers||{}}};try{console.log("Fetch request config:",{url:n,method:i.method||"GET"});const t=await fetch(n,i);let e;console.log(`Received response with status: ${t.status}`);const r=t.headers.get("content-type");if(r&&r.includes("application/json"))e=await t.json();else{const n=await t.text();console.warn("Received non-JSON response:",n),e={message:n}}if(!t.ok){const n=new Error(e.message||`API error: ${t.status}`);throw n.status=t.status,n}return e}catch(r){if(console.error("API request failed:",{url:n,method:i.method||"GET",error:{name:r.name,message:r.message,stack:r.stack}}),"TypeError"===r.name&&r.message.includes("Failed to fetch")){const t=`Cannot connect to server at ${n}. Please ensure:\n      1. The server is running on port 8765\n      2. There are no CORS issues\n      3. The endpoint exists`;throw console.error("Network error:",t),new Error(t)}if(r.status)throw new Error(`API Error ${r.status}: ${r.message||"Unknown error"}`);throw new Error(r.message||"Unknown API error")}}console.log("API Service Initialized:",{environment:"production",apiBaseUrl:""});const jh=()=>zh("/connections"),Ah=t=>zh("/connections",{method:"POST",body:JSON.stringify(t)}),Fh=t=>zh(`/connections/${t}`,{method:"DELETE"}),Ih=t=>zh(`/connections/${t}/tables`),Vh=(t,e)=>zh(`/connections/${t}/tables/${e}/schema`),Bh=(t,e,n={})=>{const i=new URLSearchParams;return Object.entries(n).forEach((([t,e])=>{null!=e&&i.append(t,String(e))})),zh(`/connections/${t}/tables/${e}/data?${i}`)},Wh=(t,e,n=10)=>zh(`/connections/${t}/tables/${e}/data/sample?limit=${n}`),Hh=()=>zh("/visualizations"),$h=t=>zh("/visualizations",{method:"POST",body:JSON.stringify(t)}),Uh=t=>zh(`/visualizations/${t}`,{method:"DELETE"}),Yh=()=>zh("/templates"),Qh=()=>{const[t,e]=V.useState([]),[n,i]=V.useState(!0),[r,a]=V.useState(null);V.useEffect((()=>{(async()=>{try{i(!0);const t=await jh();e(t),a(null)}catch(t){a(t instanceof Error?t.message:"Failed to load connections")}finally{i(!1)}})()}),[]);return G.jsxs("div",{className:"space-y-6",children:[G.jsx("div",{className:"flex justify-between items-center",children:G.jsx("h1",{className:"text-3xl font-semibold text-slate-900",children:"Database Connections"})}),G.jsxs("div",{className:"grid grid-cols-1 md:grid-cols-3 gap-6",children:[G.jsx("div",{className:"md:col-span-1",children:G.jsx(Lh,{onAddConnection:async n=>{try{const i=await Ah(n);return e([...t,i]),Promise.resolve()}catch(i){return Promise.reject(i)}}})}),G.jsx("div",{className:"md:col-span-2",children:G.jsx(Rh,{connections:t,loading:n,error:r,onDeleteConnection:async n=>{try{await Fh(n.toString()),e(t.filter((t=>t.id!==n)))}catch(i){a(i instanceof Error?i.message:"Failed to delete connection")}}})})]})]})},qh=({tables:t=[],selectedTable:e,onSelectTable:n,loading:i=!1})=>i?G.jsx("div",{className:"bg-white p-6 rounded-md border border-slate-200 text-center",children:G.jsx("p",{className:"text-slate-500",children:"Loading tables..."})}):0===t.length?G.jsx("div",{className:"bg-white p-6 rounded-md border border-slate-200 text-center",children:G.jsx("p",{className:"text-slate-500",children:"No tables found in this database."})}):G.jsxs("div",{className:"bg-white rounded-md border border-slate-200",children:[G.jsx("div",{className:"p-4 border-b border-slate-200",children:G.jsx("h2",{className:"text-lg font-medium text-slate-900",children:"Database Tables"})}),G.jsx("div",{className:"p-2",children:G.jsx("input",{type:"text",placeholder:"Search tables...",className:"w-full px-3 py-2 border border-slate-300 rounded-sm text-sm placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-primary focus:border-primary mb-2"})}),G.jsx("ul",{className:"max-h-[500px] overflow-y-auto",children:t.map((t=>G.jsx("li",{children:G.jsxs("button",{className:"w-full text-left px-4 py-2 text-sm "+(e===t.name?"bg-primary-light text-primary font-medium":"text-slate-700 hover:bg-slate-50"),onClick:()=>n(t.name),children:[t.name,void 0!==t.rowCount&&G.jsxs("span",{className:"text-xs text-slate-400 ml-2",children:["(",t.rowCount.toLocaleString()," rows)"]})]})},t.name)))})]}),Xh=({data:t=[],total:e=0,page:n=1,limit:i=100,onPageChange:r,onSortChange:a,onFilterChange:s,loading:o=!1,filters:l={}})=>{const c=Math.ceil(e/i),u=(n-1)*i+1,d=Math.min(n*i,e),h=t.length>0?Object.keys(t[0]):[];return o?G.jsx("div",{className:"bg-white p-6 rounded-md border border-slate-200 flex justify-center items-center h-[300px]",children:G.jsx("p",{className:"text-slate-500",children:"Loading data..."})}):0===t.length?G.jsx("div",{className:"bg-white p-6 rounded-md border border-slate-200 text-center",children:G.jsx("p",{className:"text-slate-500",children:"No data available"})}):G.jsxs("div",{className:"bg-white rounded-md border border-slate-200",children:[G.jsx("div",{className:"overflow-x-auto",children:G.jsxs("table",{className:"min-w-full divide-y divide-slate-200",children:[G.jsxs("thead",{className:"bg-slate-50",children:[G.jsx("tr",{children:h.map((t=>G.jsx("th",{className:"px-4 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider cursor-pointer hover:bg-slate-100",onClick:()=>a&&a(t,"asc"),children:t},t)))}),G.jsx("tr",{children:h.map((t=>G.jsx("th",{className:"px-4 py-2",children:G.jsx("input",{type:"text",className:"w-full px-2 py-1 text-xs border border-slate-300 rounded",placeholder:`Filter ${t}`,value:l[t]||"",onChange:e=>{s({...l,[t]:e.target.value})}})},`filter-${t}`)))})]}),G.jsx("tbody",{className:"bg-white divide-y divide-slate-200",children:t.map(((t,e)=>G.jsx("tr",{className:"hover:bg-slate-50",children:h.map((n=>G.jsx("td",{className:"px-4 py-3 text-sm text-slate-900",children:null!==t[n]&&void 0!==t[n]?String(t[n]):""},`${e}-${n}`)))},e)))})]})}),G.jsxs("div",{className:"px-4 py-3 flex items-center justify-between border-t border-slate-200",children:[G.jsxs("div",{className:"text-sm text-slate-500",children:["Showing ",G.jsx("span",{className:"font-medium",children:u})," to"," ",G.jsx("span",{className:"font-medium",children:d})," of"," ",G.jsx("span",{className:"font-medium",children:e})," results"]}),G.jsxs("div",{className:"flex space-x-2",children:[G.jsx("button",{className:"px-3 py-1 border border-slate-300 rounded-sm text-sm text-slate-700 hover:bg-slate-50 disabled:opacity-50 disabled:cursor-not-allowed",onClick:()=>r(n-1),disabled:1===n,children:"Previous"}),G.jsx("button",{className:"px-3 py-1 border border-slate-300 rounded-sm text-sm text-slate-700 hover:bg-slate-50 disabled:opacity-50 disabled:cursor-not-allowed",onClick:()=>r(n+1),disabled:n>=c,children:"Next"})]})]})]})},Kh=()=>{const{id:t}=function(){let{matches:t}=V.useContext(qd),e=t[t.length-1];return e?e.params:{}}(),e=Zd(),[n,i]=V.useState([]),[r,a]=V.useState(null),[s,o]=V.useState({data:[],total:0}),[l,c]=V.useState(!0),[u,d]=V.useState(null),[h,f]=V.useState(1),[p,g]=V.useState(100),[m,b]=V.useState(null),[x,v]=V.useState({});V.useEffect((()=>{(async()=>{if(t)try{c(!0);const e=await Ih(t);i(e),d(null)}catch(e){d(e instanceof Error?e.message:"Failed to load tables")}finally{c(!1)}})()}),[t]),V.useEffect((()=>{(async()=>{if(t&&r)try{c(!0);const e={page:h,limit:p};m&&(e.sort=m.column,e.direction=m.direction),Object.keys(x).length>0&&(e.filter=JSON.stringify(x));const n=await Bh(t,r,e);o(n),d(null)}catch(e){d(e instanceof Error?e.message:"Failed to load table data")}finally{c(!1)}})()}),[t,r,h,p,m,x]);return G.jsxs("div",{className:"space-y-6",children:[G.jsxs("div",{className:"flex justify-between items-center",children:[G.jsx("h1",{className:"text-3xl font-semibold text-slate-900",children:"Table Viewer"}),G.jsx("button",{className:"px-4 py-2 text-sm bg-slate-100 text-slate-700 rounded hover:bg-slate-200",onClick:()=>e("/"),children:"Back to Connections"})]}),G.jsxs("div",{className:"grid grid-cols-1 md:grid-cols-4 gap-6",children:[G.jsx("div",{className:"md:col-span-1",children:G.jsx(qh,{tables:n,selectedTable:r,onSelectTable:t=>{a(t),f(1)},loading:l})}),G.jsx("div",{className:"md:col-span-3",children:r?G.jsx(Xh,{data:s.data,total:s.total,page:h,limit:p,onPageChange:t=>{f(t)},onSortChange:(t,e)=>{b({column:t,direction:e})},onFilterChange:t=>{v(t),f(1)},loading:l,filters:x}):G.jsx("div",{className:"bg-white p-6 rounded-md border border-slate-200 text-center",children:G.jsx("p",{className:"text-slate-500",children:"Select a table to view its data"})})})]})]})},Gh=({selected:t,onChange:e})=>G.jsx("div",{className:"space-y-2",children:[{id:"bar",label:"Bar Chart",description:"Compare values across categories"},{id:"line",label:"Line Chart",description:"Show trends over time or categories"},{id:"pie",label:"Pie Chart",description:"Show composition as parts of a whole"},{id:"doughnut",label:"Doughnut Chart",description:"Similar to pie chart with center hole"},{id:"scatter",label:"Scatter Plot",description:"Show relationship between two variables"}].map((n=>G.jsx("div",{className:"p-3 border rounded cursor-pointer transition-colors "+(t===n.id?"border-primary bg-primary-light":"border-slate-200 hover:bg-slate-50"),onClick:()=>e(n.id),children:G.jsxs("div",{className:"flex items-center",children:[G.jsx("div",{className:"w-4 h-4 rounded-full border flex items-center justify-center mr-3 "+(t===n.id?"border-primary":"border-slate-400"),children:t===n.id&&G.jsx("div",{className:"w-2 h-2 rounded-full bg-primary"})}),G.jsxs("div",{children:[G.jsx("h3",{className:"text-sm font-medium "+(t===n.id?"text-primary":"text-slate-900"),children:n.label}),G.jsx("p",{className:"text-xs text-slate-500",children:n.description})]})]})},n.id)))}),Jh=({schema:t,chartType:e,mappings:n,onChange:i})=>{if(!t)return G.jsx("p",{className:"text-slate-500",children:"No schema available"});const r={x:"X-Axis",y:"Y-Axis",labels:"Labels",values:"Values",size:"Point Size",color:"Color"},a={bar:["x","y"],line:["x","y"],pie:["labels","values"],doughnut:["labels","values"],scatter:["x","y"]}[e]||[],s=(t,e)=>{const r={...n,[t]:e};i(r)};return G.jsxs("div",{className:"space-y-4",children:[a.map((e=>G.jsxs("div",{className:"space-y-1",children:[G.jsx("label",{className:"block text-sm font-medium text-slate-700",children:r[e]}),G.jsxs("select",{className:"w-full px-3 py-2 border border-slate-300 rounded-sm text-sm",value:n[e]||"",onChange:t=>s(e,t.target.value),children:[G.jsx("option",{value:"",children:"Select a field"}),t.columns&&t.columns.map((t=>G.jsx("option",{value:t.name,children:t.name},t.name)))]})]},e))),"scatter"===e&&G.jsxs("div",{className:"space-y-1",children:[G.jsx("label",{className:"block text-sm font-medium text-slate-700",children:"Point Size (optional)"}),G.jsxs("select",{className:"w-full px-3 py-2 border border-slate-300 rounded-sm text-sm",value:n.size||"",onChange:t=>s("size",t.target.value),children:[G.jsx("option",{value:"",children:"None"}),t.columns&&t.columns.map((t=>G.jsx("option",{value:t.name,children:t.name},t.name)))]})]})]})};
/*!
 * @kurkle/color v0.3.4
 * https://github.com/kurkle/color#readme
 * (c) 2024 Jukka Kurkela
 * Released under the MIT License
 */
function Zh(t){return t+.5|0}const tf=(t,e,n)=>Math.max(Math.min(t,n),e);function ef(t){return tf(Zh(2.55*t),0,255)}function nf(t){return tf(Zh(255*t),0,255)}function rf(t){return tf(Zh(t/2.55)/100,0,1)}function af(t){return tf(Zh(100*t),0,100)}const sf={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,A:10,B:11,C:12,D:13,E:14,F:15,a:10,b:11,c:12,d:13,e:14,f:15},of=[..."0123456789ABCDEF"],lf=t=>of[15&t],cf=t=>of[(240&t)>>4]+of[15&t],uf=t=>(240&t)>>4==(15&t);function df(t){var e=(t=>uf(t.r)&&uf(t.g)&&uf(t.b)&&uf(t.a))(t)?lf:cf;return t?"#"+e(t.r)+e(t.g)+e(t.b)+((t,e)=>t<255?e(t):"")(t.a,e):void 0}const hf=/^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;function ff(t,e,n){const i=e*Math.min(n,1-n),r=(e,r=(e+t/30)%12)=>n-i*Math.max(Math.min(r-3,9-r,1),-1);return[r(0),r(8),r(4)]}function pf(t,e,n){const i=(i,r=(i+t/60)%6)=>n-n*e*Math.max(Math.min(r,4-r,1),0);return[i(5),i(3),i(1)]}function gf(t,e,n){const i=ff(t,1,.5);let r;for(e+n>1&&(r=1/(e+n),e*=r,n*=r),r=0;r<3;r++)i[r]*=1-e-n,i[r]+=e;return i}function mf(t){const e=t.r/255,n=t.g/255,i=t.b/255,r=Math.max(e,n,i),a=Math.min(e,n,i),s=(r+a)/2;let o,l,c;return r!==a&&(c=r-a,l=s>.5?c/(2-r-a):c/(r+a),o=function(t,e,n,i,r){return t===r?(e-n)/i+(e<n?6:0):e===r?(n-t)/i+2:(t-e)/i+4}(e,n,i,c,r),o=60*o+.5),[0|o,l||0,s]}function bf(t,e,n,i){return(Array.isArray(e)?t(e[0],e[1],e[2]):t(e,n,i)).map(nf)}function xf(t,e,n){return bf(ff,t,e,n)}function vf(t){return(t%360+360)%360}function yf(t){const e=hf.exec(t);let n,i=255;if(!e)return;e[5]!==n&&(i=e[6]?ef(+e[5]):nf(+e[5]));const r=vf(+e[2]),a=+e[3]/100,s=+e[4]/100;return n="hwb"===e[1]?function(t,e,n){return bf(gf,t,e,n)}(r,a,s):"hsv"===e[1]?function(t,e,n){return bf(pf,t,e,n)}(r,a,s):xf(r,a,s),{r:n[0],g:n[1],b:n[2],a:i}}const _f={x:"dark",Z:"light",Y:"re",X:"blu",W:"gr",V:"medium",U:"slate",A:"ee",T:"ol",S:"or",B:"ra",C:"lateg",D:"ights",R:"in",Q:"turquois",E:"hi",P:"ro",O:"al",N:"le",M:"de",L:"yello",F:"en",K:"ch",G:"arks",H:"ea",I:"ightg",J:"wh"},wf={OiceXe:"f0f8ff",antiquewEte:"faebd7",aqua:"ffff",aquamarRe:"7fffd4",azuY:"f0ffff",beige:"f5f5dc",bisque:"ffe4c4",black:"0",blanKedOmond:"ffebcd",Xe:"ff",XeviTet:"8a2be2",bPwn:"a52a2a",burlywood:"deb887",caMtXe:"5f9ea0",KartYuse:"7fff00",KocTate:"d2691e",cSO:"ff7f50",cSnflowerXe:"6495ed",cSnsilk:"fff8dc",crimson:"dc143c",cyan:"ffff",xXe:"8b",xcyan:"8b8b",xgTMnPd:"b8860b",xWay:"a9a9a9",xgYF:"6400",xgYy:"a9a9a9",xkhaki:"bdb76b",xmagFta:"8b008b",xTivegYF:"556b2f",xSange:"ff8c00",xScEd:"9932cc",xYd:"8b0000",xsOmon:"e9967a",xsHgYF:"8fbc8f",xUXe:"483d8b",xUWay:"2f4f4f",xUgYy:"2f4f4f",xQe:"ced1",xviTet:"9400d3",dAppRk:"ff1493",dApskyXe:"bfff",dimWay:"696969",dimgYy:"696969",dodgerXe:"1e90ff",fiYbrick:"b22222",flSOwEte:"fffaf0",foYstWAn:"228b22",fuKsia:"ff00ff",gaRsbSo:"dcdcdc",ghostwEte:"f8f8ff",gTd:"ffd700",gTMnPd:"daa520",Way:"808080",gYF:"8000",gYFLw:"adff2f",gYy:"808080",honeyMw:"f0fff0",hotpRk:"ff69b4",RdianYd:"cd5c5c",Rdigo:"4b0082",ivSy:"fffff0",khaki:"f0e68c",lavFMr:"e6e6fa",lavFMrXsh:"fff0f5",lawngYF:"7cfc00",NmoncEffon:"fffacd",ZXe:"add8e6",ZcSO:"f08080",Zcyan:"e0ffff",ZgTMnPdLw:"fafad2",ZWay:"d3d3d3",ZgYF:"90ee90",ZgYy:"d3d3d3",ZpRk:"ffb6c1",ZsOmon:"ffa07a",ZsHgYF:"20b2aa",ZskyXe:"87cefa",ZUWay:"778899",ZUgYy:"778899",ZstAlXe:"b0c4de",ZLw:"ffffe0",lime:"ff00",limegYF:"32cd32",lRF:"faf0e6",magFta:"ff00ff",maPon:"800000",VaquamarRe:"66cdaa",VXe:"cd",VScEd:"ba55d3",VpurpN:"9370db",VsHgYF:"3cb371",VUXe:"7b68ee",VsprRggYF:"fa9a",VQe:"48d1cc",VviTetYd:"c71585",midnightXe:"191970",mRtcYam:"f5fffa",mistyPse:"ffe4e1",moccasR:"ffe4b5",navajowEte:"ffdead",navy:"80",Tdlace:"fdf5e6",Tive:"808000",TivedBb:"6b8e23",Sange:"ffa500",SangeYd:"ff4500",ScEd:"da70d6",pOegTMnPd:"eee8aa",pOegYF:"98fb98",pOeQe:"afeeee",pOeviTetYd:"db7093",papayawEp:"ffefd5",pHKpuff:"ffdab9",peru:"cd853f",pRk:"ffc0cb",plum:"dda0dd",powMrXe:"b0e0e6",purpN:"800080",YbeccapurpN:"663399",Yd:"ff0000",Psybrown:"bc8f8f",PyOXe:"4169e1",saddNbPwn:"8b4513",sOmon:"fa8072",sandybPwn:"f4a460",sHgYF:"2e8b57",sHshell:"fff5ee",siFna:"a0522d",silver:"c0c0c0",skyXe:"87ceeb",UXe:"6a5acd",UWay:"708090",UgYy:"708090",snow:"fffafa",sprRggYF:"ff7f",stAlXe:"4682b4",tan:"d2b48c",teO:"8080",tEstN:"d8bfd8",tomato:"ff6347",Qe:"40e0d0",viTet:"ee82ee",JHt:"f5deb3",wEte:"ffffff",wEtesmoke:"f5f5f5",Lw:"ffff00",LwgYF:"9acd32"};let kf;function Sf(t){kf||(kf=function(){const t={},e=Object.keys(wf),n=Object.keys(_f);let i,r,a,s,o;for(i=0;i<e.length;i++){for(s=o=e[i],r=0;r<n.length;r++)a=n[r],o=o.replace(a,_f[a]);a=parseInt(wf[s],16),t[o]=[a>>16&255,a>>8&255,255&a]}return t}(),kf.transparent=[0,0,0,0]);const e=kf[t.toLowerCase()];return e&&{r:e[0],g:e[1],b:e[2],a:4===e.length?e[3]:255}}const Cf=/^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;const Mf=t=>t<=.0031308?12.92*t:1.055*Math.pow(t,1/2.4)-.055,Ef=t=>t<=.04045?t/12.92:Math.pow((t+.055)/1.055,2.4);function Pf(t,e,n){if(t){let i=mf(t);i[e]=Math.max(0,Math.min(i[e]+i[e]*n,0===e?360:1)),i=xf(i),t.r=i[0],t.g=i[1],t.b=i[2]}}function Nf(t,e){return t?Object.assign(e||{},t):t}function Df(t){var e={r:0,g:0,b:0,a:255};return Array.isArray(t)?t.length>=3&&(e={r:t[0],g:t[1],b:t[2],a:255},t.length>3&&(e.a=nf(t[3]))):(e=Nf(t,{r:0,g:0,b:0,a:1})).a=nf(e.a),e}function Tf(t){return"r"===t.charAt(0)?function(t){const e=Cf.exec(t);let n,i,r,a=255;if(e){if(e[7]!==n){const t=+e[7];a=e[8]?ef(t):tf(255*t,0,255)}return n=+e[1],i=+e[3],r=+e[5],n=255&(e[2]?ef(n):tf(n,0,255)),i=255&(e[4]?ef(i):tf(i,0,255)),r=255&(e[6]?ef(r):tf(r,0,255)),{r:n,g:i,b:r,a:a}}}(t):yf(t)}class Of{constructor(t){if(t instanceof Of)return t;const e=typeof t;let n;var i,r,a;"object"===e?n=Df(t):"string"===e&&(a=(i=t).length,"#"===i[0]&&(4===a||5===a?r={r:255&17*sf[i[1]],g:255&17*sf[i[2]],b:255&17*sf[i[3]],a:5===a?17*sf[i[4]]:255}:7!==a&&9!==a||(r={r:sf[i[1]]<<4|sf[i[2]],g:sf[i[3]]<<4|sf[i[4]],b:sf[i[5]]<<4|sf[i[6]],a:9===a?sf[i[7]]<<4|sf[i[8]]:255})),n=r||Sf(t)||Tf(t)),this._rgb=n,this._valid=!!n}get valid(){return this._valid}get rgb(){var t=Nf(this._rgb);return t&&(t.a=rf(t.a)),t}set rgb(t){this._rgb=Df(t)}rgbString(){return this._valid?(t=this._rgb)&&(t.a<255?`rgba(${t.r}, ${t.g}, ${t.b}, ${rf(t.a)})`:`rgb(${t.r}, ${t.g}, ${t.b})`):void 0;var t}hexString(){return this._valid?df(this._rgb):void 0}hslString(){return this._valid?function(t){if(!t)return;const e=mf(t),n=e[0],i=af(e[1]),r=af(e[2]);return t.a<255?`hsla(${n}, ${i}%, ${r}%, ${rf(t.a)})`:`hsl(${n}, ${i}%, ${r}%)`}(this._rgb):void 0}mix(t,e){if(t){const n=this.rgb,i=t.rgb;let r;const a=e===r?.5:e,s=2*a-1,o=n.a-i.a,l=((s*o==-1?s:(s+o)/(1+s*o))+1)/2;r=1-l,n.r=255&l*n.r+r*i.r+.5,n.g=255&l*n.g+r*i.g+.5,n.b=255&l*n.b+r*i.b+.5,n.a=a*n.a+(1-a)*i.a,this.rgb=n}return this}interpolate(t,e){return t&&(this._rgb=function(t,e,n){const i=Ef(rf(t.r)),r=Ef(rf(t.g)),a=Ef(rf(t.b));return{r:nf(Mf(i+n*(Ef(rf(e.r))-i))),g:nf(Mf(r+n*(Ef(rf(e.g))-r))),b:nf(Mf(a+n*(Ef(rf(e.b))-a))),a:t.a+n*(e.a-t.a)}}(this._rgb,t._rgb,e)),this}clone(){return new Of(this.rgb)}alpha(t){return this._rgb.a=nf(t),this}clearer(t){return this._rgb.a*=1-t,this}greyscale(){const t=this._rgb,e=Zh(.3*t.r+.59*t.g+.11*t.b);return t.r=t.g=t.b=e,this}opaquer(t){return this._rgb.a*=1+t,this}negate(){const t=this._rgb;return t.r=255-t.r,t.g=255-t.g,t.b=255-t.b,this}lighten(t){return Pf(this._rgb,2,t),this}darken(t){return Pf(this._rgb,2,-t),this}saturate(t){return Pf(this._rgb,1,t),this}desaturate(t){return Pf(this._rgb,1,-t),this}rotate(t){return function(t,e){var n=mf(t);n[0]=vf(n[0]+e),n=xf(n),t.r=n[0],t.g=n[1],t.b=n[2]}(this._rgb,t),this}}
/*!
 * Chart.js v4.4.8
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */function Lf(){}const Rf=(()=>{let t=0;return()=>t++})();function zf(t){return null==t}function jf(t){if(Array.isArray&&Array.isArray(t))return!0;const e=Object.prototype.toString.call(t);return"[object"===e.slice(0,7)&&"Array]"===e.slice(-6)}function Af(t){return null!==t&&"[object Object]"===Object.prototype.toString.call(t)}function Ff(t){return("number"==typeof t||t instanceof Number)&&isFinite(+t)}function If(t,e){return Ff(t)?t:e}function Vf(t,e){return void 0===t?e:t}const Bf=(t,e)=>"string"==typeof t&&t.endsWith("%")?parseFloat(t)/100*e:+t;function Wf(t,e,n){if(t&&"function"==typeof t.call)return t.apply(n,e)}function Hf(t,e,n,i){let r,a,s;if(jf(t))if(a=t.length,i)for(r=a-1;r>=0;r--)e.call(n,t[r],r);else for(r=0;r<a;r++)e.call(n,t[r],r);else if(Af(t))for(s=Object.keys(t),a=s.length,r=0;r<a;r++)e.call(n,t[s[r]],s[r])}function $f(t,e){let n,i,r,a;if(!t||!e||t.length!==e.length)return!1;for(n=0,i=t.length;n<i;++n)if(r=t[n],a=e[n],r.datasetIndex!==a.datasetIndex||r.index!==a.index)return!1;return!0}function Uf(t){if(jf(t))return t.map(Uf);if(Af(t)){const e=Object.create(null),n=Object.keys(t),i=n.length;let r=0;for(;r<i;++r)e[n[r]]=Uf(t[n[r]]);return e}return t}function Yf(t){return-1===["__proto__","prototype","constructor"].indexOf(t)}function Qf(t,e,n,i){if(!Yf(t))return;const r=e[t],a=n[t];Af(r)&&Af(a)?qf(r,a,i):e[t]=Uf(a)}function qf(t,e,n){const i=jf(e)?e:[e],r=i.length;if(!Af(t))return t;const a=(n=n||{}).merger||Qf;let s;for(let o=0;o<r;++o){if(s=i[o],!Af(s))continue;const e=Object.keys(s);for(let i=0,r=e.length;i<r;++i)a(e[i],t,s,n)}return t}function Xf(t,e){return qf(t,e,{merger:Kf})}function Kf(t,e,n){if(!Yf(t))return;const i=e[t],r=n[t];Af(i)&&Af(r)?Xf(i,r):Object.prototype.hasOwnProperty.call(e,t)||(e[t]=Uf(r))}const Gf={"":t=>t,x:t=>t.x,y:t=>t.y};function Jf(t,e){const n=Gf[e]||(Gf[e]=function(t){const e=function(t){const e=t.split("."),n=[];let i="";for(const r of e)i+=r,i.endsWith("\\")?i=i.slice(0,-1)+".":(n.push(i),i="");return n}(t);return t=>{for(const n of e){if(""===n)break;t=t&&t[n]}return t}}(e));return n(t)}function Zf(t){return t.charAt(0).toUpperCase()+t.slice(1)}const tp=t=>void 0!==t,ep=t=>"function"==typeof t,np=(t,e)=>{if(t.size!==e.size)return!1;for(const n of t)if(!e.has(n))return!1;return!0};const ip=Math.PI,rp=2*ip,ap=rp+ip,sp=Number.POSITIVE_INFINITY,op=ip/180,lp=ip/2,cp=ip/4,up=2*ip/3,dp=Math.log10,hp=Math.sign;function fp(t,e,n){return Math.abs(t-e)<n}function pp(t){const e=Math.round(t);t=fp(t,e,t/1e3)?e:t;const n=Math.pow(10,Math.floor(dp(t))),i=t/n;return(i<=1?1:i<=2?2:i<=5?5:10)*n}function gp(t){return!function(t){return"symbol"==typeof t||"object"==typeof t&&null!==t&&!(Symbol.toPrimitive in t||"toString"in t||"valueOf"in t)}(t)&&!isNaN(parseFloat(t))&&isFinite(t)}function mp(t,e,n){let i,r,a;for(i=0,r=t.length;i<r;i++)a=t[i][n],isNaN(a)||(e.min=Math.min(e.min,a),e.max=Math.max(e.max,a))}function bp(t){return t*(ip/180)}function xp(t){return t*(180/ip)}function vp(t){if(!Ff(t))return;let e=1,n=0;for(;Math.round(t*e)/e!==t;)e*=10,n++;return n}function yp(t,e){const n=e.x-t.x,i=e.y-t.y,r=Math.sqrt(n*n+i*i);let a=Math.atan2(i,n);return a<-.5*ip&&(a+=rp),{angle:a,distance:r}}function _p(t,e){return Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2))}function wp(t,e){return(t-e+ap)%rp-ip}function kp(t){return(t%rp+rp)%rp}function Sp(t,e,n,i){const r=kp(t),a=kp(e),s=kp(n),o=kp(a-r),l=kp(s-r),c=kp(r-a),u=kp(r-s);return r===a||r===s||i&&a===s||o>l&&c<u}function Cp(t,e,n){return Math.max(e,Math.min(n,t))}function Mp(t,e,n,i=1e-6){return t>=Math.min(e,n)-i&&t<=Math.max(e,n)+i}function Ep(t,e,n){n=n||(n=>t[n]<e);let i,r=t.length-1,a=0;for(;r-a>1;)i=a+r>>1,n(i)?a=i:r=i;return{lo:a,hi:r}}const Pp=(t,e,n,i)=>Ep(t,n,i?i=>{const r=t[i][e];return r<n||r===n&&t[i+1][e]===n}:i=>t[i][e]<n),Np=(t,e,n)=>Ep(t,n,(i=>t[i][e]>=n));const Dp=["push","pop","shift","splice","unshift"];function Tp(t,e){const n=t._chartjs;if(!n)return;const i=n.listeners,r=i.indexOf(e);-1!==r&&i.splice(r,1),i.length>0||(Dp.forEach((e=>{delete t[e]})),delete t._chartjs)}function Op(t){const e=new Set(t);return e.size===t.length?t:Array.from(e)}const Lp="undefined"==typeof window?function(t){return t()}:window.requestAnimationFrame;function Rp(t,e){let n=[],i=!1;return function(...r){n=r,i||(i=!0,Lp.call(window,(()=>{i=!1,t.apply(e,n)})))}}const zp=t=>"start"===t?"left":"end"===t?"right":"center",jp=(t,e,n)=>"start"===t?e:"end"===t?n:(e+n)/2;function Ap(t,e,n){const i=e.length;let r=0,a=i;if(t._sorted){const{iScale:s,vScale:o,_parsed:l}=t,c=t.dataset&&t.dataset.options?t.dataset.options.spanGaps:null,u=s.axis,{min:d,max:h,minDefined:f,maxDefined:p}=s.getUserBounds();if(f){if(r=Math.min(Pp(l,u,d).lo,n?i:Pp(e,u,s.getPixelForValue(d)).lo),c){const t=l.slice(0,r+1).reverse().findIndex((t=>!zf(t[o.axis])));r-=Math.max(0,t)}r=Cp(r,0,i-1)}if(p){let t=Math.max(Pp(l,s.axis,h,!0).hi+1,n?0:Pp(e,u,s.getPixelForValue(h),!0).hi+1);if(c){const e=l.slice(t-1).findIndex((t=>!zf(t[o.axis])));t+=Math.max(0,e)}a=Cp(t,r,i)-r}else a=i-r}return{start:r,count:a}}function Fp(t){const{xScale:e,yScale:n,_scaleRanges:i}=t,r={xmin:e.min,xmax:e.max,ymin:n.min,ymax:n.max};if(!i)return t._scaleRanges=r,!0;const a=i.xmin!==e.min||i.xmax!==e.max||i.ymin!==n.min||i.ymax!==n.max;return Object.assign(i,r),a}const Ip=t=>0===t||1===t,Vp=(t,e,n)=>-Math.pow(2,10*(t-=1))*Math.sin((t-e)*rp/n),Bp=(t,e,n)=>Math.pow(2,-10*t)*Math.sin((t-e)*rp/n)+1,Wp={linear:t=>t,easeInQuad:t=>t*t,easeOutQuad:t=>-t*(t-2),easeInOutQuad:t=>(t/=.5)<1?.5*t*t:-.5*(--t*(t-2)-1),easeInCubic:t=>t*t*t,easeOutCubic:t=>(t-=1)*t*t+1,easeInOutCubic:t=>(t/=.5)<1?.5*t*t*t:.5*((t-=2)*t*t+2),easeInQuart:t=>t*t*t*t,easeOutQuart:t=>-((t-=1)*t*t*t-1),easeInOutQuart:t=>(t/=.5)<1?.5*t*t*t*t:-.5*((t-=2)*t*t*t-2),easeInQuint:t=>t*t*t*t*t,easeOutQuint:t=>(t-=1)*t*t*t*t+1,easeInOutQuint:t=>(t/=.5)<1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2),easeInSine:t=>1-Math.cos(t*lp),easeOutSine:t=>Math.sin(t*lp),easeInOutSine:t=>-.5*(Math.cos(ip*t)-1),easeInExpo:t=>0===t?0:Math.pow(2,10*(t-1)),easeOutExpo:t=>1===t?1:1-Math.pow(2,-10*t),easeInOutExpo:t=>Ip(t)?t:t<.5?.5*Math.pow(2,10*(2*t-1)):.5*(2-Math.pow(2,-10*(2*t-1))),easeInCirc:t=>t>=1?t:-(Math.sqrt(1-t*t)-1),easeOutCirc:t=>Math.sqrt(1-(t-=1)*t),easeInOutCirc:t=>(t/=.5)<1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1),easeInElastic:t=>Ip(t)?t:Vp(t,.075,.3),easeOutElastic:t=>Ip(t)?t:Bp(t,.075,.3),easeInOutElastic(t){const e=.1125;return Ip(t)?t:t<.5?.5*Vp(2*t,e,.45):.5+.5*Bp(2*t-1,e,.45)},easeInBack(t){const e=1.70158;return t*t*((e+1)*t-e)},easeOutBack(t){const e=1.70158;return(t-=1)*t*((e+1)*t+e)+1},easeInOutBack(t){let e=1.70158;return(t/=.5)<1?t*t*((1+(e*=1.525))*t-e)*.5:.5*((t-=2)*t*((1+(e*=1.525))*t+e)+2)},easeInBounce:t=>1-Wp.easeOutBounce(1-t),easeOutBounce(t){const e=7.5625,n=2.75;return t<1/n?e*t*t:t<2/n?e*(t-=1.5/n)*t+.75:t<2.5/n?e*(t-=2.25/n)*t+.9375:e*(t-=2.625/n)*t+.984375},easeInOutBounce:t=>t<.5?.5*Wp.easeInBounce(2*t):.5*Wp.easeOutBounce(2*t-1)+.5};function Hp(t){if(t&&"object"==typeof t){const e=t.toString();return"[object CanvasPattern]"===e||"[object CanvasGradient]"===e}return!1}function $p(t){return Hp(t)?t:new Of(t)}function Up(t){return Hp(t)?t:new Of(t).saturate(.5).darken(.1).hexString()}const Yp=["x","y","borderWidth","radius","tension"],Qp=["color","borderColor","backgroundColor"];const qp=new Map;function Xp(t,e,n){return function(t,e){e=e||{};const n=t+JSON.stringify(e);let i=qp.get(n);return i||(i=new Intl.NumberFormat(t,e),qp.set(n,i)),i}(e,n).format(t)}const Kp={values:t=>jf(t)?t:""+t,numeric(t,e,n){if(0===t)return"0";const i=this.chart.options.locale;let r,a=t;if(n.length>1){const e=Math.max(Math.abs(n[0].value),Math.abs(n[n.length-1].value));(e<1e-4||e>1e15)&&(r="scientific"),a=function(t,e){let n=e.length>3?e[2].value-e[1].value:e[1].value-e[0].value;Math.abs(n)>=1&&t!==Math.floor(t)&&(n=t-Math.floor(t));return n}(t,n)}const s=dp(Math.abs(a)),o=isNaN(s)?1:Math.max(Math.min(-1*Math.floor(s),20),0),l={notation:r,minimumFractionDigits:o,maximumFractionDigits:o};return Object.assign(l,this.options.ticks.format),Xp(t,i,l)},logarithmic(t,e,n){if(0===t)return"0";const i=n[e].significand||t/Math.pow(10,Math.floor(dp(t)));return[1,2,3,5,10,15].includes(i)||e>.8*n.length?Kp.numeric.call(this,t,e,n):""}};var Gp={formatters:Kp};const Jp=Object.create(null),Zp=Object.create(null);function tg(t,e){if(!e)return t;const n=e.split(".");for(let i=0,r=n.length;i<r;++i){const e=n[i];t=t[e]||(t[e]=Object.create(null))}return t}function eg(t,e,n){return"string"==typeof e?qf(tg(t,e),n):qf(tg(t,""),e)}class ng{constructor(t,e){this.animation=void 0,this.backgroundColor="rgba(0,0,0,0.1)",this.borderColor="rgba(0,0,0,0.1)",this.color="#666",this.datasets={},this.devicePixelRatio=t=>t.chart.platform.getDevicePixelRatio(),this.elements={},this.events=["mousemove","mouseout","click","touchstart","touchmove"],this.font={family:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",size:12,style:"normal",lineHeight:1.2,weight:null},this.hover={},this.hoverBackgroundColor=(t,e)=>Up(e.backgroundColor),this.hoverBorderColor=(t,e)=>Up(e.borderColor),this.hoverColor=(t,e)=>Up(e.color),this.indexAxis="x",this.interaction={mode:"nearest",intersect:!0,includeInvisible:!1},this.maintainAspectRatio=!0,this.onHover=null,this.onClick=null,this.parsing=!0,this.plugins={},this.responsive=!0,this.scale=void 0,this.scales={},this.showLine=!0,this.drawActiveElementsOnTop=!0,this.describe(t),this.apply(e)}set(t,e){return eg(this,t,e)}get(t){return tg(this,t)}describe(t,e){return eg(Zp,t,e)}override(t,e){return eg(Jp,t,e)}route(t,e,n,i){const r=tg(this,t),a=tg(this,n),s="_"+e;Object.defineProperties(r,{[s]:{value:r[e],writable:!0},[e]:{enumerable:!0,get(){const t=this[s],e=a[i];return Af(t)?Object.assign({},e,t):Vf(t,e)},set(t){this[s]=t}}})}apply(t){t.forEach((t=>t(this)))}}var ig=new ng({_scriptable:t=>!t.startsWith("on"),_indexable:t=>"events"!==t,hover:{_fallback:"interaction"},interaction:{_scriptable:!1,_indexable:!1}},[function(t){t.set("animation",{delay:void 0,duration:1e3,easing:"easeOutQuart",fn:void 0,from:void 0,loop:void 0,to:void 0,type:void 0}),t.describe("animation",{_fallback:!1,_indexable:!1,_scriptable:t=>"onProgress"!==t&&"onComplete"!==t&&"fn"!==t}),t.set("animations",{colors:{type:"color",properties:Qp},numbers:{type:"number",properties:Yp}}),t.describe("animations",{_fallback:"animation"}),t.set("transitions",{active:{animation:{duration:400}},resize:{animation:{duration:0}},show:{animations:{colors:{from:"transparent"},visible:{type:"boolean",duration:0}}},hide:{animations:{colors:{to:"transparent"},visible:{type:"boolean",easing:"linear",fn:t=>0|t}}}})},function(t){t.set("layout",{autoPadding:!0,padding:{top:0,right:0,bottom:0,left:0}})},function(t){t.set("scale",{display:!0,offset:!1,reverse:!1,beginAtZero:!1,bounds:"ticks",clip:!0,grace:0,grid:{display:!0,lineWidth:1,drawOnChartArea:!0,drawTicks:!0,tickLength:8,tickWidth:(t,e)=>e.lineWidth,tickColor:(t,e)=>e.color,offset:!1},border:{display:!0,dash:[],dashOffset:0,width:1},title:{display:!1,text:"",padding:{top:4,bottom:4}},ticks:{minRotation:0,maxRotation:50,mirror:!1,textStrokeWidth:0,textStrokeColor:"",padding:3,display:!0,autoSkip:!0,autoSkipPadding:3,labelOffset:0,callback:Gp.formatters.values,minor:{},major:{},align:"center",crossAlign:"near",showLabelBackdrop:!1,backdropColor:"rgba(255, 255, 255, 0.75)",backdropPadding:2}}),t.route("scale.ticks","color","","color"),t.route("scale.grid","color","","borderColor"),t.route("scale.border","color","","borderColor"),t.route("scale.title","color","","color"),t.describe("scale",{_fallback:!1,_scriptable:t=>!t.startsWith("before")&&!t.startsWith("after")&&"callback"!==t&&"parser"!==t,_indexable:t=>"borderDash"!==t&&"tickBorderDash"!==t&&"dash"!==t}),t.describe("scales",{_fallback:"scale"}),t.describe("scale.ticks",{_scriptable:t=>"backdropPadding"!==t&&"callback"!==t,_indexable:t=>"backdropPadding"!==t})}]);function rg(t,e,n,i,r){let a=e[r];return a||(a=e[r]=t.measureText(r).width,n.push(r)),a>i&&(i=a),i}function ag(t,e,n,i){let r=(i=i||{}).data=i.data||{},a=i.garbageCollect=i.garbageCollect||[];i.font!==e&&(r=i.data={},a=i.garbageCollect=[],i.font=e),t.save(),t.font=e;let s=0;const o=n.length;let l,c,u,d,h;for(l=0;l<o;l++)if(d=n[l],null==d||jf(d)){if(jf(d))for(c=0,u=d.length;c<u;c++)h=d[c],null==h||jf(h)||(s=rg(t,r,a,s,h))}else s=rg(t,r,a,s,d);t.restore();const f=a.length/2;if(f>n.length){for(l=0;l<f;l++)delete r[a[l]];a.splice(0,f)}return s}function sg(t,e,n){const i=t.currentDevicePixelRatio,r=0!==n?Math.max(n/2,.5):0;return Math.round((e-r)*i)/i+r}function og(t,e){(e||t)&&((e=e||t.getContext("2d")).save(),e.resetTransform(),e.clearRect(0,0,t.width,t.height),e.restore())}function lg(t,e,n,i){cg(t,e,n,i,null)}function cg(t,e,n,i,r){let a,s,o,l,c,u,d,h;const f=e.pointStyle,p=e.rotation,g=e.radius;let m=(p||0)*op;if(f&&"object"==typeof f&&(a=f.toString(),"[object HTMLImageElement]"===a||"[object HTMLCanvasElement]"===a))return t.save(),t.translate(n,i),t.rotate(m),t.drawImage(f,-f.width/2,-f.height/2,f.width,f.height),void t.restore();if(!(isNaN(g)||g<=0)){switch(t.beginPath(),f){default:r?t.ellipse(n,i,r/2,g,0,0,rp):t.arc(n,i,g,0,rp),t.closePath();break;case"triangle":u=r?r/2:g,t.moveTo(n+Math.sin(m)*u,i-Math.cos(m)*g),m+=up,t.lineTo(n+Math.sin(m)*u,i-Math.cos(m)*g),m+=up,t.lineTo(n+Math.sin(m)*u,i-Math.cos(m)*g),t.closePath();break;case"rectRounded":c=.516*g,l=g-c,s=Math.cos(m+cp)*l,d=Math.cos(m+cp)*(r?r/2-c:l),o=Math.sin(m+cp)*l,h=Math.sin(m+cp)*(r?r/2-c:l),t.arc(n-d,i-o,c,m-ip,m-lp),t.arc(n+h,i-s,c,m-lp,m),t.arc(n+d,i+o,c,m,m+lp),t.arc(n-h,i+s,c,m+lp,m+ip),t.closePath();break;case"rect":if(!p){l=Math.SQRT1_2*g,u=r?r/2:l,t.rect(n-u,i-l,2*u,2*l);break}m+=cp;case"rectRot":d=Math.cos(m)*(r?r/2:g),s=Math.cos(m)*g,o=Math.sin(m)*g,h=Math.sin(m)*(r?r/2:g),t.moveTo(n-d,i-o),t.lineTo(n+h,i-s),t.lineTo(n+d,i+o),t.lineTo(n-h,i+s),t.closePath();break;case"crossRot":m+=cp;case"cross":d=Math.cos(m)*(r?r/2:g),s=Math.cos(m)*g,o=Math.sin(m)*g,h=Math.sin(m)*(r?r/2:g),t.moveTo(n-d,i-o),t.lineTo(n+d,i+o),t.moveTo(n+h,i-s),t.lineTo(n-h,i+s);break;case"star":d=Math.cos(m)*(r?r/2:g),s=Math.cos(m)*g,o=Math.sin(m)*g,h=Math.sin(m)*(r?r/2:g),t.moveTo(n-d,i-o),t.lineTo(n+d,i+o),t.moveTo(n+h,i-s),t.lineTo(n-h,i+s),m+=cp,d=Math.cos(m)*(r?r/2:g),s=Math.cos(m)*g,o=Math.sin(m)*g,h=Math.sin(m)*(r?r/2:g),t.moveTo(n-d,i-o),t.lineTo(n+d,i+o),t.moveTo(n+h,i-s),t.lineTo(n-h,i+s);break;case"line":s=r?r/2:Math.cos(m)*g,o=Math.sin(m)*g,t.moveTo(n-s,i-o),t.lineTo(n+s,i+o);break;case"dash":t.moveTo(n,i),t.lineTo(n+Math.cos(m)*(r?r/2:g),i+Math.sin(m)*g);break;case!1:t.closePath()}t.fill(),e.borderWidth>0&&t.stroke()}}function ug(t,e,n){return n=n||.5,!e||t&&t.x>e.left-n&&t.x<e.right+n&&t.y>e.top-n&&t.y<e.bottom+n}function dg(t,e){t.save(),t.beginPath(),t.rect(e.left,e.top,e.right-e.left,e.bottom-e.top),t.clip()}function hg(t){t.restore()}function fg(t,e,n,i,r){if(!e)return t.lineTo(n.x,n.y);if("middle"===r){const i=(e.x+n.x)/2;t.lineTo(i,e.y),t.lineTo(i,n.y)}else"after"===r!=!!i?t.lineTo(e.x,n.y):t.lineTo(n.x,e.y);t.lineTo(n.x,n.y)}function pg(t,e,n,i){if(!e)return t.lineTo(n.x,n.y);t.bezierCurveTo(i?e.cp1x:e.cp2x,i?e.cp1y:e.cp2y,i?n.cp2x:n.cp1x,i?n.cp2y:n.cp1y,n.x,n.y)}function gg(t,e,n,i,r){if(r.strikethrough||r.underline){const a=t.measureText(i),s=e-a.actualBoundingBoxLeft,o=e+a.actualBoundingBoxRight,l=n-a.actualBoundingBoxAscent,c=n+a.actualBoundingBoxDescent,u=r.strikethrough?(l+c)/2:c;t.strokeStyle=t.fillStyle,t.beginPath(),t.lineWidth=r.decorationWidth||2,t.moveTo(s,u),t.lineTo(o,u),t.stroke()}}function mg(t,e){const n=t.fillStyle;t.fillStyle=e.color,t.fillRect(e.left,e.top,e.width,e.height),t.fillStyle=n}function bg(t,e,n,i,r,a={}){const s=jf(e)?e:[e],o=a.strokeWidth>0&&""!==a.strokeColor;let l,c;for(t.save(),t.font=r.string,function(t,e){e.translation&&t.translate(e.translation[0],e.translation[1]),zf(e.rotation)||t.rotate(e.rotation),e.color&&(t.fillStyle=e.color),e.textAlign&&(t.textAlign=e.textAlign),e.textBaseline&&(t.textBaseline=e.textBaseline)}(t,a),l=0;l<s.length;++l)c=s[l],a.backdrop&&mg(t,a.backdrop),o&&(a.strokeColor&&(t.strokeStyle=a.strokeColor),zf(a.strokeWidth)||(t.lineWidth=a.strokeWidth),t.strokeText(c,n,i,a.maxWidth)),t.fillText(c,n,i,a.maxWidth),gg(t,n,i,c,a),i+=Number(r.lineHeight);t.restore()}function xg(t,e){const{x:n,y:i,w:r,h:a,radius:s}=e;t.arc(n+s.topLeft,i+s.topLeft,s.topLeft,1.5*ip,ip,!0),t.lineTo(n,i+a-s.bottomLeft),t.arc(n+s.bottomLeft,i+a-s.bottomLeft,s.bottomLeft,ip,lp,!0),t.lineTo(n+r-s.bottomRight,i+a),t.arc(n+r-s.bottomRight,i+a-s.bottomRight,s.bottomRight,lp,0,!0),t.lineTo(n+r,i+s.topRight),t.arc(n+r-s.topRight,i+s.topRight,s.topRight,0,-lp,!0),t.lineTo(n+s.topLeft,i)}const vg=/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/,yg=/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;function _g(t,e){const n=(""+t).match(vg);if(!n||"normal"===n[1])return 1.2*e;switch(t=+n[2],n[3]){case"px":return t;case"%":t/=100}return e*t}function wg(t,e){const n={},i=Af(e),r=i?Object.keys(e):e,a=Af(t)?i?n=>Vf(t[n],t[e[n]]):e=>t[e]:()=>t;for(const s of r)n[s]=+a(s)||0;return n}function kg(t){return wg(t,{top:"y",right:"x",bottom:"y",left:"x"})}function Sg(t){return wg(t,["topLeft","topRight","bottomLeft","bottomRight"])}function Cg(t){const e=kg(t);return e.width=e.left+e.right,e.height=e.top+e.bottom,e}function Mg(t,e){t=t||{},e=e||ig.font;let n=Vf(t.size,e.size);"string"==typeof n&&(n=parseInt(n,10));let i=Vf(t.style,e.style);i&&!(""+i).match(yg)&&(console.warn('Invalid font style specified: "'+i+'"'),i=void 0);const r={family:Vf(t.family,e.family),lineHeight:_g(Vf(t.lineHeight,e.lineHeight),n),size:n,style:i,weight:Vf(t.weight,e.weight),string:""};return r.string=function(t){return!t||zf(t.size)||zf(t.family)?null:(t.style?t.style+" ":"")+(t.weight?t.weight+" ":"")+t.size+"px "+t.family}(r),r}function Eg(t,e,n,i){let r,a,s,o=!0;for(r=0,a=t.length;r<a;++r)if(s=t[r],void 0!==s&&(void 0!==e&&"function"==typeof s&&(s=s(e),o=!1),void 0!==n&&jf(s)&&(s=s[n%s.length],o=!1),void 0!==s))return i&&!o&&(i.cacheable=!1),s}function Pg(t,e){return Object.assign(Object.create(t),e)}function Ng(t,e=[""],n,i,r=()=>t[0]){const a=n||t;void 0===i&&(i=Vg("_fallback",t));const s={[Symbol.toStringTag]:"Object",_cacheable:!0,_scopes:t,_rootScopes:a,_fallback:i,_getTarget:r,override:n=>Ng([n,...t],e,a,i)};return new Proxy(s,{deleteProperty:(e,n)=>(delete e[n],delete e._keys,delete t[0][n],!0),get:(n,i)=>Rg(n,i,(()=>function(t,e,n,i){let r;for(const a of e)if(r=Vg(Og(a,t),n),void 0!==r)return Lg(t,r)?Fg(n,i,t,r):r}(i,e,t,n))),getOwnPropertyDescriptor:(t,e)=>Reflect.getOwnPropertyDescriptor(t._scopes[0],e),getPrototypeOf:()=>Reflect.getPrototypeOf(t[0]),has:(t,e)=>Bg(t).includes(e),ownKeys:t=>Bg(t),set(t,e,n){const i=t._storage||(t._storage=r());return t[e]=i[e]=n,delete t._keys,!0}})}function Dg(t,e,n,i){const r={_cacheable:!1,_proxy:t,_context:e,_subProxy:n,_stack:new Set,_descriptors:Tg(t,i),setContext:e=>Dg(t,e,n,i),override:r=>Dg(t.override(r),e,n,i)};return new Proxy(r,{deleteProperty:(e,n)=>(delete e[n],delete t[n],!0),get:(t,e,n)=>Rg(t,e,(()=>function(t,e,n){const{_proxy:i,_context:r,_subProxy:a,_descriptors:s}=t;let o=i[e];ep(o)&&s.isScriptable(e)&&(o=function(t,e,n,i){const{_proxy:r,_context:a,_subProxy:s,_stack:o}=n;if(o.has(t))throw new Error("Recursion detected: "+Array.from(o).join("->")+"->"+t);o.add(t);let l=e(a,s||i);o.delete(t),Lg(t,l)&&(l=Fg(r._scopes,r,t,l));return l}(e,o,t,n));jf(o)&&o.length&&(o=function(t,e,n,i){const{_proxy:r,_context:a,_subProxy:s,_descriptors:o}=n;if(void 0!==a.index&&i(t))return e[a.index%e.length];if(Af(e[0])){const n=e,i=r._scopes.filter((t=>t!==n));e=[];for(const l of n){const n=Fg(i,r,t,l);e.push(Dg(n,a,s&&s[t],o))}}return e}(e,o,t,s.isIndexable));Lg(e,o)&&(o=Dg(o,r,a&&a[e],s));return o}(t,e,n))),getOwnPropertyDescriptor:(e,n)=>e._descriptors.allKeys?Reflect.has(t,n)?{enumerable:!0,configurable:!0}:void 0:Reflect.getOwnPropertyDescriptor(t,n),getPrototypeOf:()=>Reflect.getPrototypeOf(t),has:(e,n)=>Reflect.has(t,n),ownKeys:()=>Reflect.ownKeys(t),set:(e,n,i)=>(t[n]=i,delete e[n],!0)})}function Tg(t,e={scriptable:!0,indexable:!0}){const{_scriptable:n=e.scriptable,_indexable:i=e.indexable,_allKeys:r=e.allKeys}=t;return{allKeys:r,scriptable:n,indexable:i,isScriptable:ep(n)?n:()=>n,isIndexable:ep(i)?i:()=>i}}const Og=(t,e)=>t?t+Zf(e):e,Lg=(t,e)=>Af(e)&&"adapters"!==t&&(null===Object.getPrototypeOf(e)||e.constructor===Object);function Rg(t,e,n){if(Object.prototype.hasOwnProperty.call(t,e)||"constructor"===e)return t[e];const i=n();return t[e]=i,i}function zg(t,e,n){return ep(t)?t(e,n):t}const jg=(t,e)=>!0===t?e:"string"==typeof t?Jf(e,t):void 0;function Ag(t,e,n,i,r){for(const a of e){const e=jg(n,a);if(e){t.add(e);const a=zg(e._fallback,n,r);if(void 0!==a&&a!==n&&a!==i)return a}else if(!1===e&&void 0!==i&&n!==i)return null}return!1}function Fg(t,e,n,i){const r=e._rootScopes,a=zg(e._fallback,n,i),s=[...t,...r],o=new Set;o.add(i);let l=Ig(o,s,n,a||n,i);return null!==l&&((void 0===a||a===n||(l=Ig(o,s,a,l,i),null!==l))&&Ng(Array.from(o),[""],r,a,(()=>function(t,e,n){const i=t._getTarget();e in i||(i[e]={});const r=i[e];if(jf(r)&&Af(n))return n;return r||{}}(e,n,i))))}function Ig(t,e,n,i,r){for(;n;)n=Ag(t,e,n,i,r);return n}function Vg(t,e){for(const n of e){if(!n)continue;const e=n[t];if(void 0!==e)return e}}function Bg(t){let e=t._keys;return e||(e=t._keys=function(t){const e=new Set;for(const n of t)for(const t of Object.keys(n).filter((t=>!t.startsWith("_"))))e.add(t);return Array.from(e)}(t._scopes)),e}function Wg(t,e,n,i){const{iScale:r}=t,{key:a="r"}=this._parsing,s=new Array(i);let o,l,c,u;for(o=0,l=i;o<l;++o)c=o+n,u=e[c],s[o]={r:r.parse(Jf(u,a),c)};return s}const Hg=Number.EPSILON||1e-14,$g=(t,e)=>e<t.length&&!t[e].skip&&t[e],Ug=t=>"x"===t?"y":"x";function Yg(t,e,n,i){const r=t.skip?e:t,a=e,s=n.skip?e:n,o=_p(a,r),l=_p(s,a);let c=o/(o+l),u=l/(o+l);c=isNaN(c)?0:c,u=isNaN(u)?0:u;const d=i*c,h=i*u;return{previous:{x:a.x-d*(s.x-r.x),y:a.y-d*(s.y-r.y)},next:{x:a.x+h*(s.x-r.x),y:a.y+h*(s.y-r.y)}}}function Qg(t,e="x"){const n=Ug(e),i=t.length,r=Array(i).fill(0),a=Array(i);let s,o,l,c=$g(t,0);for(s=0;s<i;++s)if(o=l,l=c,c=$g(t,s+1),l){if(c){const t=c[e]-l[e];r[s]=0!==t?(c[n]-l[n])/t:0}a[s]=o?c?hp(r[s-1])!==hp(r[s])?0:(r[s-1]+r[s])/2:r[s-1]:r[s]}!function(t,e,n){const i=t.length;let r,a,s,o,l,c=$g(t,0);for(let u=0;u<i-1;++u)l=c,c=$g(t,u+1),l&&c&&(fp(e[u],0,Hg)?n[u]=n[u+1]=0:(r=n[u]/e[u],a=n[u+1]/e[u],o=Math.pow(r,2)+Math.pow(a,2),o<=9||(s=3/Math.sqrt(o),n[u]=r*s*e[u],n[u+1]=a*s*e[u])))}(t,r,a),function(t,e,n="x"){const i=Ug(n),r=t.length;let a,s,o,l=$g(t,0);for(let c=0;c<r;++c){if(s=o,o=l,l=$g(t,c+1),!o)continue;const r=o[n],u=o[i];s&&(a=(r-s[n])/3,o[`cp1${n}`]=r-a,o[`cp1${i}`]=u-a*e[c]),l&&(a=(l[n]-r)/3,o[`cp2${n}`]=r+a,o[`cp2${i}`]=u+a*e[c])}}(t,a,e)}function qg(t,e,n){return Math.max(Math.min(t,n),e)}function Xg(t,e,n,i,r){let a,s,o,l;if(e.spanGaps&&(t=t.filter((t=>!t.skip))),"monotone"===e.cubicInterpolationMode)Qg(t,r);else{let n=i?t[t.length-1]:t[0];for(a=0,s=t.length;a<s;++a)o=t[a],l=Yg(n,o,t[Math.min(a+1,s-(i?0:1))%s],e.tension),o.cp1x=l.previous.x,o.cp1y=l.previous.y,o.cp2x=l.next.x,o.cp2y=l.next.y,n=o}e.capBezierPoints&&function(t,e){let n,i,r,a,s,o=ug(t[0],e);for(n=0,i=t.length;n<i;++n)s=a,a=o,o=n<i-1&&ug(t[n+1],e),a&&(r=t[n],s&&(r.cp1x=qg(r.cp1x,e.left,e.right),r.cp1y=qg(r.cp1y,e.top,e.bottom)),o&&(r.cp2x=qg(r.cp2x,e.left,e.right),r.cp2y=qg(r.cp2y,e.top,e.bottom)))}(t,n)}function Kg(){return"undefined"!=typeof window&&"undefined"!=typeof document}function Gg(t){let e=t.parentNode;return e&&"[object ShadowRoot]"===e.toString()&&(e=e.host),e}function Jg(t,e,n){let i;return"string"==typeof t?(i=parseInt(t,10),-1!==t.indexOf("%")&&(i=i/100*e.parentNode[n])):i=t,i}const Zg=t=>t.ownerDocument.defaultView.getComputedStyle(t,null);const tm=["top","right","bottom","left"];function em(t,e,n){const i={};n=n?"-"+n:"";for(let r=0;r<4;r++){const a=tm[r];i[a]=parseFloat(t[e+"-"+a+n])||0}return i.width=i.left+i.right,i.height=i.top+i.bottom,i}function nm(t,e){if("native"in t)return t;const{canvas:n,currentDevicePixelRatio:i}=e,r=Zg(n),a="border-box"===r.boxSizing,s=em(r,"padding"),o=em(r,"border","width"),{x:l,y:c,box:u}=function(t,e){const n=t.touches,i=n&&n.length?n[0]:t,{offsetX:r,offsetY:a}=i;let s,o,l=!1;if(((t,e,n)=>(t>0||e>0)&&(!n||!n.shadowRoot))(r,a,t.target))s=r,o=a;else{const t=e.getBoundingClientRect();s=i.clientX-t.left,o=i.clientY-t.top,l=!0}return{x:s,y:o,box:l}}(t,n),d=s.left+(u&&o.left),h=s.top+(u&&o.top);let{width:f,height:p}=e;return a&&(f-=s.width+o.width,p-=s.height+o.height),{x:Math.round((l-d)/f*n.width/i),y:Math.round((c-h)/p*n.height/i)}}const im=t=>Math.round(10*t)/10;function rm(t,e,n,i){const r=Zg(t),a=em(r,"margin"),s=Jg(r.maxWidth,t,"clientWidth")||sp,o=Jg(r.maxHeight,t,"clientHeight")||sp,l=function(t,e,n){let i,r;if(void 0===e||void 0===n){const a=t&&Gg(t);if(a){const t=a.getBoundingClientRect(),s=Zg(a),o=em(s,"border","width"),l=em(s,"padding");e=t.width-l.width-o.width,n=t.height-l.height-o.height,i=Jg(s.maxWidth,a,"clientWidth"),r=Jg(s.maxHeight,a,"clientHeight")}else e=t.clientWidth,n=t.clientHeight}return{width:e,height:n,maxWidth:i||sp,maxHeight:r||sp}}(t,e,n);let{width:c,height:u}=l;if("content-box"===r.boxSizing){const t=em(r,"border","width"),e=em(r,"padding");c-=e.width+t.width,u-=e.height+t.height}c=Math.max(0,c-a.width),u=Math.max(0,i?c/i:u-a.height),c=im(Math.min(c,s,l.maxWidth)),u=im(Math.min(u,o,l.maxHeight)),c&&!u&&(u=im(c/2));return(void 0!==e||void 0!==n)&&i&&l.height&&u>l.height&&(u=l.height,c=im(Math.floor(u*i))),{width:c,height:u}}function am(t,e,n){const i=e||1,r=Math.floor(t.height*i),a=Math.floor(t.width*i);t.height=Math.floor(t.height),t.width=Math.floor(t.width);const s=t.canvas;return s.style&&(n||!s.style.height&&!s.style.width)&&(s.style.height=`${t.height}px`,s.style.width=`${t.width}px`),(t.currentDevicePixelRatio!==i||s.height!==r||s.width!==a)&&(t.currentDevicePixelRatio=i,s.height=r,s.width=a,t.ctx.setTransform(i,0,0,i,0,0),!0)}const sm=function(){let t=!1;try{const e={get passive(){return t=!0,!1}};Kg()&&(window.addEventListener("test",null,e),window.removeEventListener("test",null,e))}catch(Ay){}return t}();function om(t,e){const n=function(t,e){return Zg(t).getPropertyValue(e)}(t,e),i=n&&n.match(/^(\d+)(\.\d+)?px$/);return i?+i[1]:void 0}function lm(t,e,n,i){return{x:t.x+n*(e.x-t.x),y:t.y+n*(e.y-t.y)}}function cm(t,e,n,i){return{x:t.x+n*(e.x-t.x),y:"middle"===i?n<.5?t.y:e.y:"after"===i?n<1?t.y:e.y:n>0?e.y:t.y}}function um(t,e,n,i){const r={x:t.cp2x,y:t.cp2y},a={x:e.cp1x,y:e.cp1y},s=lm(t,r,n),o=lm(r,a,n),l=lm(a,e,n),c=lm(s,o,n),u=lm(o,l,n);return lm(c,u,n)}function dm(t,e,n){return t?function(t,e){return{x:n=>t+t+e-n,setWidth(t){e=t},textAlign:t=>"center"===t?t:"right"===t?"left":"right",xPlus:(t,e)=>t-e,leftForLtr:(t,e)=>t-e}}(e,n):{x:t=>t,setWidth(t){},textAlign:t=>t,xPlus:(t,e)=>t+e,leftForLtr:(t,e)=>t}}function hm(t,e){let n,i;"ltr"!==e&&"rtl"!==e||(n=t.canvas.style,i=[n.getPropertyValue("direction"),n.getPropertyPriority("direction")],n.setProperty("direction",e,"important"),t.prevTextDirection=i)}function fm(t,e){void 0!==e&&(delete t.prevTextDirection,t.canvas.style.setProperty("direction",e[0],e[1]))}function pm(t){return"angle"===t?{between:Sp,compare:wp,normalize:kp}:{between:Mp,compare:(t,e)=>t-e,normalize:t=>t}}function gm({start:t,end:e,count:n,loop:i,style:r}){return{start:t%n,end:e%n,loop:i&&(e-t+1)%n==0,style:r}}function mm(t,e,n){if(!n)return[t];const{property:i,start:r,end:a}=n,s=e.length,{compare:o,between:l,normalize:c}=pm(i),{start:u,end:d,loop:h,style:f}=function(t,e,n){const{property:i,start:r,end:a}=n,{between:s,normalize:o}=pm(i),l=e.length;let c,u,{start:d,end:h,loop:f}=t;if(f){for(d+=l,h+=l,c=0,u=l;c<u&&s(o(e[d%l][i]),r,a);++c)d--,h--;d%=l,h%=l}return h<d&&(h+=l),{start:d,end:h,loop:f,style:t.style}}(t,e,n),p=[];let g,m,b,x=!1,v=null;const y=()=>x||l(r,b,g)&&0!==o(r,b),_=()=>!x||0===o(a,g)||l(a,b,g);for(let w=u,k=u;w<=d;++w)m=e[w%s],m.skip||(g=c(m[i]),g!==b&&(x=l(g,r,a),null===v&&y()&&(v=0===o(g,r)?w:k),null!==v&&_()&&(p.push(gm({start:v,end:w,loop:h,count:s,style:f})),v=null),k=w,b=g));return null!==v&&p.push(gm({start:v,end:d,loop:h,count:s,style:f})),p}function bm(t,e){const n=[],i=t.segments;for(let r=0;r<i.length;r++){const a=mm(i[r],t.points,e);a.length&&n.push(...a)}return n}function xm(t,e,n,i){return i&&i.setContext&&n?function(t,e,n,i){const r=t._chart.getContext(),a=vm(t.options),{_datasetIndex:s,options:{spanGaps:o}}=t,l=n.length,c=[];let u=a,d=e[0].start,h=d;function f(t,e,i,r){const a=o?-1:1;if(t!==e){for(t+=l;n[t%l].skip;)t-=a;for(;n[e%l].skip;)e+=a;t%l!=e%l&&(c.push({start:t%l,end:e%l,loop:i,style:r}),u=r,d=e%l)}}for(const p of e){d=o?d:p.start;let t,e=n[d%l];for(h=d+1;h<=p.end;h++){const a=n[h%l];t=vm(i.setContext(Pg(r,{type:"segment",p0:e,p1:a,p0DataIndex:(h-1)%l,p1DataIndex:h%l,datasetIndex:s}))),ym(t,u)&&f(d,h-1,p.loop,u),e=a,u=t}d<h-1&&f(d,h-1,p.loop,u)}return c}(t,e,n,i):e}function vm(t){return{backgroundColor:t.backgroundColor,borderCapStyle:t.borderCapStyle,borderDash:t.borderDash,borderDashOffset:t.borderDashOffset,borderJoinStyle:t.borderJoinStyle,borderWidth:t.borderWidth,borderColor:t.borderColor}}function ym(t,e){if(!e)return!1;const n=[],i=function(t,e){return Hp(e)?(n.includes(e)||n.push(e),n.indexOf(e)):e};return JSON.stringify(t,i)!==JSON.stringify(e,i)}
/*!
 * Chart.js v4.4.8
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */class _m{constructor(){this._request=null,this._charts=new Map,this._running=!1,this._lastDate=void 0}_notify(t,e,n,i){const r=e.listeners[i],a=e.duration;r.forEach((i=>i({chart:t,initial:e.initial,numSteps:a,currentStep:Math.min(n-e.start,a)})))}_refresh(){this._request||(this._running=!0,this._request=Lp.call(window,(()=>{this._update(),this._request=null,this._running&&this._refresh()})))}_update(t=Date.now()){let e=0;this._charts.forEach(((n,i)=>{if(!n.running||!n.items.length)return;const r=n.items;let a,s=r.length-1,o=!1;for(;s>=0;--s)a=r[s],a._active?(a._total>n.duration&&(n.duration=a._total),a.tick(t),o=!0):(r[s]=r[r.length-1],r.pop());o&&(i.draw(),this._notify(i,n,t,"progress")),r.length||(n.running=!1,this._notify(i,n,t,"complete"),n.initial=!1),e+=r.length})),this._lastDate=t,0===e&&(this._running=!1)}_getAnims(t){const e=this._charts;let n=e.get(t);return n||(n={running:!1,initial:!0,items:[],listeners:{complete:[],progress:[]}},e.set(t,n)),n}listen(t,e,n){this._getAnims(t).listeners[e].push(n)}add(t,e){e&&e.length&&this._getAnims(t).items.push(...e)}has(t){return this._getAnims(t).items.length>0}start(t){const e=this._charts.get(t);e&&(e.running=!0,e.start=Date.now(),e.duration=e.items.reduce(((t,e)=>Math.max(t,e._duration)),0),this._refresh())}running(t){if(!this._running)return!1;const e=this._charts.get(t);return!!(e&&e.running&&e.items.length)}stop(t){const e=this._charts.get(t);if(!e||!e.items.length)return;const n=e.items;let i=n.length-1;for(;i>=0;--i)n[i].cancel();e.items=[],this._notify(t,e,Date.now(),"complete")}remove(t){return this._charts.delete(t)}}var wm=new _m;const km="transparent",Sm={boolean:(t,e,n)=>n>.5?e:t,color(t,e,n){const i=$p(t||km),r=i.valid&&$p(e||km);return r&&r.valid?r.mix(i,n).hexString():e},number:(t,e,n)=>t+(e-t)*n};class Cm{constructor(t,e,n,i){const r=e[n];i=Eg([t.to,i,r,t.from]);const a=Eg([t.from,r,i]);this._active=!0,this._fn=t.fn||Sm[t.type||typeof a],this._easing=Wp[t.easing]||Wp.linear,this._start=Math.floor(Date.now()+(t.delay||0)),this._duration=this._total=Math.floor(t.duration),this._loop=!!t.loop,this._target=e,this._prop=n,this._from=a,this._to=i,this._promises=void 0}active(){return this._active}update(t,e,n){if(this._active){this._notify(!1);const i=this._target[this._prop],r=n-this._start,a=this._duration-r;this._start=n,this._duration=Math.floor(Math.max(a,t.duration)),this._total+=r,this._loop=!!t.loop,this._to=Eg([t.to,e,i,t.from]),this._from=Eg([t.from,i,e])}}cancel(){this._active&&(this.tick(Date.now()),this._active=!1,this._notify(!1))}tick(t){const e=t-this._start,n=this._duration,i=this._prop,r=this._from,a=this._loop,s=this._to;let o;if(this._active=r!==s&&(a||e<n),!this._active)return this._target[i]=s,void this._notify(!0);e<0?this._target[i]=r:(o=e/n%2,o=a&&o>1?2-o:o,o=this._easing(Math.min(1,Math.max(0,o))),this._target[i]=this._fn(r,s,o))}wait(){const t=this._promises||(this._promises=[]);return new Promise(((e,n)=>{t.push({res:e,rej:n})}))}_notify(t){const e=t?"res":"rej",n=this._promises||[];for(let i=0;i<n.length;i++)n[i][e]()}}class Mm{constructor(t,e){this._chart=t,this._properties=new Map,this.configure(e)}configure(t){if(!Af(t))return;const e=Object.keys(ig.animation),n=this._properties;Object.getOwnPropertyNames(t).forEach((i=>{const r=t[i];if(!Af(r))return;const a={};for(const t of e)a[t]=r[t];(jf(r.properties)&&r.properties||[i]).forEach((t=>{t!==i&&n.has(t)||n.set(t,a)}))}))}_animateOptions(t,e){const n=e.options,i=function(t,e){if(!e)return;let n=t.options;if(!n)return void(t.options=e);n.$shared&&(t.options=n=Object.assign({},n,{$shared:!1,$animations:{}}));return n}(t,n);if(!i)return[];const r=this._createAnimations(i,n);return n.$shared&&function(t,e){const n=[],i=Object.keys(e);for(let r=0;r<i.length;r++){const e=t[i[r]];e&&e.active()&&n.push(e.wait())}return Promise.all(n)}(t.options.$animations,n).then((()=>{t.options=n}),(()=>{})),r}_createAnimations(t,e){const n=this._properties,i=[],r=t.$animations||(t.$animations={}),a=Object.keys(e),s=Date.now();let o;for(o=a.length-1;o>=0;--o){const l=a[o];if("$"===l.charAt(0))continue;if("options"===l){i.push(...this._animateOptions(t,e));continue}const c=e[l];let u=r[l];const d=n.get(l);if(u){if(d&&u.active()){u.update(d,c,s);continue}u.cancel()}d&&d.duration?(r[l]=u=new Cm(d,t,l,c),i.push(u)):t[l]=c}return i}update(t,e){if(0===this._properties.size)return void Object.assign(t,e);const n=this._createAnimations(t,e);return n.length?(wm.add(this._chart,n),!0):void 0}}function Em(t,e){const n=t&&t.options||{},i=n.reverse,r=void 0===n.min?e:0,a=void 0===n.max?e:0;return{start:i?a:r,end:i?r:a}}function Pm(t,e){const n=[],i=t._getSortedDatasetMetas(e);let r,a;for(r=0,a=i.length;r<a;++r)n.push(i[r].index);return n}function Nm(t,e,n,i={}){const r=t.keys,a="single"===i.mode;let s,o,l,c;if(null===e)return;let u=!1;for(s=0,o=r.length;s<o;++s){if(l=+r[s],l===n){if(u=!0,i.all)continue;break}c=t.values[l],Ff(c)&&(a||0===e||hp(e)===hp(c))&&(e+=c)}return u||i.all?e:0}function Dm(t,e){const n=t&&t.options.stacked;return n||void 0===n&&void 0!==e.stack}function Tm(t,e,n){const i=t[e]||(t[e]={});return i[n]||(i[n]={})}function Om(t,e,n,i){for(const r of e.getMatchingVisibleMetas(i).reverse()){const e=t[r.index];if(n&&e>0||!n&&e<0)return r.index}return null}function Lm(t,e){const{chart:n,_cachedMeta:i}=t,r=n._stacks||(n._stacks={}),{iScale:a,vScale:s,index:o}=i,l=a.axis,c=s.axis,u=function(t,e,n){return`${t.id}.${e.id}.${n.stack||n.type}`}(a,s,i),d=e.length;let h;for(let f=0;f<d;++f){const t=e[f],{[l]:n,[c]:a}=t;h=(t._stacks||(t._stacks={}))[c]=Tm(r,u,n),h[o]=a,h._top=Om(h,s,!0,i.type),h._bottom=Om(h,s,!1,i.type);(h._visualValues||(h._visualValues={}))[o]=a}}function Rm(t,e){const n=t.scales;return Object.keys(n).filter((t=>n[t].axis===e)).shift()}function zm(t,e){const n=t.controller.index,i=t.vScale&&t.vScale.axis;if(i){e=e||t._parsed;for(const t of e){const e=t._stacks;if(!e||void 0===e[i]||void 0===e[i][n])return;delete e[i][n],void 0!==e[i]._visualValues&&void 0!==e[i]._visualValues[n]&&delete e[i]._visualValues[n]}}}const jm=t=>"reset"===t||"none"===t,Am=(t,e)=>e?t:Object.assign({},t);class Fm{constructor(t,e){this.chart=t,this._ctx=t.ctx,this.index=e,this._cachedDataOpts={},this._cachedMeta=this.getMeta(),this._type=this._cachedMeta.type,this.options=void 0,this._parsing=!1,this._data=void 0,this._objectData=void 0,this._sharedOptions=void 0,this._drawStart=void 0,this._drawCount=void 0,this.enableOptionSharing=!1,this.supportsDecimation=!1,this.$context=void 0,this._syncList=[],this.datasetElementType=new.target.datasetElementType,this.dataElementType=new.target.dataElementType,this.initialize()}initialize(){const t=this._cachedMeta;this.configure(),this.linkScales(),t._stacked=Dm(t.vScale,t),this.addElements(),this.options.fill&&!this.chart.isPluginEnabled("filler")&&console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options")}updateIndex(t){this.index!==t&&zm(this._cachedMeta),this.index=t}linkScales(){const t=this.chart,e=this._cachedMeta,n=this.getDataset(),i=(t,e,n,i)=>"x"===t?e:"r"===t?i:n,r=e.xAxisID=Vf(n.xAxisID,Rm(t,"x")),a=e.yAxisID=Vf(n.yAxisID,Rm(t,"y")),s=e.rAxisID=Vf(n.rAxisID,Rm(t,"r")),o=e.indexAxis,l=e.iAxisID=i(o,r,a,s),c=e.vAxisID=i(o,a,r,s);e.xScale=this.getScaleForId(r),e.yScale=this.getScaleForId(a),e.rScale=this.getScaleForId(s),e.iScale=this.getScaleForId(l),e.vScale=this.getScaleForId(c)}getDataset(){return this.chart.data.datasets[this.index]}getMeta(){return this.chart.getDatasetMeta(this.index)}getScaleForId(t){return this.chart.scales[t]}_getOtherScale(t){const e=this._cachedMeta;return t===e.iScale?e.vScale:e.iScale}reset(){this._update("reset")}_destroy(){const t=this._cachedMeta;this._data&&Tp(this._data,this),t._stacked&&zm(t)}_dataCheck(){const t=this.getDataset(),e=t.data||(t.data=[]),n=this._data;if(Af(e)){const t=this._cachedMeta;this._data=function(t,e){const{iScale:n,vScale:i}=e,r="x"===n.axis?"x":"y",a="x"===i.axis?"x":"y",s=Object.keys(t),o=new Array(s.length);let l,c,u;for(l=0,c=s.length;l<c;++l)u=s[l],o[l]={[r]:u,[a]:t[u]};return o}(e,t)}else if(n!==e){if(n){Tp(n,this);const t=this._cachedMeta;zm(t),t._parsed=[]}e&&Object.isExtensible(e)&&(r=this,(i=e)._chartjs?i._chartjs.listeners.push(r):(Object.defineProperty(i,"_chartjs",{configurable:!0,enumerable:!1,value:{listeners:[r]}}),Dp.forEach((t=>{const e="_onData"+Zf(t),n=i[t];Object.defineProperty(i,t,{configurable:!0,enumerable:!1,value(...t){const r=n.apply(this,t);return i._chartjs.listeners.forEach((n=>{"function"==typeof n[e]&&n[e](...t)})),r}})})))),this._syncList=[],this._data=e}var i,r}addElements(){const t=this._cachedMeta;this._dataCheck(),this.datasetElementType&&(t.dataset=new this.datasetElementType)}buildOrUpdateElements(t){const e=this._cachedMeta,n=this.getDataset();let i=!1;this._dataCheck();const r=e._stacked;e._stacked=Dm(e.vScale,e),e.stack!==n.stack&&(i=!0,zm(e),e.stack=n.stack),this._resyncElements(t),(i||r!==e._stacked)&&(Lm(this,e._parsed),e._stacked=Dm(e.vScale,e))}configure(){const t=this.chart.config,e=t.datasetScopeKeys(this._type),n=t.getOptionScopes(this.getDataset(),e,!0);this.options=t.createResolver(n,this.getContext()),this._parsing=this.options.parsing,this._cachedDataOpts={}}parse(t,e){const{_cachedMeta:n,_data:i}=this,{iScale:r,_stacked:a}=n,s=r.axis;let o,l,c,u=0===t&&e===i.length||n._sorted,d=t>0&&n._parsed[t-1];if(!1===this._parsing)n._parsed=i,n._sorted=!0,c=i;else{c=jf(i[t])?this.parseArrayData(n,i,t,e):Af(i[t])?this.parseObjectData(n,i,t,e):this.parsePrimitiveData(n,i,t,e);const r=()=>null===l[s]||d&&l[s]<d[s];for(o=0;o<e;++o)n._parsed[o+t]=l=c[o],u&&(r()&&(u=!1),d=l);n._sorted=u}a&&Lm(this,c)}parsePrimitiveData(t,e,n,i){const{iScale:r,vScale:a}=t,s=r.axis,o=a.axis,l=r.getLabels(),c=r===a,u=new Array(i);let d,h,f;for(d=0,h=i;d<h;++d)f=d+n,u[d]={[s]:c||r.parse(l[f],f),[o]:a.parse(e[f],f)};return u}parseArrayData(t,e,n,i){const{xScale:r,yScale:a}=t,s=new Array(i);let o,l,c,u;for(o=0,l=i;o<l;++o)c=o+n,u=e[c],s[o]={x:r.parse(u[0],c),y:a.parse(u[1],c)};return s}parseObjectData(t,e,n,i){const{xScale:r,yScale:a}=t,{xAxisKey:s="x",yAxisKey:o="y"}=this._parsing,l=new Array(i);let c,u,d,h;for(c=0,u=i;c<u;++c)d=c+n,h=e[d],l[c]={x:r.parse(Jf(h,s),d),y:a.parse(Jf(h,o),d)};return l}getParsed(t){return this._cachedMeta._parsed[t]}getDataElement(t){return this._cachedMeta.data[t]}applyStack(t,e,n){const i=this.chart,r=this._cachedMeta,a=e[t.axis];return Nm({keys:Pm(i,!0),values:e._stacks[t.axis]._visualValues},a,r.index,{mode:n})}updateRangeFromParsed(t,e,n,i){const r=n[e.axis];let a=null===r?NaN:r;const s=i&&n._stacks[e.axis];i&&s&&(i.values=s,a=Nm(i,r,this._cachedMeta.index)),t.min=Math.min(t.min,a),t.max=Math.max(t.max,a)}getMinMax(t,e){const n=this._cachedMeta,i=n._parsed,r=n._sorted&&t===n.iScale,a=i.length,s=this._getOtherScale(t),o=((t,e,n)=>t&&!e.hidden&&e._stacked&&{keys:Pm(n,!0),values:null})(e,n,this.chart),l={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY},{min:c,max:u}=function(t){const{min:e,max:n,minDefined:i,maxDefined:r}=t.getUserBounds();return{min:i?e:Number.NEGATIVE_INFINITY,max:r?n:Number.POSITIVE_INFINITY}}(s);let d,h;function f(){h=i[d];const e=h[s.axis];return!Ff(h[t.axis])||c>e||u<e}for(d=0;d<a&&(f()||(this.updateRangeFromParsed(l,t,h,o),!r));++d);if(r)for(d=a-1;d>=0;--d)if(!f()){this.updateRangeFromParsed(l,t,h,o);break}return l}getAllParsedValues(t){const e=this._cachedMeta._parsed,n=[];let i,r,a;for(i=0,r=e.length;i<r;++i)a=e[i][t.axis],Ff(a)&&n.push(a);return n}getMaxOverflow(){return!1}getLabelAndValue(t){const e=this._cachedMeta,n=e.iScale,i=e.vScale,r=this.getParsed(t);return{label:n?""+n.getLabelForValue(r[n.axis]):"",value:i?""+i.getLabelForValue(r[i.axis]):""}}_update(t){const e=this._cachedMeta;this.update(t||"default"),e._clip=function(t){let e,n,i,r;return Af(t)?(e=t.top,n=t.right,i=t.bottom,r=t.left):e=n=i=r=t,{top:e,right:n,bottom:i,left:r,disabled:!1===t}}(Vf(this.options.clip,function(t,e,n){if(!1===n)return!1;const i=Em(t,n),r=Em(e,n);return{top:r.end,right:i.end,bottom:r.start,left:i.start}}(e.xScale,e.yScale,this.getMaxOverflow())))}update(t){}draw(){const t=this._ctx,e=this.chart,n=this._cachedMeta,i=n.data||[],r=e.chartArea,a=[],s=this._drawStart||0,o=this._drawCount||i.length-s,l=this.options.drawActiveElementsOnTop;let c;for(n.dataset&&n.dataset.draw(t,r,s,o),c=s;c<s+o;++c){const e=i[c];e.hidden||(e.active&&l?a.push(e):e.draw(t,r))}for(c=0;c<a.length;++c)a[c].draw(t,r)}getStyle(t,e){const n=e?"active":"default";return void 0===t&&this._cachedMeta.dataset?this.resolveDatasetElementOptions(n):this.resolveDataElementOptions(t||0,n)}getContext(t,e,n){const i=this.getDataset();let r;if(t>=0&&t<this._cachedMeta.data.length){const e=this._cachedMeta.data[t];r=e.$context||(e.$context=function(t,e,n){return Pg(t,{active:!1,dataIndex:e,parsed:void 0,raw:void 0,element:n,index:e,mode:"default",type:"data"})}(this.getContext(),t,e)),r.parsed=this.getParsed(t),r.raw=i.data[t],r.index=r.dataIndex=t}else r=this.$context||(this.$context=function(t,e){return Pg(t,{active:!1,dataset:void 0,datasetIndex:e,index:e,mode:"default",type:"dataset"})}(this.chart.getContext(),this.index)),r.dataset=i,r.index=r.datasetIndex=this.index;return r.active=!!e,r.mode=n,r}resolveDatasetElementOptions(t){return this._resolveElementOptions(this.datasetElementType.id,t)}resolveDataElementOptions(t,e){return this._resolveElementOptions(this.dataElementType.id,e,t)}_resolveElementOptions(t,e="default",n){const i="active"===e,r=this._cachedDataOpts,a=t+"-"+e,s=r[a],o=this.enableOptionSharing&&tp(n);if(s)return Am(s,o);const l=this.chart.config,c=l.datasetElementScopeKeys(this._type,t),u=i?[`${t}Hover`,"hover",t,""]:[t,""],d=l.getOptionScopes(this.getDataset(),c),h=Object.keys(ig.elements[t]),f=l.resolveNamedOptions(d,h,(()=>this.getContext(n,i,e)),u);return f.$shared&&(f.$shared=o,r[a]=Object.freeze(Am(f,o))),f}_resolveAnimations(t,e,n){const i=this.chart,r=this._cachedDataOpts,a=`animation-${e}`,s=r[a];if(s)return s;let o;if(!1!==i.options.animation){const i=this.chart.config,r=i.datasetAnimationScopeKeys(this._type,e),a=i.getOptionScopes(this.getDataset(),r);o=i.createResolver(a,this.getContext(t,n,e))}const l=new Mm(i,o&&o.animations);return o&&o._cacheable&&(r[a]=Object.freeze(l)),l}getSharedOptions(t){if(t.$shared)return this._sharedOptions||(this._sharedOptions=Object.assign({},t))}includeOptions(t,e){return!e||jm(t)||this.chart._animationsDisabled}_getSharedOptions(t,e){const n=this.resolveDataElementOptions(t,e),i=this._sharedOptions,r=this.getSharedOptions(n),a=this.includeOptions(e,r)||r!==i;return this.updateSharedOptions(r,e,n),{sharedOptions:r,includeOptions:a}}updateElement(t,e,n,i){jm(i)?Object.assign(t,n):this._resolveAnimations(e,i).update(t,n)}updateSharedOptions(t,e,n){t&&!jm(e)&&this._resolveAnimations(void 0,e).update(t,n)}_setStyle(t,e,n,i){t.active=i;const r=this.getStyle(e,i);this._resolveAnimations(e,n,i).update(t,{options:!i&&this.getSharedOptions(r)||r})}removeHoverStyle(t,e,n){this._setStyle(t,n,"active",!1)}setHoverStyle(t,e,n){this._setStyle(t,n,"active",!0)}_removeDatasetHoverStyle(){const t=this._cachedMeta.dataset;t&&this._setStyle(t,void 0,"active",!1)}_setDatasetHoverStyle(){const t=this._cachedMeta.dataset;t&&this._setStyle(t,void 0,"active",!0)}_resyncElements(t){const e=this._data,n=this._cachedMeta.data;for(const[s,o,l]of this._syncList)this[s](o,l);this._syncList=[];const i=n.length,r=e.length,a=Math.min(r,i);a&&this.parse(0,a),r>i?this._insertElements(i,r-i,t):r<i&&this._removeElements(r,i-r)}_insertElements(t,e,n=!0){const i=this._cachedMeta,r=i.data,a=t+e;let s;const o=t=>{for(t.length+=e,s=t.length-1;s>=a;s--)t[s]=t[s-e]};for(o(r),s=t;s<a;++s)r[s]=new this.dataElementType;this._parsing&&o(i._parsed),this.parse(t,e),n&&this.updateElements(r,t,e,"reset")}updateElements(t,e,n,i){}_removeElements(t,e){const n=this._cachedMeta;if(this._parsing){const i=n._parsed.splice(t,e);n._stacked&&zm(n,i)}n.data.splice(t,e)}_sync(t){if(this._parsing)this._syncList.push(t);else{const[e,n,i]=t;this[e](n,i)}this.chart._dataChanges.push([this.index,...t])}_onDataPush(){const t=arguments.length;this._sync(["_insertElements",this.getDataset().data.length-t,t])}_onDataPop(){this._sync(["_removeElements",this._cachedMeta.data.length-1,1])}_onDataShift(){this._sync(["_removeElements",0,1])}_onDataSplice(t,e){e&&this._sync(["_removeElements",t,e]);const n=arguments.length-2;n&&this._sync(["_insertElements",t,n])}_onDataUnshift(){this._sync(["_insertElements",0,arguments.length])}}function Im(t){const e=t.iScale,n=function(t,e){if(!t._cache.$bar){const n=t.getMatchingVisibleMetas(e);let i=[];for(let e=0,r=n.length;e<r;e++)i=i.concat(n[e].controller.getAllParsedValues(t));t._cache.$bar=Op(i.sort(((t,e)=>t-e)))}return t._cache.$bar}(e,t.type);let i,r,a,s,o=e._length;const l=()=>{32767!==a&&-32768!==a&&(tp(s)&&(o=Math.min(o,Math.abs(a-s)||o)),s=a)};for(i=0,r=n.length;i<r;++i)a=e.getPixelForValue(n[i]),l();for(s=void 0,i=0,r=e.ticks.length;i<r;++i)a=e.getPixelForTick(i),l();return o}function Vm(t,e,n,i){return jf(t)?function(t,e,n,i){const r=n.parse(t[0],i),a=n.parse(t[1],i),s=Math.min(r,a),o=Math.max(r,a);let l=s,c=o;Math.abs(s)>Math.abs(o)&&(l=o,c=s),e[n.axis]=c,e._custom={barStart:l,barEnd:c,start:r,end:a,min:s,max:o}}(t,e,n,i):e[n.axis]=n.parse(t,i),e}function Bm(t,e,n,i){const r=t.iScale,a=t.vScale,s=r.getLabels(),o=r===a,l=[];let c,u,d,h;for(c=n,u=n+i;c<u;++c)h=e[c],d={},d[r.axis]=o||r.parse(s[c],c),l.push(Vm(h,d,a,c));return l}function Wm(t){return t&&void 0!==t.barStart&&void 0!==t.barEnd}function Hm(t,e,n,i){let r=e.borderSkipped;const a={};if(!r)return void(t.borderSkipped=a);if(!0===r)return void(t.borderSkipped={top:!0,right:!0,bottom:!0,left:!0});const{start:s,end:o,reverse:l,top:c,bottom:u}=function(t){let e,n,i,r,a;return t.horizontal?(e=t.base>t.x,n="left",i="right"):(e=t.base<t.y,n="bottom",i="top"),e?(r="end",a="start"):(r="start",a="end"),{start:n,end:i,reverse:e,top:r,bottom:a}}(t);"middle"===r&&n&&(t.enableBorderRadius=!0,(n._top||0)===i?r=c:(n._bottom||0)===i?r=u:(a[$m(u,s,o,l)]=!0,r=c)),a[$m(r,s,o,l)]=!0,t.borderSkipped=a}function $m(t,e,n,i){var r,a,s;return i?(s=n,t=Um(t=(r=t)===(a=e)?s:r===s?a:r,n,e)):t=Um(t,e,n),t}function Um(t,e,n){return"start"===t?e:"end"===t?n:t}function Ym(t,{inflateAmount:e},n){t.inflateAmount="auto"===e?1===n?.33:0:e}e(Fm,"defaults",{}),e(Fm,"datasetElementType",null),e(Fm,"dataElementType",null);class Qm extends Fm{parsePrimitiveData(t,e,n,i){return Bm(t,e,n,i)}parseArrayData(t,e,n,i){return Bm(t,e,n,i)}parseObjectData(t,e,n,i){const{iScale:r,vScale:a}=t,{xAxisKey:s="x",yAxisKey:o="y"}=this._parsing,l="x"===r.axis?s:o,c="x"===a.axis?s:o,u=[];let d,h,f,p;for(d=n,h=n+i;d<h;++d)p=e[d],f={},f[r.axis]=r.parse(Jf(p,l),d),u.push(Vm(Jf(p,c),f,a,d));return u}updateRangeFromParsed(t,e,n,i){super.updateRangeFromParsed(t,e,n,i);const r=n._custom;r&&e===this._cachedMeta.vScale&&(t.min=Math.min(t.min,r.min),t.max=Math.max(t.max,r.max))}getMaxOverflow(){return 0}getLabelAndValue(t){const e=this._cachedMeta,{iScale:n,vScale:i}=e,r=this.getParsed(t),a=r._custom,s=Wm(a)?"["+a.start+", "+a.end+"]":""+i.getLabelForValue(r[i.axis]);return{label:""+n.getLabelForValue(r[n.axis]),value:s}}initialize(){this.enableOptionSharing=!0,super.initialize();this._cachedMeta.stack=this.getDataset().stack}update(t){const e=this._cachedMeta;this.updateElements(e.data,0,e.data.length,t)}updateElements(t,e,n,i){const r="reset"===i,{index:a,_cachedMeta:{vScale:s}}=this,o=s.getBasePixel(),l=s.isHorizontal(),c=this._getRuler(),{sharedOptions:u,includeOptions:d}=this._getSharedOptions(e,i);for(let h=e;h<e+n;h++){const e=this.getParsed(h),n=r||zf(e[s.axis])?{base:o,head:o}:this._calculateBarValuePixels(h),f=this._calculateBarIndexPixels(h,c),p=(e._stacks||{})[s.axis],g={horizontal:l,base:n.base,enableBorderRadius:!p||Wm(e._custom)||a===p._top||a===p._bottom,x:l?n.head:f.center,y:l?f.center:n.head,height:l?f.size:Math.abs(n.size),width:l?Math.abs(n.size):f.size};d&&(g.options=u||this.resolveDataElementOptions(h,t[h].active?"active":i));const m=g.options||t[h].options;Hm(g,m,p,a),Ym(g,m,c.ratio),this.updateElement(t[h],h,g,i)}}_getStacks(t,e){const{iScale:n}=this._cachedMeta,i=n.getMatchingVisibleMetas(this._type).filter((t=>t.controller.options.grouped)),r=n.options.stacked,a=[],s=this._cachedMeta.controller.getParsed(e),o=s&&s[n.axis],l=t=>{const e=t._parsed.find((t=>t[n.axis]===o)),i=e&&e[t.vScale.axis];if(zf(i)||isNaN(i))return!0};for(const c of i)if((void 0===e||!l(c))&&((!1===r||-1===a.indexOf(c.stack)||void 0===r&&void 0===c.stack)&&a.push(c.stack),c.index===t))break;return a.length||a.push(void 0),a}_getStackCount(t){return this._getStacks(void 0,t).length}_getStackIndex(t,e,n){const i=this._getStacks(t,n),r=void 0!==e?i.indexOf(e):-1;return-1===r?i.length-1:r}_getRuler(){const t=this.options,e=this._cachedMeta,n=e.iScale,i=[];let r,a;for(r=0,a=e.data.length;r<a;++r)i.push(n.getPixelForValue(this.getParsed(r)[n.axis],r));const s=t.barThickness;return{min:s||Im(e),pixels:i,start:n._startPixel,end:n._endPixel,stackCount:this._getStackCount(),scale:n,grouped:t.grouped,ratio:s?1:t.categoryPercentage*t.barPercentage}}_calculateBarValuePixels(t){const{_cachedMeta:{vScale:e,_stacked:n,index:i},options:{base:r,minBarLength:a}}=this,s=r||0,o=this.getParsed(t),l=o._custom,c=Wm(l);let u,d,h=o[e.axis],f=0,p=n?this.applyStack(e,o,n):h;p!==h&&(f=p-h,p=h),c&&(h=l.barStart,p=l.barEnd-l.barStart,0!==h&&hp(h)!==hp(l.barEnd)&&(f=0),f+=h);const g=zf(r)||c?f:r;let m=e.getPixelForValue(g);if(u=this.chart.getDataVisibility(t)?e.getPixelForValue(f+p):m,d=u-m,Math.abs(d)<a){d=function(t,e,n){return 0!==t?hp(t):(e.isHorizontal()?1:-1)*(e.min>=n?1:-1)}(d,e,s)*a,h===s&&(m-=d/2);const t=e.getPixelForDecimal(0),r=e.getPixelForDecimal(1),l=Math.min(t,r),f=Math.max(t,r);m=Math.max(Math.min(m,f),l),u=m+d,n&&!c&&(o._stacks[e.axis]._visualValues[i]=e.getValueForPixel(u)-e.getValueForPixel(m))}if(m===e.getPixelForValue(s)){const t=hp(d)*e.getLineWidthForValue(s)/2;m+=t,d-=t}return{size:d,base:m,head:u,center:u+d/2}}_calculateBarIndexPixels(t,e){const n=e.scale,i=this.options,r=i.skipNull,a=Vf(i.maxBarThickness,1/0);let s,o;if(e.grouped){const n=r?this._getStackCount(t):e.stackCount,l="flex"===i.barThickness?function(t,e,n,i){const r=e.pixels,a=r[t];let s=t>0?r[t-1]:null,o=t<r.length-1?r[t+1]:null;const l=n.categoryPercentage;null===s&&(s=a-(null===o?e.end-e.start:o-a)),null===o&&(o=a+a-s);const c=a-(a-Math.min(s,o))/2*l;return{chunk:Math.abs(o-s)/2*l/i,ratio:n.barPercentage,start:c}}(t,e,i,n):function(t,e,n,i){const r=n.barThickness;let a,s;return zf(r)?(a=e.min*n.categoryPercentage,s=n.barPercentage):(a=r*i,s=1),{chunk:a/i,ratio:s,start:e.pixels[t]-a/2}}(t,e,i,n),c=this._getStackIndex(this.index,this._cachedMeta.stack,r?t:void 0);s=l.start+l.chunk*c+l.chunk/2,o=Math.min(a,l.chunk*l.ratio)}else s=n.getPixelForValue(this.getParsed(t)[n.axis],t),o=Math.min(a,e.min*e.ratio);return{base:s-o/2,head:s+o/2,center:s,size:o}}draw(){const t=this._cachedMeta,e=t.vScale,n=t.data,i=n.length;let r=0;for(;r<i;++r)null===this.getParsed(r)[e.axis]||n[r].hidden||n[r].draw(this._ctx)}}e(Qm,"id","bar"),e(Qm,"defaults",{datasetElementType:!1,dataElementType:"bar",categoryPercentage:.8,barPercentage:.9,grouped:!0,animations:{numbers:{type:"number",properties:["x","y","base","width","height"]}}}),e(Qm,"overrides",{scales:{_index_:{type:"category",offset:!0,grid:{offset:!0}},_value_:{type:"linear",beginAtZero:!0}}});class qm extends Fm{initialize(){this.enableOptionSharing=!0,super.initialize()}parsePrimitiveData(t,e,n,i){const r=super.parsePrimitiveData(t,e,n,i);for(let a=0;a<r.length;a++)r[a]._custom=this.resolveDataElementOptions(a+n).radius;return r}parseArrayData(t,e,n,i){const r=super.parseArrayData(t,e,n,i);for(let a=0;a<r.length;a++){const t=e[n+a];r[a]._custom=Vf(t[2],this.resolveDataElementOptions(a+n).radius)}return r}parseObjectData(t,e,n,i){const r=super.parseObjectData(t,e,n,i);for(let a=0;a<r.length;a++){const t=e[n+a];r[a]._custom=Vf(t&&t.r&&+t.r,this.resolveDataElementOptions(a+n).radius)}return r}getMaxOverflow(){const t=this._cachedMeta.data;let e=0;for(let n=t.length-1;n>=0;--n)e=Math.max(e,t[n].size(this.resolveDataElementOptions(n))/2);return e>0&&e}getLabelAndValue(t){const e=this._cachedMeta,n=this.chart.data.labels||[],{xScale:i,yScale:r}=e,a=this.getParsed(t),s=i.getLabelForValue(a.x),o=r.getLabelForValue(a.y),l=a._custom;return{label:n[t]||"",value:"("+s+", "+o+(l?", "+l:"")+")"}}update(t){const e=this._cachedMeta.data;this.updateElements(e,0,e.length,t)}updateElements(t,e,n,i){const r="reset"===i,{iScale:a,vScale:s}=this._cachedMeta,{sharedOptions:o,includeOptions:l}=this._getSharedOptions(e,i),c=a.axis,u=s.axis;for(let d=e;d<e+n;d++){const e=t[d],n=!r&&this.getParsed(d),h={},f=h[c]=r?a.getPixelForDecimal(.5):a.getPixelForValue(n[c]),p=h[u]=r?s.getBasePixel():s.getPixelForValue(n[u]);h.skip=isNaN(f)||isNaN(p),l&&(h.options=o||this.resolveDataElementOptions(d,e.active?"active":i),r&&(h.options.radius=0)),this.updateElement(e,d,h,i)}}resolveDataElementOptions(t,e){const n=this.getParsed(t);let i=super.resolveDataElementOptions(t,e);i.$shared&&(i=Object.assign({},i,{$shared:!1}));const r=i.radius;return"active"!==e&&(i.radius=0),i.radius+=Vf(n&&n._custom,r),i}}e(qm,"id","bubble"),e(qm,"defaults",{datasetElementType:!1,dataElementType:"point",animations:{numbers:{type:"number",properties:["x","y","borderWidth","radius"]}}}),e(qm,"overrides",{scales:{x:{type:"linear"},y:{type:"linear"}}});class Xm extends Fm{constructor(t,e){super(t,e),this.enableOptionSharing=!0,this.innerRadius=void 0,this.outerRadius=void 0,this.offsetX=void 0,this.offsetY=void 0}linkScales(){}parse(t,e){const n=this.getDataset().data,i=this._cachedMeta;if(!1===this._parsing)i._parsed=n;else{let r,a,s=t=>+n[t];if(Af(n[t])){const{key:t="value"}=this._parsing;s=e=>+Jf(n[e],t)}for(r=t,a=t+e;r<a;++r)i._parsed[r]=s(r)}}_getRotation(){return bp(this.options.rotation-90)}_getCircumference(){return bp(this.options.circumference)}_getRotationExtents(){let t=rp,e=-rp;for(let n=0;n<this.chart.data.datasets.length;++n)if(this.chart.isDatasetVisible(n)&&this.chart.getDatasetMeta(n).type===this._type){const i=this.chart.getDatasetMeta(n).controller,r=i._getRotation(),a=i._getCircumference();t=Math.min(t,r),e=Math.max(e,r+a)}return{rotation:t,circumference:e-t}}update(t){const e=this.chart,{chartArea:n}=e,i=this._cachedMeta,r=i.data,a=this.getMaxBorderWidth()+this.getMaxOffset(r)+this.options.spacing,s=Math.max((Math.min(n.width,n.height)-a)/2,0),o=Math.min((l=this.options.cutout,c=s,"string"==typeof l&&l.endsWith("%")?parseFloat(l)/100:+l/c),1);var l,c;const u=this._getRingWeight(this.index),{circumference:d,rotation:h}=this._getRotationExtents(),{ratioX:f,ratioY:p,offsetX:g,offsetY:m}=function(t,e,n){let i=1,r=1,a=0,s=0;if(e<rp){const o=t,l=o+e,c=Math.cos(o),u=Math.sin(o),d=Math.cos(l),h=Math.sin(l),f=(t,e,i)=>Sp(t,o,l,!0)?1:Math.max(e,e*n,i,i*n),p=(t,e,i)=>Sp(t,o,l,!0)?-1:Math.min(e,e*n,i,i*n),g=f(0,c,d),m=f(lp,u,h),b=p(ip,c,d),x=p(ip+lp,u,h);i=(g-b)/2,r=(m-x)/2,a=-(g+b)/2,s=-(m+x)/2}return{ratioX:i,ratioY:r,offsetX:a,offsetY:s}}(h,d,o),b=(n.width-a)/f,x=(n.height-a)/p,v=Math.max(Math.min(b,x)/2,0),y=Bf(this.options.radius,v),_=(y-Math.max(y*o,0))/this._getVisibleDatasetWeightTotal();this.offsetX=g*y,this.offsetY=m*y,i.total=this.calculateTotal(),this.outerRadius=y-_*this._getRingWeightOffset(this.index),this.innerRadius=Math.max(this.outerRadius-_*u,0),this.updateElements(r,0,r.length,t)}_circumference(t,e){const n=this.options,i=this._cachedMeta,r=this._getCircumference();return e&&n.animation.animateRotate||!this.chart.getDataVisibility(t)||null===i._parsed[t]||i.data[t].hidden?0:this.calculateCircumference(i._parsed[t]*r/rp)}updateElements(t,e,n,i){const r="reset"===i,a=this.chart,s=a.chartArea,o=a.options.animation,l=(s.left+s.right)/2,c=(s.top+s.bottom)/2,u=r&&o.animateScale,d=u?0:this.innerRadius,h=u?0:this.outerRadius,{sharedOptions:f,includeOptions:p}=this._getSharedOptions(e,i);let g,m=this._getRotation();for(g=0;g<e;++g)m+=this._circumference(g,r);for(g=e;g<e+n;++g){const e=this._circumference(g,r),n=t[g],a={x:l+this.offsetX,y:c+this.offsetY,startAngle:m,endAngle:m+e,circumference:e,outerRadius:h,innerRadius:d};p&&(a.options=f||this.resolveDataElementOptions(g,n.active?"active":i)),m+=e,this.updateElement(n,g,a,i)}}calculateTotal(){const t=this._cachedMeta,e=t.data;let n,i=0;for(n=0;n<e.length;n++){const r=t._parsed[n];null===r||isNaN(r)||!this.chart.getDataVisibility(n)||e[n].hidden||(i+=Math.abs(r))}return i}calculateCircumference(t){const e=this._cachedMeta.total;return e>0&&!isNaN(t)?rp*(Math.abs(t)/e):0}getLabelAndValue(t){const e=this._cachedMeta,n=this.chart,i=n.data.labels||[],r=Xp(e._parsed[t],n.options.locale);return{label:i[t]||"",value:r}}getMaxBorderWidth(t){let e=0;const n=this.chart;let i,r,a,s,o;if(!t)for(i=0,r=n.data.datasets.length;i<r;++i)if(n.isDatasetVisible(i)){a=n.getDatasetMeta(i),t=a.data,s=a.controller;break}if(!t)return 0;for(i=0,r=t.length;i<r;++i)o=s.resolveDataElementOptions(i),"inner"!==o.borderAlign&&(e=Math.max(e,o.borderWidth||0,o.hoverBorderWidth||0));return e}getMaxOffset(t){let e=0;for(let n=0,i=t.length;n<i;++n){const t=this.resolveDataElementOptions(n);e=Math.max(e,t.offset||0,t.hoverOffset||0)}return e}_getRingWeightOffset(t){let e=0;for(let n=0;n<t;++n)this.chart.isDatasetVisible(n)&&(e+=this._getRingWeight(n));return e}_getRingWeight(t){return Math.max(Vf(this.chart.data.datasets[t].weight,1),0)}_getVisibleDatasetWeightTotal(){return this._getRingWeightOffset(this.chart.data.datasets.length)||1}}e(Xm,"id","doughnut"),e(Xm,"defaults",{datasetElementType:!1,dataElementType:"arc",animation:{animateRotate:!0,animateScale:!1},animations:{numbers:{type:"number",properties:["circumference","endAngle","innerRadius","outerRadius","startAngle","x","y","offset","borderWidth","spacing"]}},cutout:"50%",rotation:0,circumference:360,radius:"100%",spacing:0,indexAxis:"r"}),e(Xm,"descriptors",{_scriptable:t=>"spacing"!==t,_indexable:t=>"spacing"!==t&&!t.startsWith("borderDash")&&!t.startsWith("hoverBorderDash")}),e(Xm,"overrides",{aspectRatio:1,plugins:{legend:{labels:{generateLabels(t){const e=t.data;if(e.labels.length&&e.datasets.length){const{labels:{pointStyle:n,color:i}}=t.legend.options;return e.labels.map(((e,r)=>{const a=t.getDatasetMeta(0).controller.getStyle(r);return{text:e,fillStyle:a.backgroundColor,strokeStyle:a.borderColor,fontColor:i,lineWidth:a.borderWidth,pointStyle:n,hidden:!t.getDataVisibility(r),index:r}}))}return[]}},onClick(t,e,n){n.chart.toggleDataVisibility(e.index),n.chart.update()}}}});class Km extends Fm{initialize(){this.enableOptionSharing=!0,this.supportsDecimation=!0,super.initialize()}update(t){const e=this._cachedMeta,{dataset:n,data:i=[],_dataset:r}=e,a=this.chart._animationsDisabled;let{start:s,count:o}=Ap(e,i,a);this._drawStart=s,this._drawCount=o,Fp(e)&&(s=0,o=i.length),n._chart=this.chart,n._datasetIndex=this.index,n._decimated=!!r._decimated,n.points=i;const l=this.resolveDatasetElementOptions(t);this.options.showLine||(l.borderWidth=0),l.segment=this.options.segment,this.updateElement(n,void 0,{animated:!a,options:l},t),this.updateElements(i,s,o,t)}updateElements(t,e,n,i){const r="reset"===i,{iScale:a,vScale:s,_stacked:o,_dataset:l}=this._cachedMeta,{sharedOptions:c,includeOptions:u}=this._getSharedOptions(e,i),d=a.axis,h=s.axis,{spanGaps:f,segment:p}=this.options,g=gp(f)?f:Number.POSITIVE_INFINITY,m=this.chart._animationsDisabled||r||"none"===i,b=e+n,x=t.length;let v=e>0&&this.getParsed(e-1);for(let y=0;y<x;++y){const n=t[y],f=m?n:{};if(y<e||y>=b){f.skip=!0;continue}const x=this.getParsed(y),_=zf(x[h]),w=f[d]=a.getPixelForValue(x[d],y),k=f[h]=r||_?s.getBasePixel():s.getPixelForValue(o?this.applyStack(s,x,o):x[h],y);f.skip=isNaN(w)||isNaN(k)||_,f.stop=y>0&&Math.abs(x[d]-v[d])>g,p&&(f.parsed=x,f.raw=l.data[y]),u&&(f.options=c||this.resolveDataElementOptions(y,n.active?"active":i)),m||this.updateElement(n,y,f,i),v=x}}getMaxOverflow(){const t=this._cachedMeta,e=t.dataset,n=e.options&&e.options.borderWidth||0,i=t.data||[];if(!i.length)return n;const r=i[0].size(this.resolveDataElementOptions(0)),a=i[i.length-1].size(this.resolveDataElementOptions(i.length-1));return Math.max(n,r,a)/2}draw(){const t=this._cachedMeta;t.dataset.updateControlPoints(this.chart.chartArea,t.iScale.axis),super.draw()}}e(Km,"id","line"),e(Km,"defaults",{datasetElementType:"line",dataElementType:"point",showLine:!0,spanGaps:!1}),e(Km,"overrides",{scales:{_index_:{type:"category"},_value_:{type:"linear"}}});class Gm extends Fm{constructor(t,e){super(t,e),this.innerRadius=void 0,this.outerRadius=void 0}getLabelAndValue(t){const e=this._cachedMeta,n=this.chart,i=n.data.labels||[],r=Xp(e._parsed[t].r,n.options.locale);return{label:i[t]||"",value:r}}parseObjectData(t,e,n,i){return Wg.bind(this)(t,e,n,i)}update(t){const e=this._cachedMeta.data;this._updateRadius(),this.updateElements(e,0,e.length,t)}getMinMax(){const t=this._cachedMeta,e={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY};return t.data.forEach(((t,n)=>{const i=this.getParsed(n).r;!isNaN(i)&&this.chart.getDataVisibility(n)&&(i<e.min&&(e.min=i),i>e.max&&(e.max=i))})),e}_updateRadius(){const t=this.chart,e=t.chartArea,n=t.options,i=Math.min(e.right-e.left,e.bottom-e.top),r=Math.max(i/2,0),a=(r-Math.max(n.cutoutPercentage?r/100*n.cutoutPercentage:1,0))/t.getVisibleDatasetCount();this.outerRadius=r-a*this.index,this.innerRadius=this.outerRadius-a}updateElements(t,e,n,i){const r="reset"===i,a=this.chart,s=a.options.animation,o=this._cachedMeta.rScale,l=o.xCenter,c=o.yCenter,u=o.getIndexAngle(0)-.5*ip;let d,h=u;const f=360/this.countVisibleElements();for(d=0;d<e;++d)h+=this._computeAngle(d,i,f);for(d=e;d<e+n;d++){const e=t[d];let n=h,p=h+this._computeAngle(d,i,f),g=a.getDataVisibility(d)?o.getDistanceFromCenterForValue(this.getParsed(d).r):0;h=p,r&&(s.animateScale&&(g=0),s.animateRotate&&(n=p=u));const m={x:l,y:c,innerRadius:0,outerRadius:g,startAngle:n,endAngle:p,options:this.resolveDataElementOptions(d,e.active?"active":i)};this.updateElement(e,d,m,i)}}countVisibleElements(){const t=this._cachedMeta;let e=0;return t.data.forEach(((t,n)=>{!isNaN(this.getParsed(n).r)&&this.chart.getDataVisibility(n)&&e++})),e}_computeAngle(t,e,n){return this.chart.getDataVisibility(t)?bp(this.resolveDataElementOptions(t,e).angle||n):0}}e(Gm,"id","polarArea"),e(Gm,"defaults",{dataElementType:"arc",animation:{animateRotate:!0,animateScale:!0},animations:{numbers:{type:"number",properties:["x","y","startAngle","endAngle","innerRadius","outerRadius"]}},indexAxis:"r",startAngle:0}),e(Gm,"overrides",{aspectRatio:1,plugins:{legend:{labels:{generateLabels(t){const e=t.data;if(e.labels.length&&e.datasets.length){const{labels:{pointStyle:n,color:i}}=t.legend.options;return e.labels.map(((e,r)=>{const a=t.getDatasetMeta(0).controller.getStyle(r);return{text:e,fillStyle:a.backgroundColor,strokeStyle:a.borderColor,fontColor:i,lineWidth:a.borderWidth,pointStyle:n,hidden:!t.getDataVisibility(r),index:r}}))}return[]}},onClick(t,e,n){n.chart.toggleDataVisibility(e.index),n.chart.update()}}},scales:{r:{type:"radialLinear",angleLines:{display:!1},beginAtZero:!0,grid:{circular:!0},pointLabels:{display:!1},startAngle:0}}});class Jm extends Xm{}e(Jm,"id","pie"),e(Jm,"defaults",{cutout:0,rotation:0,circumference:360,radius:"100%"});class Zm extends Fm{getLabelAndValue(t){const e=this._cachedMeta.vScale,n=this.getParsed(t);return{label:e.getLabels()[t],value:""+e.getLabelForValue(n[e.axis])}}parseObjectData(t,e,n,i){return Wg.bind(this)(t,e,n,i)}update(t){const e=this._cachedMeta,n=e.dataset,i=e.data||[],r=e.iScale.getLabels();if(n.points=i,"resize"!==t){const e=this.resolveDatasetElementOptions(t);this.options.showLine||(e.borderWidth=0);const a={_loop:!0,_fullLoop:r.length===i.length,options:e};this.updateElement(n,void 0,a,t)}this.updateElements(i,0,i.length,t)}updateElements(t,e,n,i){const r=this._cachedMeta.rScale,a="reset"===i;for(let s=e;s<e+n;s++){const e=t[s],n=this.resolveDataElementOptions(s,e.active?"active":i),o=r.getPointPositionForValue(s,this.getParsed(s).r),l=a?r.xCenter:o.x,c=a?r.yCenter:o.y,u={x:l,y:c,angle:o.angle,skip:isNaN(l)||isNaN(c),options:n};this.updateElement(e,s,u,i)}}}e(Zm,"id","radar"),e(Zm,"defaults",{datasetElementType:"line",dataElementType:"point",indexAxis:"r",showLine:!0,elements:{line:{fill:"start"}}}),e(Zm,"overrides",{aspectRatio:1,scales:{r:{type:"radialLinear"}}});class tb extends Fm{getLabelAndValue(t){const e=this._cachedMeta,n=this.chart.data.labels||[],{xScale:i,yScale:r}=e,a=this.getParsed(t),s=i.getLabelForValue(a.x),o=r.getLabelForValue(a.y);return{label:n[t]||"",value:"("+s+", "+o+")"}}update(t){const e=this._cachedMeta,{data:n=[]}=e,i=this.chart._animationsDisabled;let{start:r,count:a}=Ap(e,n,i);if(this._drawStart=r,this._drawCount=a,Fp(e)&&(r=0,a=n.length),this.options.showLine){this.datasetElementType||this.addElements();const{dataset:r,_dataset:a}=e;r._chart=this.chart,r._datasetIndex=this.index,r._decimated=!!a._decimated,r.points=n;const s=this.resolveDatasetElementOptions(t);s.segment=this.options.segment,this.updateElement(r,void 0,{animated:!i,options:s},t)}else this.datasetElementType&&(delete e.dataset,this.datasetElementType=!1);this.updateElements(n,r,a,t)}addElements(){const{showLine:t}=this.options;!this.datasetElementType&&t&&(this.datasetElementType=this.chart.registry.getElement("line")),super.addElements()}updateElements(t,e,n,i){const r="reset"===i,{iScale:a,vScale:s,_stacked:o,_dataset:l}=this._cachedMeta,c=this.resolveDataElementOptions(e,i),u=this.getSharedOptions(c),d=this.includeOptions(i,u),h=a.axis,f=s.axis,{spanGaps:p,segment:g}=this.options,m=gp(p)?p:Number.POSITIVE_INFINITY,b=this.chart._animationsDisabled||r||"none"===i;let x=e>0&&this.getParsed(e-1);for(let v=e;v<e+n;++v){const e=t[v],n=this.getParsed(v),c=b?e:{},p=zf(n[f]),y=c[h]=a.getPixelForValue(n[h],v),_=c[f]=r||p?s.getBasePixel():s.getPixelForValue(o?this.applyStack(s,n,o):n[f],v);c.skip=isNaN(y)||isNaN(_)||p,c.stop=v>0&&Math.abs(n[h]-x[h])>m,g&&(c.parsed=n,c.raw=l.data[v]),d&&(c.options=u||this.resolveDataElementOptions(v,e.active?"active":i)),b||this.updateElement(e,v,c,i),x=n}this.updateSharedOptions(u,i,c)}getMaxOverflow(){const t=this._cachedMeta,e=t.data||[];if(!this.options.showLine){let t=0;for(let n=e.length-1;n>=0;--n)t=Math.max(t,e[n].size(this.resolveDataElementOptions(n))/2);return t>0&&t}const n=t.dataset,i=n.options&&n.options.borderWidth||0;if(!e.length)return i;const r=e[0].size(this.resolveDataElementOptions(0)),a=e[e.length-1].size(this.resolveDataElementOptions(e.length-1));return Math.max(i,r,a)/2}}e(tb,"id","scatter"),e(tb,"defaults",{datasetElementType:!1,dataElementType:"point",showLine:!1,fill:!1}),e(tb,"overrides",{interaction:{mode:"point"},scales:{x:{type:"linear"},y:{type:"linear"}}});var eb=Object.freeze({__proto__:null,BarController:Qm,BubbleController:qm,DoughnutController:Xm,LineController:Km,PieController:Jm,PolarAreaController:Gm,RadarController:Zm,ScatterController:tb});function nb(){throw new Error("This method is not implemented: Check that a complete date adapter is provided.")}class ib{constructor(t){e(this,"options"),this.options=t||{}}static override(t){Object.assign(ib.prototype,t)}init(){}formats(){return nb()}parse(){return nb()}format(){return nb()}add(){return nb()}diff(){return nb()}startOf(){return nb()}endOf(){return nb()}}var rb=ib;function ab(t,e,n,i){const{controller:r,data:a,_sorted:s}=t,o=r._cachedMeta.iScale,l=t.dataset&&t.dataset.options?t.dataset.options.spanGaps:null;if(o&&e===o.axis&&"r"!==e&&s&&a.length){const s=o._reversePixels?Np:Pp;if(!i){const i=s(a,e,n);if(l){const{vScale:e}=r._cachedMeta,{_parsed:n}=t,a=n.slice(0,i.lo+1).reverse().findIndex((t=>!zf(t[e.axis])));i.lo-=Math.max(0,a);const s=n.slice(i.hi).findIndex((t=>!zf(t[e.axis])));i.hi+=Math.max(0,s)}return i}if(r._sharedOptions){const t=a[0],i="function"==typeof t.getRange&&t.getRange(e);if(i){const t=s(a,e,n-i),r=s(a,e,n+i);return{lo:t.lo,hi:r.hi}}}}return{lo:0,hi:a.length-1}}function sb(t,e,n,i,r){const a=t.getSortedVisibleDatasetMetas(),s=n[e];for(let o=0,l=a.length;o<l;++o){const{index:t,data:n}=a[o],{lo:l,hi:c}=ab(a[o],e,s,r);for(let e=l;e<=c;++e){const r=n[e];r.skip||i(r,t,e)}}}function ob(t,e,n,i,r){const a=[];if(!r&&!t.isPointInArea(e))return a;return sb(t,n,e,(function(n,s,o){(r||ug(n,t.chartArea,0))&&n.inRange(e.x,e.y,i)&&a.push({element:n,datasetIndex:s,index:o})}),!0),a}function lb(t,e,n,i,r,a){let s=[];const o=function(t){const e=-1!==t.indexOf("x"),n=-1!==t.indexOf("y");return function(t,i){const r=e?Math.abs(t.x-i.x):0,a=n?Math.abs(t.y-i.y):0;return Math.sqrt(Math.pow(r,2)+Math.pow(a,2))}}(n);let l=Number.POSITIVE_INFINITY;return sb(t,n,e,(function(n,c,u){const d=n.inRange(e.x,e.y,r);if(i&&!d)return;const h=n.getCenterPoint(r);if(!(!!a||t.isPointInArea(h))&&!d)return;const f=o(e,h);f<l?(s=[{element:n,datasetIndex:c,index:u}],l=f):f===l&&s.push({element:n,datasetIndex:c,index:u})})),s}function cb(t,e,n,i,r,a){return a||t.isPointInArea(e)?"r"!==n||i?lb(t,e,n,i,r,a):function(t,e,n,i){let r=[];return sb(t,n,e,(function(t,n,a){const{startAngle:s,endAngle:o}=t.getProps(["startAngle","endAngle"],i),{angle:l}=yp(t,{x:e.x,y:e.y});Sp(l,s,o)&&r.push({element:t,datasetIndex:n,index:a})})),r}(t,e,n,r):[]}function ub(t,e,n,i,r){const a=[],s="x"===n?"inXRange":"inYRange";let o=!1;return sb(t,n,e,((t,i,l)=>{t[s]&&t[s](e[n],r)&&(a.push({element:t,datasetIndex:i,index:l}),o=o||t.inRange(e.x,e.y,r))})),i&&!o?[]:a}var db={evaluateInteractionItems:sb,modes:{index(t,e,n,i){const r=nm(e,t),a=n.axis||"x",s=n.includeInvisible||!1,o=n.intersect?ob(t,r,a,i,s):cb(t,r,a,!1,i,s),l=[];return o.length?(t.getSortedVisibleDatasetMetas().forEach((t=>{const e=o[0].index,n=t.data[e];n&&!n.skip&&l.push({element:n,datasetIndex:t.index,index:e})})),l):[]},dataset(t,e,n,i){const r=nm(e,t),a=n.axis||"xy",s=n.includeInvisible||!1;let o=n.intersect?ob(t,r,a,i,s):cb(t,r,a,!1,i,s);if(o.length>0){const e=o[0].datasetIndex,n=t.getDatasetMeta(e).data;o=[];for(let t=0;t<n.length;++t)o.push({element:n[t],datasetIndex:e,index:t})}return o},point:(t,e,n,i)=>ob(t,nm(e,t),n.axis||"xy",i,n.includeInvisible||!1),nearest(t,e,n,i){const r=nm(e,t),a=n.axis||"xy",s=n.includeInvisible||!1;return cb(t,r,a,n.intersect,i,s)},x:(t,e,n,i)=>ub(t,nm(e,t),"x",n.intersect,i),y:(t,e,n,i)=>ub(t,nm(e,t),"y",n.intersect,i)}};const hb=["left","top","right","bottom"];function fb(t,e){return t.filter((t=>t.pos===e))}function pb(t,e){return t.filter((t=>-1===hb.indexOf(t.pos)&&t.box.axis===e))}function gb(t,e){return t.sort(((t,n)=>{const i=e?n:t,r=e?t:n;return i.weight===r.weight?i.index-r.index:i.weight-r.weight}))}function mb(t,e){const n=function(t){const e={};for(const n of t){const{stack:t,pos:i,stackWeight:r}=n;if(!t||!hb.includes(i))continue;const a=e[t]||(e[t]={count:0,placed:0,weight:0,size:0});a.count++,a.weight+=r}return e}(t),{vBoxMaxWidth:i,hBoxMaxHeight:r}=e;let a,s,o;for(a=0,s=t.length;a<s;++a){o=t[a];const{fullSize:s}=o.box,l=n[o.stack],c=l&&o.stackWeight/l.weight;o.horizontal?(o.width=c?c*i:s&&e.availableWidth,o.height=r):(o.width=i,o.height=c?c*r:s&&e.availableHeight)}return n}function bb(t,e,n,i){return Math.max(t[n],e[n])+Math.max(t[i],e[i])}function xb(t,e){t.top=Math.max(t.top,e.top),t.left=Math.max(t.left,e.left),t.bottom=Math.max(t.bottom,e.bottom),t.right=Math.max(t.right,e.right)}function vb(t,e,n,i){const{pos:r,box:a}=n,s=t.maxPadding;if(!Af(r)){n.size&&(t[r]-=n.size);const e=i[n.stack]||{size:0,count:1};e.size=Math.max(e.size,n.horizontal?a.height:a.width),n.size=e.size/e.count,t[r]+=n.size}a.getPadding&&xb(s,a.getPadding());const o=Math.max(0,e.outerWidth-bb(s,t,"left","right")),l=Math.max(0,e.outerHeight-bb(s,t,"top","bottom")),c=o!==t.w,u=l!==t.h;return t.w=o,t.h=l,n.horizontal?{same:c,other:u}:{same:u,other:c}}function yb(t,e){const n=e.maxPadding;function i(t){const i={left:0,top:0,right:0,bottom:0};return t.forEach((t=>{i[t]=Math.max(e[t],n[t])})),i}return i(t?["left","right"]:["top","bottom"])}function _b(t,e,n,i){const r=[];let a,s,o,l,c,u;for(a=0,s=t.length,c=0;a<s;++a){o=t[a],l=o.box,l.update(o.width||e.w,o.height||e.h,yb(o.horizontal,e));const{same:s,other:d}=vb(e,n,o,i);c|=s&&r.length,u=u||d,l.fullSize||r.push(o)}return c&&_b(r,e,n,i)||u}function wb(t,e,n,i,r){t.top=n,t.left=e,t.right=e+i,t.bottom=n+r,t.width=i,t.height=r}function kb(t,e,n,i){const r=n.padding;let{x:a,y:s}=e;for(const o of t){const t=o.box,l=i[o.stack]||{count:1,placed:0,weight:1},c=o.stackWeight/l.weight||1;if(o.horizontal){const i=e.w*c,a=l.size||t.height;tp(l.start)&&(s=l.start),t.fullSize?wb(t,r.left,s,n.outerWidth-r.right-r.left,a):wb(t,e.left+l.placed,s,i,a),l.start=s,l.placed+=i,s=t.bottom}else{const i=e.h*c,s=l.size||t.width;tp(l.start)&&(a=l.start),t.fullSize?wb(t,a,r.top,s,n.outerHeight-r.bottom-r.top):wb(t,a,e.top+l.placed,s,i),l.start=a,l.placed+=i,a=t.right}}e.x=a,e.y=s}var Sb={addBox(t,e){t.boxes||(t.boxes=[]),e.fullSize=e.fullSize||!1,e.position=e.position||"top",e.weight=e.weight||0,e._layers=e._layers||function(){return[{z:0,draw(t){e.draw(t)}}]},t.boxes.push(e)},removeBox(t,e){const n=t.boxes?t.boxes.indexOf(e):-1;-1!==n&&t.boxes.splice(n,1)},configure(t,e,n){e.fullSize=n.fullSize,e.position=n.position,e.weight=n.weight},update(t,e,n,i){if(!t)return;const r=Cg(t.options.layout.padding),a=Math.max(e-r.width,0),s=Math.max(n-r.height,0),o=function(t){const e=function(t){const e=[];let n,i,r,a,s,o;for(n=0,i=(t||[]).length;n<i;++n)r=t[n],({position:a,options:{stack:s,stackWeight:o=1}}=r),e.push({index:n,box:r,pos:a,horizontal:r.isHorizontal(),weight:r.weight,stack:s&&a+s,stackWeight:o});return e}(t),n=gb(e.filter((t=>t.box.fullSize)),!0),i=gb(fb(e,"left"),!0),r=gb(fb(e,"right")),a=gb(fb(e,"top"),!0),s=gb(fb(e,"bottom")),o=pb(e,"x"),l=pb(e,"y");return{fullSize:n,leftAndTop:i.concat(a),rightAndBottom:r.concat(l).concat(s).concat(o),chartArea:fb(e,"chartArea"),vertical:i.concat(r).concat(l),horizontal:a.concat(s).concat(o)}}(t.boxes),l=o.vertical,c=o.horizontal;Hf(t.boxes,(t=>{"function"==typeof t.beforeLayout&&t.beforeLayout()}));const u=l.reduce(((t,e)=>e.box.options&&!1===e.box.options.display?t:t+1),0)||1,d=Object.freeze({outerWidth:e,outerHeight:n,padding:r,availableWidth:a,availableHeight:s,vBoxMaxWidth:a/2/u,hBoxMaxHeight:s/2}),h=Object.assign({},r);xb(h,Cg(i));const f=Object.assign({maxPadding:h,w:a,h:s,x:r.left,y:r.top},r),p=mb(l.concat(c),d);_b(o.fullSize,f,d,p),_b(l,f,d,p),_b(c,f,d,p)&&_b(l,f,d,p),function(t){const e=t.maxPadding;function n(n){const i=Math.max(e[n]-t[n],0);return t[n]+=i,i}t.y+=n("top"),t.x+=n("left"),n("right"),n("bottom")}(f),kb(o.leftAndTop,f,d,p),f.x+=f.w,f.y+=f.h,kb(o.rightAndBottom,f,d,p),t.chartArea={left:f.left,top:f.top,right:f.left+f.w,bottom:f.top+f.h,height:f.h,width:f.w},Hf(o.chartArea,(e=>{const n=e.box;Object.assign(n,t.chartArea),n.update(f.w,f.h,{left:0,top:0,right:0,bottom:0})}))}};class Cb{acquireContext(t,e){}releaseContext(t){return!1}addEventListener(t,e,n){}removeEventListener(t,e,n){}getDevicePixelRatio(){return 1}getMaximumSize(t,e,n,i){return e=Math.max(0,e||t.width),n=n||t.height,{width:e,height:Math.max(0,i?Math.floor(e/i):n)}}isAttached(t){return!0}updateConfig(t){}}class Mb extends Cb{acquireContext(t){return t&&t.getContext&&t.getContext("2d")||null}updateConfig(t){t.options.animation=!1}}const Eb="$chartjs",Pb={touchstart:"mousedown",touchmove:"mousemove",touchend:"mouseup",pointerenter:"mouseenter",pointerdown:"mousedown",pointermove:"mousemove",pointerup:"mouseup",pointerleave:"mouseout",pointerout:"mouseout"},Nb=t=>null===t||""===t;const Db=!!sm&&{passive:!0};function Tb(t,e,n){t&&t.canvas&&t.canvas.removeEventListener(e,n,Db)}function Ob(t,e){for(const n of t)if(n===e||n.contains(e))return!0}function Lb(t,e,n){const i=t.canvas,r=new MutationObserver((t=>{let e=!1;for(const n of t)e=e||Ob(n.addedNodes,i),e=e&&!Ob(n.removedNodes,i);e&&n()}));return r.observe(document,{childList:!0,subtree:!0}),r}function Rb(t,e,n){const i=t.canvas,r=new MutationObserver((t=>{let e=!1;for(const n of t)e=e||Ob(n.removedNodes,i),e=e&&!Ob(n.addedNodes,i);e&&n()}));return r.observe(document,{childList:!0,subtree:!0}),r}const zb=new Map;let jb=0;function Ab(){const t=window.devicePixelRatio;t!==jb&&(jb=t,zb.forEach(((e,n)=>{n.currentDevicePixelRatio!==t&&e()})))}function Fb(t,e,n){const i=t.canvas,r=i&&Gg(i);if(!r)return;const a=Rp(((t,e)=>{const i=r.clientWidth;n(t,e),i<r.clientWidth&&n()}),window),s=new ResizeObserver((t=>{const e=t[0],n=e.contentRect.width,i=e.contentRect.height;0===n&&0===i||a(n,i)}));return s.observe(r),function(t,e){zb.size||window.addEventListener("resize",Ab),zb.set(t,e)}(t,a),s}function Ib(t,e,n){n&&n.disconnect(),"resize"===e&&function(t){zb.delete(t),zb.size||window.removeEventListener("resize",Ab)}(t)}function Vb(t,e,n){const i=t.canvas,r=Rp((e=>{null!==t.ctx&&n(function(t,e){const n=Pb[t.type]||t.type,{x:i,y:r}=nm(t,e);return{type:n,chart:e,native:t,x:void 0!==i?i:null,y:void 0!==r?r:null}}(e,t))}),t);return function(t,e,n){t&&t.addEventListener(e,n,Db)}(i,e,r),r}class Bb extends Cb{acquireContext(t,e){const n=t&&t.getContext&&t.getContext("2d");return n&&n.canvas===t?(function(t,e){const n=t.style,i=t.getAttribute("height"),r=t.getAttribute("width");if(t[Eb]={initial:{height:i,width:r,style:{display:n.display,height:n.height,width:n.width}}},n.display=n.display||"block",n.boxSizing=n.boxSizing||"border-box",Nb(r)){const e=om(t,"width");void 0!==e&&(t.width=e)}if(Nb(i))if(""===t.style.height)t.height=t.width/(e||2);else{const e=om(t,"height");void 0!==e&&(t.height=e)}}(t,e),n):null}releaseContext(t){const e=t.canvas;if(!e[Eb])return!1;const n=e[Eb].initial;["height","width"].forEach((t=>{const i=n[t];zf(i)?e.removeAttribute(t):e.setAttribute(t,i)}));const i=n.style||{};return Object.keys(i).forEach((t=>{e.style[t]=i[t]})),e.width=e.width,delete e[Eb],!0}addEventListener(t,e,n){this.removeEventListener(t,e);const i=t.$proxies||(t.$proxies={}),r={attach:Lb,detach:Rb,resize:Fb}[e]||Vb;i[e]=r(t,e,n)}removeEventListener(t,e){const n=t.$proxies||(t.$proxies={}),i=n[e];if(!i)return;({attach:Ib,detach:Ib,resize:Ib}[e]||Tb)(t,e,i),n[e]=void 0}getDevicePixelRatio(){return window.devicePixelRatio}getMaximumSize(t,e,n,i){return rm(t,e,n,i)}isAttached(t){const e=t&&Gg(t);return!(!e||!e.isConnected)}}class Wb{constructor(){e(this,"x"),e(this,"y"),e(this,"active",!1),e(this,"options"),e(this,"$animations")}tooltipPosition(t){const{x:e,y:n}=this.getProps(["x","y"],t);return{x:e,y:n}}hasValue(){return gp(this.x)&&gp(this.y)}getProps(t,e){const n=this.$animations;if(!e||!n)return this;const i={};return t.forEach((t=>{i[t]=n[t]&&n[t].active()?n[t]._to:this[t]})),i}}function Hb(t,e){const n=t.options.ticks,i=function(t){const e=t.options.offset,n=t._tickSize(),i=t._length/n+(e?0:1),r=t._maxLength/n;return Math.floor(Math.min(i,r))}(t),r=Math.min(n.maxTicksLimit||i,i),a=n.major.enabled?function(t){const e=[];let n,i;for(n=0,i=t.length;n<i;n++)t[n].major&&e.push(n);return e}(e):[],s=a.length,o=a[0],l=a[s-1],c=[];if(s>r)return function(t,e,n,i){let r,a=0,s=n[0];for(i=Math.ceil(i),r=0;r<t.length;r++)r===s&&(e.push(t[r]),a++,s=n[a*i])}(e,c,a,s/r),c;const u=function(t,e,n){const i=function(t){const e=t.length;let n,i;if(e<2)return!1;for(i=t[0],n=1;n<e;++n)if(t[n]-t[n-1]!==i)return!1;return i}(t),r=e.length/n;if(!i)return Math.max(r,1);const a=function(t){const e=[],n=Math.sqrt(t);let i;for(i=1;i<n;i++)t%i==0&&(e.push(i),e.push(t/i));return n===(0|n)&&e.push(n),e.sort(((t,e)=>t-e)).pop(),e}(i);for(let s=0,o=a.length-1;s<o;s++){const t=a[s];if(t>r)return t}return Math.max(r,1)}(a,e,r);if(s>0){let t,n;const i=s>1?Math.round((l-o)/(s-1)):null;for($b(e,c,u,zf(i)?0:o-i,o),t=0,n=s-1;t<n;t++)$b(e,c,u,a[t],a[t+1]);return $b(e,c,u,l,zf(i)?e.length:l+i),c}return $b(e,c,u),c}function $b(t,e,n,i,r){const a=Vf(i,0),s=Math.min(Vf(r,t.length),t.length);let o,l,c,u=0;for(n=Math.ceil(n),r&&(o=r-i,n=o/Math.floor(o/n)),c=a;c<0;)u++,c=Math.round(a+u*n);for(l=Math.max(a,0);l<s;l++)l===c&&(e.push(t[l]),u++,c=Math.round(a+u*n))}e(Wb,"defaults",{}),e(Wb,"defaultRoutes");const Ub=(t,e,n)=>"top"===e||"left"===e?t[e]+n:t[e]-n,Yb=(t,e)=>Math.min(e||t,t);function Qb(t,e){const n=[],i=t.length/e,r=t.length;let a=0;for(;a<r;a+=i)n.push(t[Math.floor(a)]);return n}function qb(t,e,n){const i=t.ticks.length,r=Math.min(e,i-1),a=t._startPixel,s=t._endPixel,o=1e-6;let l,c=t.getPixelForTick(r);if(!(n&&(l=1===i?Math.max(c-a,s-c):0===e?(t.getPixelForTick(1)-c)/2:(c-t.getPixelForTick(r-1))/2,c+=r<e?l:-l,c<a-o||c>s+o)))return c}function Xb(t){return t.drawTicks?t.tickLength:0}function Kb(t,e){if(!t.display)return 0;const n=Mg(t.font,e),i=Cg(t.padding);return(jf(t.text)?t.text.length:1)*n.lineHeight+i.height}function Gb(t,e,n){let i=zp(t);return(n&&"right"!==e||!n&&"right"===e)&&(i=(t=>"left"===t?"right":"right"===t?"left":t)(i)),i}class Jb extends Wb{constructor(t){super(),this.id=t.id,this.type=t.type,this.options=void 0,this.ctx=t.ctx,this.chart=t.chart,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this._margins={left:0,right:0,top:0,bottom:0},this.maxWidth=void 0,this.maxHeight=void 0,this.paddingTop=void 0,this.paddingBottom=void 0,this.paddingLeft=void 0,this.paddingRight=void 0,this.axis=void 0,this.labelRotation=void 0,this.min=void 0,this.max=void 0,this._range=void 0,this.ticks=[],this._gridLineItems=null,this._labelItems=null,this._labelSizes=null,this._length=0,this._maxLength=0,this._longestTextCache={},this._startPixel=void 0,this._endPixel=void 0,this._reversePixels=!1,this._userMax=void 0,this._userMin=void 0,this._suggestedMax=void 0,this._suggestedMin=void 0,this._ticksLength=0,this._borderValue=0,this._cache={},this._dataLimitsCached=!1,this.$context=void 0}init(t){this.options=t.setContext(this.getContext()),this.axis=t.axis,this._userMin=this.parse(t.min),this._userMax=this.parse(t.max),this._suggestedMin=this.parse(t.suggestedMin),this._suggestedMax=this.parse(t.suggestedMax)}parse(t,e){return t}getUserBounds(){let{_userMin:t,_userMax:e,_suggestedMin:n,_suggestedMax:i}=this;return t=If(t,Number.POSITIVE_INFINITY),e=If(e,Number.NEGATIVE_INFINITY),n=If(n,Number.POSITIVE_INFINITY),i=If(i,Number.NEGATIVE_INFINITY),{min:If(t,n),max:If(e,i),minDefined:Ff(t),maxDefined:Ff(e)}}getMinMax(t){let e,{min:n,max:i,minDefined:r,maxDefined:a}=this.getUserBounds();if(r&&a)return{min:n,max:i};const s=this.getMatchingVisibleMetas();for(let o=0,l=s.length;o<l;++o)e=s[o].controller.getMinMax(this,t),r||(n=Math.min(n,e.min)),a||(i=Math.max(i,e.max));return n=a&&n>i?i:n,i=r&&n>i?n:i,{min:If(n,If(i,n)),max:If(i,If(n,i))}}getPadding(){return{left:this.paddingLeft||0,top:this.paddingTop||0,right:this.paddingRight||0,bottom:this.paddingBottom||0}}getTicks(){return this.ticks}getLabels(){const t=this.chart.data;return this.options.labels||(this.isHorizontal()?t.xLabels:t.yLabels)||t.labels||[]}getLabelItems(t=this.chart.chartArea){return this._labelItems||(this._labelItems=this._computeLabelItems(t))}beforeLayout(){this._cache={},this._dataLimitsCached=!1}beforeUpdate(){Wf(this.options.beforeUpdate,[this])}update(t,e,n){const{beginAtZero:i,grace:r,ticks:a}=this.options,s=a.sampleSize;this.beforeUpdate(),this.maxWidth=t,this.maxHeight=e,this._margins=n=Object.assign({left:0,right:0,top:0,bottom:0},n),this.ticks=null,this._labelSizes=null,this._gridLineItems=null,this._labelItems=null,this.beforeSetDimensions(),this.setDimensions(),this.afterSetDimensions(),this._maxLength=this.isHorizontal()?this.width+n.left+n.right:this.height+n.top+n.bottom,this._dataLimitsCached||(this.beforeDataLimits(),this.determineDataLimits(),this.afterDataLimits(),this._range=function(t,e,n){const{min:i,max:r}=t,a=Bf(e,(r-i)/2),s=(t,e)=>n&&0===t?0:t+e;return{min:s(i,-Math.abs(a)),max:s(r,a)}}(this,r,i),this._dataLimitsCached=!0),this.beforeBuildTicks(),this.ticks=this.buildTicks()||[],this.afterBuildTicks();const o=s<this.ticks.length;this._convertTicksToLabels(o?Qb(this.ticks,s):this.ticks),this.configure(),this.beforeCalculateLabelRotation(),this.calculateLabelRotation(),this.afterCalculateLabelRotation(),a.display&&(a.autoSkip||"auto"===a.source)&&(this.ticks=Hb(this,this.ticks),this._labelSizes=null,this.afterAutoSkip()),o&&this._convertTicksToLabels(this.ticks),this.beforeFit(),this.fit(),this.afterFit(),this.afterUpdate()}configure(){let t,e,n=this.options.reverse;this.isHorizontal()?(t=this.left,e=this.right):(t=this.top,e=this.bottom,n=!n),this._startPixel=t,this._endPixel=e,this._reversePixels=n,this._length=e-t,this._alignToPixels=this.options.alignToPixels}afterUpdate(){Wf(this.options.afterUpdate,[this])}beforeSetDimensions(){Wf(this.options.beforeSetDimensions,[this])}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=0,this.right=this.width):(this.height=this.maxHeight,this.top=0,this.bottom=this.height),this.paddingLeft=0,this.paddingTop=0,this.paddingRight=0,this.paddingBottom=0}afterSetDimensions(){Wf(this.options.afterSetDimensions,[this])}_callHooks(t){this.chart.notifyPlugins(t,this.getContext()),Wf(this.options[t],[this])}beforeDataLimits(){this._callHooks("beforeDataLimits")}determineDataLimits(){}afterDataLimits(){this._callHooks("afterDataLimits")}beforeBuildTicks(){this._callHooks("beforeBuildTicks")}buildTicks(){return[]}afterBuildTicks(){this._callHooks("afterBuildTicks")}beforeTickToLabelConversion(){Wf(this.options.beforeTickToLabelConversion,[this])}generateTickLabels(t){const e=this.options.ticks;let n,i,r;for(n=0,i=t.length;n<i;n++)r=t[n],r.label=Wf(e.callback,[r.value,n,t],this)}afterTickToLabelConversion(){Wf(this.options.afterTickToLabelConversion,[this])}beforeCalculateLabelRotation(){Wf(this.options.beforeCalculateLabelRotation,[this])}calculateLabelRotation(){const t=this.options,e=t.ticks,n=Yb(this.ticks.length,t.ticks.maxTicksLimit),i=e.minRotation||0,r=e.maxRotation;let a,s,o,l=i;if(!this._isVisible()||!e.display||i>=r||n<=1||!this.isHorizontal())return void(this.labelRotation=i);const c=this._getLabelSizes(),u=c.widest.width,d=c.highest.height,h=Cp(this.chart.width-u,0,this.maxWidth);a=t.offset?this.maxWidth/n:h/(n-1),u+6>a&&(a=h/(n-(t.offset?.5:1)),s=this.maxHeight-Xb(t.grid)-e.padding-Kb(t.title,this.chart.options.font),o=Math.sqrt(u*u+d*d),l=xp(Math.min(Math.asin(Cp((c.highest.height+6)/a,-1,1)),Math.asin(Cp(s/o,-1,1))-Math.asin(Cp(d/o,-1,1)))),l=Math.max(i,Math.min(r,l))),this.labelRotation=l}afterCalculateLabelRotation(){Wf(this.options.afterCalculateLabelRotation,[this])}afterAutoSkip(){}beforeFit(){Wf(this.options.beforeFit,[this])}fit(){const t={width:0,height:0},{chart:e,options:{ticks:n,title:i,grid:r}}=this,a=this._isVisible(),s=this.isHorizontal();if(a){const a=Kb(i,e.options.font);if(s?(t.width=this.maxWidth,t.height=Xb(r)+a):(t.height=this.maxHeight,t.width=Xb(r)+a),n.display&&this.ticks.length){const{first:e,last:i,widest:r,highest:a}=this._getLabelSizes(),o=2*n.padding,l=bp(this.labelRotation),c=Math.cos(l),u=Math.sin(l);if(s){const e=n.mirror?0:u*r.width+c*a.height;t.height=Math.min(this.maxHeight,t.height+e+o)}else{const e=n.mirror?0:c*r.width+u*a.height;t.width=Math.min(this.maxWidth,t.width+e+o)}this._calculatePadding(e,i,u,c)}}this._handleMargins(),s?(this.width=this._length=e.width-this._margins.left-this._margins.right,this.height=t.height):(this.width=t.width,this.height=this._length=e.height-this._margins.top-this._margins.bottom)}_calculatePadding(t,e,n,i){const{ticks:{align:r,padding:a},position:s}=this.options,o=0!==this.labelRotation,l="top"!==s&&"x"===this.axis;if(this.isHorizontal()){const s=this.getPixelForTick(0)-this.left,c=this.right-this.getPixelForTick(this.ticks.length-1);let u=0,d=0;o?l?(u=i*t.width,d=n*e.height):(u=n*t.height,d=i*e.width):"start"===r?d=e.width:"end"===r?u=t.width:"inner"!==r&&(u=t.width/2,d=e.width/2),this.paddingLeft=Math.max((u-s+a)*this.width/(this.width-s),0),this.paddingRight=Math.max((d-c+a)*this.width/(this.width-c),0)}else{let n=e.height/2,i=t.height/2;"start"===r?(n=0,i=t.height):"end"===r&&(n=e.height,i=0),this.paddingTop=n+a,this.paddingBottom=i+a}}_handleMargins(){this._margins&&(this._margins.left=Math.max(this.paddingLeft,this._margins.left),this._margins.top=Math.max(this.paddingTop,this._margins.top),this._margins.right=Math.max(this.paddingRight,this._margins.right),this._margins.bottom=Math.max(this.paddingBottom,this._margins.bottom))}afterFit(){Wf(this.options.afterFit,[this])}isHorizontal(){const{axis:t,position:e}=this.options;return"top"===e||"bottom"===e||"x"===t}isFullSize(){return this.options.fullSize}_convertTicksToLabels(t){let e,n;for(this.beforeTickToLabelConversion(),this.generateTickLabels(t),e=0,n=t.length;e<n;e++)zf(t[e].label)&&(t.splice(e,1),n--,e--);this.afterTickToLabelConversion()}_getLabelSizes(){let t=this._labelSizes;if(!t){const e=this.options.ticks.sampleSize;let n=this.ticks;e<n.length&&(n=Qb(n,e)),this._labelSizes=t=this._computeLabelSizes(n,n.length,this.options.ticks.maxTicksLimit)}return t}_computeLabelSizes(t,e,n){const{ctx:i,_longestTextCache:r}=this,a=[],s=[],o=Math.floor(e/Yb(e,n));let l,c,u,d,h,f,p,g,m,b,x,v=0,y=0;for(l=0;l<e;l+=o){if(d=t[l].label,h=this._resolveTickFontOptions(l),i.font=f=h.string,p=r[f]=r[f]||{data:{},gc:[]},g=h.lineHeight,m=b=0,zf(d)||jf(d)){if(jf(d))for(c=0,u=d.length;c<u;++c)x=d[c],zf(x)||jf(x)||(m=rg(i,p.data,p.gc,m,x),b+=g)}else m=rg(i,p.data,p.gc,m,d),b=g;a.push(m),s.push(b),v=Math.max(m,v),y=Math.max(b,y)}!function(t,e){Hf(t,(t=>{const n=t.gc,i=n.length/2;let r;if(i>e){for(r=0;r<i;++r)delete t.data[n[r]];n.splice(0,i)}}))}(r,e);const _=a.indexOf(v),w=s.indexOf(y),k=t=>({width:a[t]||0,height:s[t]||0});return{first:k(0),last:k(e-1),widest:k(_),highest:k(w),widths:a,heights:s}}getLabelForValue(t){return t}getPixelForValue(t,e){return NaN}getValueForPixel(t){}getPixelForTick(t){const e=this.ticks;return t<0||t>e.length-1?null:this.getPixelForValue(e[t].value)}getPixelForDecimal(t){this._reversePixels&&(t=1-t);const e=this._startPixel+t*this._length;return Cp(this._alignToPixels?sg(this.chart,e,0):e,-32768,32767)}getDecimalForPixel(t){const e=(t-this._startPixel)/this._length;return this._reversePixels?1-e:e}getBasePixel(){return this.getPixelForValue(this.getBaseValue())}getBaseValue(){const{min:t,max:e}=this;return t<0&&e<0?e:t>0&&e>0?t:0}getContext(t){const e=this.ticks||[];if(t>=0&&t<e.length){const n=e[t];return n.$context||(n.$context=function(t,e,n){return Pg(t,{tick:n,index:e,type:"tick"})}(this.getContext(),t,n))}return this.$context||(this.$context=Pg(this.chart.getContext(),{scale:this,type:"scale"}))}_tickSize(){const t=this.options.ticks,e=bp(this.labelRotation),n=Math.abs(Math.cos(e)),i=Math.abs(Math.sin(e)),r=this._getLabelSizes(),a=t.autoSkipPadding||0,s=r?r.widest.width+a:0,o=r?r.highest.height+a:0;return this.isHorizontal()?o*n>s*i?s/n:o/i:o*i<s*n?o/n:s/i}_isVisible(){const t=this.options.display;return"auto"!==t?!!t:this.getMatchingVisibleMetas().length>0}_computeGridLineItems(t){const e=this.axis,n=this.chart,i=this.options,{grid:r,position:a,border:s}=i,o=r.offset,l=this.isHorizontal(),c=this.ticks.length+(o?1:0),u=Xb(r),d=[],h=s.setContext(this.getContext()),f=h.display?h.width:0,p=f/2,g=function(t){return sg(n,t,f)};let m,b,x,v,y,_,w,k,S,C,M,E;if("top"===a)m=g(this.bottom),_=this.bottom-u,k=m-p,C=g(t.top)+p,E=t.bottom;else if("bottom"===a)m=g(this.top),C=t.top,E=g(t.bottom)-p,_=m+p,k=this.top+u;else if("left"===a)m=g(this.right),y=this.right-u,w=m-p,S=g(t.left)+p,M=t.right;else if("right"===a)m=g(this.left),S=t.left,M=g(t.right)-p,y=m+p,w=this.left+u;else if("x"===e){if("center"===a)m=g((t.top+t.bottom)/2+.5);else if(Af(a)){const t=Object.keys(a)[0],e=a[t];m=g(this.chart.scales[t].getPixelForValue(e))}C=t.top,E=t.bottom,_=m+p,k=_+u}else if("y"===e){if("center"===a)m=g((t.left+t.right)/2);else if(Af(a)){const t=Object.keys(a)[0],e=a[t];m=g(this.chart.scales[t].getPixelForValue(e))}y=m-p,w=y-u,S=t.left,M=t.right}const P=Vf(i.ticks.maxTicksLimit,c),N=Math.max(1,Math.ceil(c/P));for(b=0;b<c;b+=N){const t=this.getContext(b),e=r.setContext(t),i=s.setContext(t),a=e.lineWidth,c=e.color,u=i.dash||[],h=i.dashOffset,f=e.tickWidth,p=e.tickColor,g=e.tickBorderDash||[],m=e.tickBorderDashOffset;x=qb(this,b,o),void 0!==x&&(v=sg(n,x,a),l?y=w=S=M=v:_=k=C=E=v,d.push({tx1:y,ty1:_,tx2:w,ty2:k,x1:S,y1:C,x2:M,y2:E,width:a,color:c,borderDash:u,borderDashOffset:h,tickWidth:f,tickColor:p,tickBorderDash:g,tickBorderDashOffset:m}))}return this._ticksLength=c,this._borderValue=m,d}_computeLabelItems(t){const e=this.axis,n=this.options,{position:i,ticks:r}=n,a=this.isHorizontal(),s=this.ticks,{align:o,crossAlign:l,padding:c,mirror:u}=r,d=Xb(n.grid),h=d+c,f=u?-c:h,p=-bp(this.labelRotation),g=[];let m,b,x,v,y,_,w,k,S,C,M,E,P="middle";if("top"===i)_=this.bottom-f,w=this._getXAxisLabelAlignment();else if("bottom"===i)_=this.top+f,w=this._getXAxisLabelAlignment();else if("left"===i){const t=this._getYAxisLabelAlignment(d);w=t.textAlign,y=t.x}else if("right"===i){const t=this._getYAxisLabelAlignment(d);w=t.textAlign,y=t.x}else if("x"===e){if("center"===i)_=(t.top+t.bottom)/2+h;else if(Af(i)){const t=Object.keys(i)[0],e=i[t];_=this.chart.scales[t].getPixelForValue(e)+h}w=this._getXAxisLabelAlignment()}else if("y"===e){if("center"===i)y=(t.left+t.right)/2-h;else if(Af(i)){const t=Object.keys(i)[0],e=i[t];y=this.chart.scales[t].getPixelForValue(e)}w=this._getYAxisLabelAlignment(d).textAlign}"y"===e&&("start"===o?P="top":"end"===o&&(P="bottom"));const N=this._getLabelSizes();for(m=0,b=s.length;m<b;++m){x=s[m],v=x.label;const t=r.setContext(this.getContext(m));k=this.getPixelForTick(m)+r.labelOffset,S=this._resolveTickFontOptions(m),C=S.lineHeight,M=jf(v)?v.length:1;const e=M/2,n=t.color,o=t.textStrokeColor,c=t.textStrokeWidth;let d,h=w;if(a?(y=k,"inner"===w&&(h=m===b-1?this.options.reverse?"left":"right":0===m?this.options.reverse?"right":"left":"center"),E="top"===i?"near"===l||0!==p?-M*C+C/2:"center"===l?-N.highest.height/2-e*C+C:-N.highest.height+C/2:"near"===l||0!==p?C/2:"center"===l?N.highest.height/2-e*C:N.highest.height-M*C,u&&(E*=-1),0===p||t.showLabelBackdrop||(y+=C/2*Math.sin(p))):(_=k,E=(1-M)*C/2),t.showLabelBackdrop){const e=Cg(t.backdropPadding),n=N.heights[m],i=N.widths[m];let r=E-e.top,a=0-e.left;switch(P){case"middle":r-=n/2;break;case"bottom":r-=n}switch(w){case"center":a-=i/2;break;case"right":a-=i;break;case"inner":m===b-1?a-=i:m>0&&(a-=i/2)}d={left:a,top:r,width:i+e.width,height:n+e.height,color:t.backdropColor}}g.push({label:v,font:S,textOffset:E,options:{rotation:p,color:n,strokeColor:o,strokeWidth:c,textAlign:h,textBaseline:P,translation:[y,_],backdrop:d}})}return g}_getXAxisLabelAlignment(){const{position:t,ticks:e}=this.options;if(-bp(this.labelRotation))return"top"===t?"left":"right";let n="center";return"start"===e.align?n="left":"end"===e.align?n="right":"inner"===e.align&&(n="inner"),n}_getYAxisLabelAlignment(t){const{position:e,ticks:{crossAlign:n,mirror:i,padding:r}}=this.options,a=t+r,s=this._getLabelSizes().widest.width;let o,l;return"left"===e?i?(l=this.right+r,"near"===n?o="left":"center"===n?(o="center",l+=s/2):(o="right",l+=s)):(l=this.right-a,"near"===n?o="right":"center"===n?(o="center",l-=s/2):(o="left",l=this.left)):"right"===e?i?(l=this.left+r,"near"===n?o="right":"center"===n?(o="center",l-=s/2):(o="left",l-=s)):(l=this.left+a,"near"===n?o="left":"center"===n?(o="center",l+=s/2):(o="right",l=this.right)):o="right",{textAlign:o,x:l}}_computeLabelArea(){if(this.options.ticks.mirror)return;const t=this.chart,e=this.options.position;return"left"===e||"right"===e?{top:0,left:this.left,bottom:t.height,right:this.right}:"top"===e||"bottom"===e?{top:this.top,left:0,bottom:this.bottom,right:t.width}:void 0}drawBackground(){const{ctx:t,options:{backgroundColor:e},left:n,top:i,width:r,height:a}=this;e&&(t.save(),t.fillStyle=e,t.fillRect(n,i,r,a),t.restore())}getLineWidthForValue(t){const e=this.options.grid;if(!this._isVisible()||!e.display)return 0;const n=this.ticks.findIndex((e=>e.value===t));if(n>=0){return e.setContext(this.getContext(n)).lineWidth}return 0}drawGrid(t){const e=this.options.grid,n=this.ctx,i=this._gridLineItems||(this._gridLineItems=this._computeGridLineItems(t));let r,a;const s=(t,e,i)=>{i.width&&i.color&&(n.save(),n.lineWidth=i.width,n.strokeStyle=i.color,n.setLineDash(i.borderDash||[]),n.lineDashOffset=i.borderDashOffset,n.beginPath(),n.moveTo(t.x,t.y),n.lineTo(e.x,e.y),n.stroke(),n.restore())};if(e.display)for(r=0,a=i.length;r<a;++r){const t=i[r];e.drawOnChartArea&&s({x:t.x1,y:t.y1},{x:t.x2,y:t.y2},t),e.drawTicks&&s({x:t.tx1,y:t.ty1},{x:t.tx2,y:t.ty2},{color:t.tickColor,width:t.tickWidth,borderDash:t.tickBorderDash,borderDashOffset:t.tickBorderDashOffset})}}drawBorder(){const{chart:t,ctx:e,options:{border:n,grid:i}}=this,r=n.setContext(this.getContext()),a=n.display?r.width:0;if(!a)return;const s=i.setContext(this.getContext(0)).lineWidth,o=this._borderValue;let l,c,u,d;this.isHorizontal()?(l=sg(t,this.left,a)-a/2,c=sg(t,this.right,s)+s/2,u=d=o):(u=sg(t,this.top,a)-a/2,d=sg(t,this.bottom,s)+s/2,l=c=o),e.save(),e.lineWidth=r.width,e.strokeStyle=r.color,e.beginPath(),e.moveTo(l,u),e.lineTo(c,d),e.stroke(),e.restore()}drawLabels(t){if(!this.options.ticks.display)return;const e=this.ctx,n=this._computeLabelArea();n&&dg(e,n);const i=this.getLabelItems(t);for(const r of i){const t=r.options,n=r.font;bg(e,r.label,0,r.textOffset,n,t)}n&&hg(e)}drawTitle(){const{ctx:t,options:{position:e,title:n,reverse:i}}=this;if(!n.display)return;const r=Mg(n.font),a=Cg(n.padding),s=n.align;let o=r.lineHeight/2;"bottom"===e||"center"===e||Af(e)?(o+=a.bottom,jf(n.text)&&(o+=r.lineHeight*(n.text.length-1))):o+=a.top;const{titleX:l,titleY:c,maxWidth:u,rotation:d}=function(t,e,n,i){const{top:r,left:a,bottom:s,right:o,chart:l}=t,{chartArea:c,scales:u}=l;let d,h,f,p=0;const g=s-r,m=o-a;if(t.isHorizontal()){if(h=jp(i,a,o),Af(n)){const t=Object.keys(n)[0],i=n[t];f=u[t].getPixelForValue(i)+g-e}else f="center"===n?(c.bottom+c.top)/2+g-e:Ub(t,n,e);d=o-a}else{if(Af(n)){const t=Object.keys(n)[0],i=n[t];h=u[t].getPixelForValue(i)-m+e}else h="center"===n?(c.left+c.right)/2-m+e:Ub(t,n,e);f=jp(i,s,r),p="left"===n?-lp:lp}return{titleX:h,titleY:f,maxWidth:d,rotation:p}}(this,o,e,s);bg(t,n.text,0,0,r,{color:n.color,maxWidth:u,rotation:d,textAlign:Gb(s,e,i),textBaseline:"middle",translation:[l,c]})}draw(t){this._isVisible()&&(this.drawBackground(),this.drawGrid(t),this.drawBorder(),this.drawTitle(),this.drawLabels(t))}_layers(){const t=this.options,e=t.ticks&&t.ticks.z||0,n=Vf(t.grid&&t.grid.z,-1),i=Vf(t.border&&t.border.z,0);return this._isVisible()&&this.draw===Jb.prototype.draw?[{z:n,draw:t=>{this.drawBackground(),this.drawGrid(t),this.drawTitle()}},{z:i,draw:()=>{this.drawBorder()}},{z:e,draw:t=>{this.drawLabels(t)}}]:[{z:e,draw:t=>{this.draw(t)}}]}getMatchingVisibleMetas(t){const e=this.chart.getSortedVisibleDatasetMetas(),n=this.axis+"AxisID",i=[];let r,a;for(r=0,a=e.length;r<a;++r){const a=e[r];a[n]!==this.id||t&&a.type!==t||i.push(a)}return i}_resolveTickFontOptions(t){return Mg(this.options.ticks.setContext(this.getContext(t)).font)}_maxDigits(){const t=this._resolveTickFontOptions(0).lineHeight;return(this.isHorizontal()?this.width:this.height)/t}}class Zb{constructor(t,e,n){this.type=t,this.scope=e,this.override=n,this.items=Object.create(null)}isForType(t){return Object.prototype.isPrototypeOf.call(this.type.prototype,t.prototype)}register(t){const e=Object.getPrototypeOf(t);let n;(function(t){return"id"in t&&"defaults"in t})(e)&&(n=this.register(e));const i=this.items,r=t.id,a=this.scope+"."+r;if(!r)throw new Error("class does not have id: "+t);return r in i||(i[r]=t,function(t,e,n){const i=qf(Object.create(null),[n?ig.get(n):{},ig.get(e),t.defaults]);ig.set(e,i),t.defaultRoutes&&function(t,e){Object.keys(e).forEach((n=>{const i=n.split("."),r=i.pop(),a=[t].concat(i).join("."),s=e[n].split("."),o=s.pop(),l=s.join(".");ig.route(a,r,l,o)}))}(e,t.defaultRoutes);t.descriptors&&ig.describe(e,t.descriptors)}(t,a,n),this.override&&ig.override(t.id,t.overrides)),a}get(t){return this.items[t]}unregister(t){const e=this.items,n=t.id,i=this.scope;n in e&&delete e[n],i&&n in ig[i]&&(delete ig[i][n],this.override&&delete Jp[n])}}class tx{constructor(){this.controllers=new Zb(Fm,"datasets",!0),this.elements=new Zb(Wb,"elements"),this.plugins=new Zb(Object,"plugins"),this.scales=new Zb(Jb,"scales"),this._typedRegistries=[this.controllers,this.scales,this.elements]}add(...t){this._each("register",t)}remove(...t){this._each("unregister",t)}addControllers(...t){this._each("register",t,this.controllers)}addElements(...t){this._each("register",t,this.elements)}addPlugins(...t){this._each("register",t,this.plugins)}addScales(...t){this._each("register",t,this.scales)}getController(t){return this._get(t,this.controllers,"controller")}getElement(t){return this._get(t,this.elements,"element")}getPlugin(t){return this._get(t,this.plugins,"plugin")}getScale(t){return this._get(t,this.scales,"scale")}removeControllers(...t){this._each("unregister",t,this.controllers)}removeElements(...t){this._each("unregister",t,this.elements)}removePlugins(...t){this._each("unregister",t,this.plugins)}removeScales(...t){this._each("unregister",t,this.scales)}_each(t,e,n){[...e].forEach((e=>{const i=n||this._getRegistryForType(e);n||i.isForType(e)||i===this.plugins&&e.id?this._exec(t,i,e):Hf(e,(e=>{const i=n||this._getRegistryForType(e);this._exec(t,i,e)}))}))}_exec(t,e,n){const i=Zf(t);Wf(n["before"+i],[],n),e[t](n),Wf(n["after"+i],[],n)}_getRegistryForType(t){for(let e=0;e<this._typedRegistries.length;e++){const n=this._typedRegistries[e];if(n.isForType(t))return n}return this.plugins}_get(t,e,n){const i=e.get(t);if(void 0===i)throw new Error('"'+t+'" is not a registered '+n+".");return i}}var ex=new tx;class nx{constructor(){this._init=[]}notify(t,e,n,i){"beforeInit"===e&&(this._init=this._createDescriptors(t,!0),this._notify(this._init,t,"install"));const r=i?this._descriptors(t).filter(i):this._descriptors(t),a=this._notify(r,t,e,n);return"afterDestroy"===e&&(this._notify(r,t,"stop"),this._notify(this._init,t,"uninstall")),a}_notify(t,e,n,i){i=i||{};for(const r of t){const t=r.plugin;if(!1===Wf(t[n],[e,i,r.options],t)&&i.cancelable)return!1}return!0}invalidate(){zf(this._cache)||(this._oldCache=this._cache,this._cache=void 0)}_descriptors(t){if(this._cache)return this._cache;const e=this._cache=this._createDescriptors(t);return this._notifyStateChanges(t),e}_createDescriptors(t,e){const n=t&&t.config,i=Vf(n.options&&n.options.plugins,{}),r=function(t){const e={},n=[],i=Object.keys(ex.plugins.items);for(let a=0;a<i.length;a++)n.push(ex.getPlugin(i[a]));const r=t.plugins||[];for(let a=0;a<r.length;a++){const t=r[a];-1===n.indexOf(t)&&(n.push(t),e[t.id]=!0)}return{plugins:n,localIds:e}}(n);return!1!==i||e?function(t,{plugins:e,localIds:n},i,r){const a=[],s=t.getContext();for(const o of e){const e=o.id,l=ix(i[e],r);null!==l&&a.push({plugin:o,options:rx(t.config,{plugin:o,local:n[e]},l,s)})}return a}(t,r,i,e):[]}_notifyStateChanges(t){const e=this._oldCache||[],n=this._cache,i=(t,e)=>t.filter((t=>!e.some((e=>t.plugin.id===e.plugin.id))));this._notify(i(e,n),t,"stop"),this._notify(i(n,e),t,"start")}}function ix(t,e){return e||!1!==t?!0===t?{}:t:null}function rx(t,{plugin:e,local:n},i,r){const a=t.pluginScopeKeys(e),s=t.getOptionScopes(i,a);return n&&e.defaults&&s.push(e.defaults),t.createResolver(s,r,[""],{scriptable:!1,indexable:!1,allKeys:!0})}function ax(t,e){const n=ig.datasets[t]||{};return((e.datasets||{})[t]||{}).indexAxis||e.indexAxis||n.indexAxis||"x"}function sx(t){if("x"===t||"y"===t||"r"===t)return t}function ox(t,...e){if(sx(t))return t;for(const i of e){const e=i.axis||("top"===(n=i.position)||"bottom"===n?"x":"left"===n||"right"===n?"y":void 0)||t.length>1&&sx(t[0].toLowerCase());if(e)return e}var n;throw new Error(`Cannot determine type of '${t}' axis. Please provide 'axis' or 'position' option.`)}function lx(t,e,n){if(n[e+"AxisID"]===t)return{axis:e}}function cx(t,e){const n=Jp[t.type]||{scales:{}},i=e.scales||{},r=ax(t.type,e),a=Object.create(null);return Object.keys(i).forEach((e=>{const s=i[e];if(!Af(s))return console.error(`Invalid scale configuration for scale: ${e}`);if(s._proxy)return console.warn(`Ignoring resolver passed as options for scale: ${e}`);const o=ox(e,s,function(t,e){if(e.data&&e.data.datasets){const n=e.data.datasets.filter((e=>e.xAxisID===t||e.yAxisID===t));if(n.length)return lx(t,"x",n[0])||lx(t,"y",n[0])}return{}}(e,t),ig.scales[s.type]),l=function(t,e){return t===e?"_index_":"_value_"}(o,r),c=n.scales||{};a[e]=Xf(Object.create(null),[{axis:o},s,c[o],c[l]])})),t.data.datasets.forEach((n=>{const r=n.type||t.type,s=n.indexAxis||ax(r,e),o=(Jp[r]||{}).scales||{};Object.keys(o).forEach((t=>{const e=function(t,e){let n=t;return"_index_"===t?n=e:"_value_"===t&&(n="x"===e?"y":"x"),n}(t,s),r=n[e+"AxisID"]||e;a[r]=a[r]||Object.create(null),Xf(a[r],[{axis:e},i[r],o[t]])}))})),Object.keys(a).forEach((t=>{const e=a[t];Xf(e,[ig.scales[e.type],ig.scale])})),a}function ux(t){const e=t.options||(t.options={});e.plugins=Vf(e.plugins,{}),e.scales=cx(t,e)}function dx(t){return(t=t||{}).datasets=t.datasets||[],t.labels=t.labels||[],t}const hx=new Map,fx=new Set;function px(t,e){let n=hx.get(t);return n||(n=e(),hx.set(t,n),fx.add(n)),n}const gx=(t,e,n)=>{const i=Jf(e,n);void 0!==i&&t.add(i)};class mx{constructor(t){this._config=function(t){return(t=t||{}).data=dx(t.data),ux(t),t}(t),this._scopeCache=new Map,this._resolverCache=new Map}get platform(){return this._config.platform}get type(){return this._config.type}set type(t){this._config.type=t}get data(){return this._config.data}set data(t){this._config.data=dx(t)}get options(){return this._config.options}set options(t){this._config.options=t}get plugins(){return this._config.plugins}update(){const t=this._config;this.clearCache(),ux(t)}clearCache(){this._scopeCache.clear(),this._resolverCache.clear()}datasetScopeKeys(t){return px(t,(()=>[[`datasets.${t}`,""]]))}datasetAnimationScopeKeys(t,e){return px(`${t}.transition.${e}`,(()=>[[`datasets.${t}.transitions.${e}`,`transitions.${e}`],[`datasets.${t}`,""]]))}datasetElementScopeKeys(t,e){return px(`${t}-${e}`,(()=>[[`datasets.${t}.elements.${e}`,`datasets.${t}`,`elements.${e}`,""]]))}pluginScopeKeys(t){const e=t.id;return px(`${this.type}-plugin-${e}`,(()=>[[`plugins.${e}`,...t.additionalOptionScopes||[]]]))}_cachedScopes(t,e){const n=this._scopeCache;let i=n.get(t);return i&&!e||(i=new Map,n.set(t,i)),i}getOptionScopes(t,e,n){const{options:i,type:r}=this,a=this._cachedScopes(t,n),s=a.get(e);if(s)return s;const o=new Set;e.forEach((e=>{t&&(o.add(t),e.forEach((e=>gx(o,t,e)))),e.forEach((t=>gx(o,i,t))),e.forEach((t=>gx(o,Jp[r]||{},t))),e.forEach((t=>gx(o,ig,t))),e.forEach((t=>gx(o,Zp,t)))}));const l=Array.from(o);return 0===l.length&&l.push(Object.create(null)),fx.has(e)&&a.set(e,l),l}chartOptionScopes(){const{options:t,type:e}=this;return[t,Jp[e]||{},ig.datasets[e]||{},{type:e},ig,Zp]}resolveNamedOptions(t,e,n,i=[""]){const r={$shared:!0},{resolver:a,subPrefixes:s}=bx(this._resolverCache,t,i);let o=a;if(function(t,e){const{isScriptable:n,isIndexable:i}=Tg(t);for(const r of e){const e=n(r),a=i(r),s=(a||e)&&t[r];if(e&&(ep(s)||xx(s))||a&&jf(s))return!0}return!1}(a,e)){r.$shared=!1;o=Dg(a,n=ep(n)?n():n,this.createResolver(t,n,s))}for(const l of e)r[l]=o[l];return r}createResolver(t,e,n=[""],i){const{resolver:r}=bx(this._resolverCache,t,n);return Af(e)?Dg(r,e,void 0,i):r}}function bx(t,e,n){let i=t.get(e);i||(i=new Map,t.set(e,i));const r=n.join();let a=i.get(r);if(!a){a={resolver:Ng(e,n),subPrefixes:n.filter((t=>!t.toLowerCase().includes("hover")))},i.set(r,a)}return a}const xx=t=>Af(t)&&Object.getOwnPropertyNames(t).some((e=>ep(t[e])));const vx=["top","bottom","left","right","chartArea"];function yx(t,e){return"top"===t||"bottom"===t||-1===vx.indexOf(t)&&"x"===e}function _x(t,e){return function(n,i){return n[t]===i[t]?n[e]-i[e]:n[t]-i[t]}}function wx(t){const e=t.chart,n=e.options.animation;e.notifyPlugins("afterRender"),Wf(n&&n.onComplete,[t],e)}function kx(t){const e=t.chart,n=e.options.animation;Wf(n&&n.onProgress,[t],e)}function Sx(t){return Kg()&&"string"==typeof t?t=document.getElementById(t):t&&t.length&&(t=t[0]),t&&t.canvas&&(t=t.canvas),t}const Cx={},Mx=t=>{const e=Sx(t);return Object.values(Cx).filter((t=>t.canvas===e)).pop()};function Ex(t,e,n){const i=Object.keys(t);for(const r of i){const i=+r;if(i>=e){const a=t[r];delete t[r],(n>0||i>e)&&(t[i+n]=a)}}}function Px(t,e,n){return t.options.clip?t[n]:e[n]}class Nx{static register(...t){ex.add(...t),Dx()}static unregister(...t){ex.remove(...t),Dx()}constructor(t,e){const n=this.config=new mx(e),i=Sx(t),r=Mx(i);if(r)throw new Error("Canvas is already in use. Chart with ID '"+r.id+"' must be destroyed before the canvas with ID '"+r.canvas.id+"' can be reused.");const a=n.createResolver(n.chartOptionScopes(),this.getContext());this.platform=new(n.platform||function(t){return!Kg()||"undefined"!=typeof OffscreenCanvas&&t instanceof OffscreenCanvas?Mb:Bb}(i)),this.platform.updateConfig(n);const s=this.platform.acquireContext(i,a.aspectRatio),o=s&&s.canvas,l=o&&o.height,c=o&&o.width;this.id=Rf(),this.ctx=s,this.canvas=o,this.width=c,this.height=l,this._options=a,this._aspectRatio=this.aspectRatio,this._layers=[],this._metasets=[],this._stacks=void 0,this.boxes=[],this.currentDevicePixelRatio=void 0,this.chartArea=void 0,this._active=[],this._lastEvent=void 0,this._listeners={},this._responsiveListeners=void 0,this._sortedMetasets=[],this.scales={},this._plugins=new nx,this.$proxies={},this._hiddenIndices={},this.attached=!1,this._animationsDisabled=void 0,this.$context=void 0,this._doResize=function(t,e){let n;return function(...i){return e?(clearTimeout(n),n=setTimeout(t,e,i)):t.apply(this,i),e}}((t=>this.update(t)),a.resizeDelay||0),this._dataChanges=[],Cx[this.id]=this,s&&o?(wm.listen(this,"complete",wx),wm.listen(this,"progress",kx),this._initialize(),this.attached&&this.update()):console.error("Failed to create chart: can't acquire context from the given item")}get aspectRatio(){const{options:{aspectRatio:t,maintainAspectRatio:e},width:n,height:i,_aspectRatio:r}=this;return zf(t)?e&&r?r:i?n/i:null:t}get data(){return this.config.data}set data(t){this.config.data=t}get options(){return this._options}set options(t){this.config.options=t}get registry(){return ex}_initialize(){return this.notifyPlugins("beforeInit"),this.options.responsive?this.resize():am(this,this.options.devicePixelRatio),this.bindEvents(),this.notifyPlugins("afterInit"),this}clear(){return og(this.canvas,this.ctx),this}stop(){return wm.stop(this),this}resize(t,e){wm.running(this)?this._resizeBeforeDraw={width:t,height:e}:this._resize(t,e)}_resize(t,e){const n=this.options,i=this.canvas,r=n.maintainAspectRatio&&this.aspectRatio,a=this.platform.getMaximumSize(i,t,e,r),s=n.devicePixelRatio||this.platform.getDevicePixelRatio(),o=this.width?"resize":"attach";this.width=a.width,this.height=a.height,this._aspectRatio=this.aspectRatio,am(this,s,!0)&&(this.notifyPlugins("resize",{size:a}),Wf(n.onResize,[this,a],this),this.attached&&this._doResize(o)&&this.render())}ensureScalesHaveIDs(){Hf(this.options.scales||{},((t,e)=>{t.id=e}))}buildOrUpdateScales(){const t=this.options,e=t.scales,n=this.scales,i=Object.keys(n).reduce(((t,e)=>(t[e]=!1,t)),{});let r=[];e&&(r=r.concat(Object.keys(e).map((t=>{const n=e[t],i=ox(t,n),r="r"===i,a="x"===i;return{options:n,dposition:r?"chartArea":a?"bottom":"left",dtype:r?"radialLinear":a?"category":"linear"}})))),Hf(r,(e=>{const r=e.options,a=r.id,s=ox(a,r),o=Vf(r.type,e.dtype);void 0!==r.position&&yx(r.position,s)===yx(e.dposition)||(r.position=e.dposition),i[a]=!0;let l=null;if(a in n&&n[a].type===o)l=n[a];else{l=new(ex.getScale(o))({id:a,type:o,ctx:this.ctx,chart:this}),n[l.id]=l}l.init(r,t)})),Hf(i,((t,e)=>{t||delete n[e]})),Hf(n,(t=>{Sb.configure(this,t,t.options),Sb.addBox(this,t)}))}_updateMetasets(){const t=this._metasets,e=this.data.datasets.length,n=t.length;if(t.sort(((t,e)=>t.index-e.index)),n>e){for(let t=e;t<n;++t)this._destroyDatasetMeta(t);t.splice(e,n-e)}this._sortedMetasets=t.slice(0).sort(_x("order","index"))}_removeUnreferencedMetasets(){const{_metasets:t,data:{datasets:e}}=this;t.length>e.length&&delete this._stacks,t.forEach(((t,n)=>{0===e.filter((e=>e===t._dataset)).length&&this._destroyDatasetMeta(n)}))}buildOrUpdateControllers(){const t=[],e=this.data.datasets;let n,i;for(this._removeUnreferencedMetasets(),n=0,i=e.length;n<i;n++){const i=e[n];let r=this.getDatasetMeta(n);const a=i.type||this.config.type;if(r.type&&r.type!==a&&(this._destroyDatasetMeta(n),r=this.getDatasetMeta(n)),r.type=a,r.indexAxis=i.indexAxis||ax(a,this.options),r.order=i.order||0,r.index=n,r.label=""+i.label,r.visible=this.isDatasetVisible(n),r.controller)r.controller.updateIndex(n),r.controller.linkScales();else{const e=ex.getController(a),{datasetElementType:i,dataElementType:s}=ig.datasets[a];Object.assign(e,{dataElementType:ex.getElement(s),datasetElementType:i&&ex.getElement(i)}),r.controller=new e(this,n),t.push(r.controller)}}return this._updateMetasets(),t}_resetElements(){Hf(this.data.datasets,((t,e)=>{this.getDatasetMeta(e).controller.reset()}),this)}reset(){this._resetElements(),this.notifyPlugins("reset")}update(t){const e=this.config;e.update();const n=this._options=e.createResolver(e.chartOptionScopes(),this.getContext()),i=this._animationsDisabled=!n.animation;if(this._updateScales(),this._checkEventBindings(),this._updateHiddenIndices(),this._plugins.invalidate(),!1===this.notifyPlugins("beforeUpdate",{mode:t,cancelable:!0}))return;const r=this.buildOrUpdateControllers();this.notifyPlugins("beforeElementsUpdate");let a=0;for(let l=0,c=this.data.datasets.length;l<c;l++){const{controller:t}=this.getDatasetMeta(l),e=!i&&-1===r.indexOf(t);t.buildOrUpdateElements(e),a=Math.max(+t.getMaxOverflow(),a)}a=this._minPadding=n.layout.autoPadding?a:0,this._updateLayout(a),i||Hf(r,(t=>{t.reset()})),this._updateDatasets(t),this.notifyPlugins("afterUpdate",{mode:t}),this._layers.sort(_x("z","_idx"));const{_active:s,_lastEvent:o}=this;o?this._eventHandler(o,!0):s.length&&this._updateHoverStyles(s,s,!0),this.render()}_updateScales(){Hf(this.scales,(t=>{Sb.removeBox(this,t)})),this.ensureScalesHaveIDs(),this.buildOrUpdateScales()}_checkEventBindings(){const t=this.options,e=new Set(Object.keys(this._listeners)),n=new Set(t.events);np(e,n)&&!!this._responsiveListeners===t.responsive||(this.unbindEvents(),this.bindEvents())}_updateHiddenIndices(){const{_hiddenIndices:t}=this,e=this._getUniformDataChanges()||[];for(const{method:n,start:i,count:r}of e){Ex(t,i,"_removeElements"===n?-r:r)}}_getUniformDataChanges(){const t=this._dataChanges;if(!t||!t.length)return;this._dataChanges=[];const e=this.data.datasets.length,n=e=>new Set(t.filter((t=>t[0]===e)).map(((t,e)=>e+","+t.splice(1).join(",")))),i=n(0);for(let r=1;r<e;r++)if(!np(i,n(r)))return;return Array.from(i).map((t=>t.split(","))).map((t=>({method:t[1],start:+t[2],count:+t[3]})))}_updateLayout(t){if(!1===this.notifyPlugins("beforeLayout",{cancelable:!0}))return;Sb.update(this,this.width,this.height,t);const e=this.chartArea,n=e.width<=0||e.height<=0;this._layers=[],Hf(this.boxes,(t=>{n&&"chartArea"===t.position||(t.configure&&t.configure(),this._layers.push(...t._layers()))}),this),this._layers.forEach(((t,e)=>{t._idx=e})),this.notifyPlugins("afterLayout")}_updateDatasets(t){if(!1!==this.notifyPlugins("beforeDatasetsUpdate",{mode:t,cancelable:!0})){for(let t=0,e=this.data.datasets.length;t<e;++t)this.getDatasetMeta(t).controller.configure();for(let e=0,n=this.data.datasets.length;e<n;++e)this._updateDataset(e,ep(t)?t({datasetIndex:e}):t);this.notifyPlugins("afterDatasetsUpdate",{mode:t})}}_updateDataset(t,e){const n=this.getDatasetMeta(t),i={meta:n,index:t,mode:e,cancelable:!0};!1!==this.notifyPlugins("beforeDatasetUpdate",i)&&(n.controller._update(e),i.cancelable=!1,this.notifyPlugins("afterDatasetUpdate",i))}render(){!1!==this.notifyPlugins("beforeRender",{cancelable:!0})&&(wm.has(this)?this.attached&&!wm.running(this)&&wm.start(this):(this.draw(),wx({chart:this})))}draw(){let t;if(this._resizeBeforeDraw){const{width:t,height:e}=this._resizeBeforeDraw;this._resizeBeforeDraw=null,this._resize(t,e)}if(this.clear(),this.width<=0||this.height<=0)return;if(!1===this.notifyPlugins("beforeDraw",{cancelable:!0}))return;const e=this._layers;for(t=0;t<e.length&&e[t].z<=0;++t)e[t].draw(this.chartArea);for(this._drawDatasets();t<e.length;++t)e[t].draw(this.chartArea);this.notifyPlugins("afterDraw")}_getSortedDatasetMetas(t){const e=this._sortedMetasets,n=[];let i,r;for(i=0,r=e.length;i<r;++i){const r=e[i];t&&!r.visible||n.push(r)}return n}getSortedVisibleDatasetMetas(){return this._getSortedDatasetMetas(!0)}_drawDatasets(){if(!1===this.notifyPlugins("beforeDatasetsDraw",{cancelable:!0}))return;const t=this.getSortedVisibleDatasetMetas();for(let e=t.length-1;e>=0;--e)this._drawDataset(t[e]);this.notifyPlugins("afterDatasetsDraw")}_drawDataset(t){const e=this.ctx,n=t._clip,i=!n.disabled,r=function(t,e){const{xScale:n,yScale:i}=t;return n&&i?{left:Px(n,e,"left"),right:Px(n,e,"right"),top:Px(i,e,"top"),bottom:Px(i,e,"bottom")}:e}(t,this.chartArea),a={meta:t,index:t.index,cancelable:!0};!1!==this.notifyPlugins("beforeDatasetDraw",a)&&(i&&dg(e,{left:!1===n.left?0:r.left-n.left,right:!1===n.right?this.width:r.right+n.right,top:!1===n.top?0:r.top-n.top,bottom:!1===n.bottom?this.height:r.bottom+n.bottom}),t.controller.draw(),i&&hg(e),a.cancelable=!1,this.notifyPlugins("afterDatasetDraw",a))}isPointInArea(t){return ug(t,this.chartArea,this._minPadding)}getElementsAtEventForMode(t,e,n,i){const r=db.modes[e];return"function"==typeof r?r(this,t,n,i):[]}getDatasetMeta(t){const e=this.data.datasets[t],n=this._metasets;let i=n.filter((t=>t&&t._dataset===e)).pop();return i||(i={type:null,data:[],dataset:null,controller:null,hidden:null,xAxisID:null,yAxisID:null,order:e&&e.order||0,index:t,_dataset:e,_parsed:[],_sorted:!1},n.push(i)),i}getContext(){return this.$context||(this.$context=Pg(null,{chart:this,type:"chart"}))}getVisibleDatasetCount(){return this.getSortedVisibleDatasetMetas().length}isDatasetVisible(t){const e=this.data.datasets[t];if(!e)return!1;const n=this.getDatasetMeta(t);return"boolean"==typeof n.hidden?!n.hidden:!e.hidden}setDatasetVisibility(t,e){this.getDatasetMeta(t).hidden=!e}toggleDataVisibility(t){this._hiddenIndices[t]=!this._hiddenIndices[t]}getDataVisibility(t){return!this._hiddenIndices[t]}_updateVisibility(t,e,n){const i=n?"show":"hide",r=this.getDatasetMeta(t),a=r.controller._resolveAnimations(void 0,i);tp(e)?(r.data[e].hidden=!n,this.update()):(this.setDatasetVisibility(t,n),a.update(r,{visible:n}),this.update((e=>e.datasetIndex===t?i:void 0)))}hide(t,e){this._updateVisibility(t,e,!1)}show(t,e){this._updateVisibility(t,e,!0)}_destroyDatasetMeta(t){const e=this._metasets[t];e&&e.controller&&e.controller._destroy(),delete this._metasets[t]}_stop(){let t,e;for(this.stop(),wm.remove(this),t=0,e=this.data.datasets.length;t<e;++t)this._destroyDatasetMeta(t)}destroy(){this.notifyPlugins("beforeDestroy");const{canvas:t,ctx:e}=this;this._stop(),this.config.clearCache(),t&&(this.unbindEvents(),og(t,e),this.platform.releaseContext(e),this.canvas=null,this.ctx=null),delete Cx[this.id],this.notifyPlugins("afterDestroy")}toBase64Image(...t){return this.canvas.toDataURL(...t)}bindEvents(){this.bindUserEvents(),this.options.responsive?this.bindResponsiveEvents():this.attached=!0}bindUserEvents(){const t=this._listeners,e=this.platform,n=(n,i)=>{e.addEventListener(this,n,i),t[n]=i},i=(t,e,n)=>{t.offsetX=e,t.offsetY=n,this._eventHandler(t)};Hf(this.options.events,(t=>n(t,i)))}bindResponsiveEvents(){this._responsiveListeners||(this._responsiveListeners={});const t=this._responsiveListeners,e=this.platform,n=(n,i)=>{e.addEventListener(this,n,i),t[n]=i},i=(n,i)=>{t[n]&&(e.removeEventListener(this,n,i),delete t[n])},r=(t,e)=>{this.canvas&&this.resize(t,e)};let a;const s=()=>{i("attach",s),this.attached=!0,this.resize(),n("resize",r),n("detach",a)};a=()=>{this.attached=!1,i("resize",r),this._stop(),this._resize(0,0),n("attach",s)},e.isAttached(this.canvas)?s():a()}unbindEvents(){Hf(this._listeners,((t,e)=>{this.platform.removeEventListener(this,e,t)})),this._listeners={},Hf(this._responsiveListeners,((t,e)=>{this.platform.removeEventListener(this,e,t)})),this._responsiveListeners=void 0}updateHoverStyle(t,e,n){const i=n?"set":"remove";let r,a,s,o;for("dataset"===e&&(r=this.getDatasetMeta(t[0].datasetIndex),r.controller["_"+i+"DatasetHoverStyle"]()),s=0,o=t.length;s<o;++s){a=t[s];const e=a&&this.getDatasetMeta(a.datasetIndex).controller;e&&e[i+"HoverStyle"](a.element,a.datasetIndex,a.index)}}getActiveElements(){return this._active||[]}setActiveElements(t){const e=this._active||[],n=t.map((({datasetIndex:t,index:e})=>{const n=this.getDatasetMeta(t);if(!n)throw new Error("No dataset found at index "+t);return{datasetIndex:t,element:n.data[e],index:e}}));!$f(n,e)&&(this._active=n,this._lastEvent=null,this._updateHoverStyles(n,e))}notifyPlugins(t,e,n){return this._plugins.notify(this,t,e,n)}isPluginEnabled(t){return 1===this._plugins._cache.filter((e=>e.plugin.id===t)).length}_updateHoverStyles(t,e,n){const i=this.options.hover,r=(t,e)=>t.filter((t=>!e.some((e=>t.datasetIndex===e.datasetIndex&&t.index===e.index)))),a=r(e,t),s=n?t:r(t,e);a.length&&this.updateHoverStyle(a,i.mode,!1),s.length&&i.mode&&this.updateHoverStyle(s,i.mode,!0)}_eventHandler(t,e){const n={event:t,replay:e,cancelable:!0,inChartArea:this.isPointInArea(t)},i=e=>(e.options.events||this.options.events).includes(t.native.type);if(!1===this.notifyPlugins("beforeEvent",n,i))return;const r=this._handleEvent(t,e,n.inChartArea);return n.cancelable=!1,this.notifyPlugins("afterEvent",n,i),(r||n.changed)&&this.render(),this}_handleEvent(t,e,n){const{_active:i=[],options:r}=this,a=e,s=this._getActiveElements(t,i,n,a),o=function(t){return"mouseup"===t.type||"click"===t.type||"contextmenu"===t.type}(t),l=function(t,e,n,i){return n&&"mouseout"!==t.type?i?e:t:null}(t,this._lastEvent,n,o);n&&(this._lastEvent=null,Wf(r.onHover,[t,s,this],this),o&&Wf(r.onClick,[t,s,this],this));const c=!$f(s,i);return(c||e)&&(this._active=s,this._updateHoverStyles(s,i,e)),this._lastEvent=l,c}_getActiveElements(t,e,n,i){if("mouseout"===t.type)return[];if(!n)return e;const r=this.options.hover;return this.getElementsAtEventForMode(t,r.mode,r,i)}}function Dx(){return Hf(Nx.instances,(t=>t._plugins.invalidate()))}function Tx(t,e,n,i){const r=wg(t.options.borderRadius,["outerStart","outerEnd","innerStart","innerEnd"]);const a=(n-e)/2,s=Math.min(a,i*e/2),o=t=>{const e=(n-Math.min(a,t))*i/2;return Cp(t,0,Math.min(a,e))};return{outerStart:o(r.outerStart),outerEnd:o(r.outerEnd),innerStart:Cp(r.innerStart,0,s),innerEnd:Cp(r.innerEnd,0,s)}}function Ox(t,e,n,i){return{x:n+t*Math.cos(e),y:i+t*Math.sin(e)}}function Lx(t,e,n,i,r,a){const{x:s,y:o,startAngle:l,pixelMargin:c,innerRadius:u}=e,d=Math.max(e.outerRadius+i+n-c,0),h=u>0?u+i+n+c:0;let f=0;const p=r-l;if(i){const t=((u>0?u-i:0)+(d>0?d-i:0))/2;f=(p-(0!==t?p*t/(t+i):p))/2}const g=(p-Math.max(.001,p*d-n/ip)/d)/2,m=l+g+f,b=r-g-f,{outerStart:x,outerEnd:v,innerStart:y,innerEnd:_}=Tx(e,h,d,b-m),w=d-x,k=d-v,S=m+x/w,C=b-v/k,M=h+y,E=h+_,P=m+y/M,N=b-_/E;if(t.beginPath(),a){const e=(S+C)/2;if(t.arc(s,o,d,S,e),t.arc(s,o,d,e,C),v>0){const e=Ox(k,C,s,o);t.arc(e.x,e.y,v,C,b+lp)}const n=Ox(E,b,s,o);if(t.lineTo(n.x,n.y),_>0){const e=Ox(E,N,s,o);t.arc(e.x,e.y,_,b+lp,N+Math.PI)}const i=(b-_/h+(m+y/h))/2;if(t.arc(s,o,h,b-_/h,i,!0),t.arc(s,o,h,i,m+y/h,!0),y>0){const e=Ox(M,P,s,o);t.arc(e.x,e.y,y,P+Math.PI,m-lp)}const r=Ox(w,m,s,o);if(t.lineTo(r.x,r.y),x>0){const e=Ox(w,S,s,o);t.arc(e.x,e.y,x,m-lp,S)}}else{t.moveTo(s,o);const e=Math.cos(S)*d+s,n=Math.sin(S)*d+o;t.lineTo(e,n);const i=Math.cos(C)*d+s,r=Math.sin(C)*d+o;t.lineTo(i,r)}t.closePath()}function Rx(t,e,n,i,r){const{fullCircles:a,startAngle:s,circumference:o,options:l}=e,{borderWidth:c,borderJoinStyle:u,borderDash:d,borderDashOffset:h}=l,f="inner"===l.borderAlign;if(!c)return;t.setLineDash(d||[]),t.lineDashOffset=h,f?(t.lineWidth=2*c,t.lineJoin=u||"round"):(t.lineWidth=c,t.lineJoin=u||"bevel");let p=e.endAngle;if(a){Lx(t,e,n,i,p,r);for(let e=0;e<a;++e)t.stroke();isNaN(o)||(p=s+(o%rp||rp))}f&&function(t,e,n){const{startAngle:i,pixelMargin:r,x:a,y:s,outerRadius:o,innerRadius:l}=e;let c=r/o;t.beginPath(),t.arc(a,s,o,i-c,n+c),l>r?(c=r/l,t.arc(a,s,l,n+c,i-c,!0)):t.arc(a,s,r,n+lp,i-lp),t.closePath(),t.clip()}(t,e,p),a||(Lx(t,e,n,i,p,r),t.stroke())}e(Nx,"defaults",ig),e(Nx,"instances",Cx),e(Nx,"overrides",Jp),e(Nx,"registry",ex),e(Nx,"version","4.4.8"),e(Nx,"getChart",Mx);class zx extends Wb{constructor(t){super(),e(this,"circumference"),e(this,"endAngle"),e(this,"fullCircles"),e(this,"innerRadius"),e(this,"outerRadius"),e(this,"pixelMargin"),e(this,"startAngle"),this.options=void 0,this.circumference=void 0,this.startAngle=void 0,this.endAngle=void 0,this.innerRadius=void 0,this.outerRadius=void 0,this.pixelMargin=0,this.fullCircles=0,t&&Object.assign(this,t)}inRange(t,e,n){const i=this.getProps(["x","y"],n),{angle:r,distance:a}=yp(i,{x:t,y:e}),{startAngle:s,endAngle:o,innerRadius:l,outerRadius:c,circumference:u}=this.getProps(["startAngle","endAngle","innerRadius","outerRadius","circumference"],n),d=(this.options.spacing+this.options.borderWidth)/2,h=Vf(u,o-s),f=Sp(r,s,o)&&s!==o,p=h>=rp||f,g=Mp(a,l+d,c+d);return p&&g}getCenterPoint(t){const{x:e,y:n,startAngle:i,endAngle:r,innerRadius:a,outerRadius:s}=this.getProps(["x","y","startAngle","endAngle","innerRadius","outerRadius"],t),{offset:o,spacing:l}=this.options,c=(i+r)/2,u=(a+s+l+o)/2;return{x:e+Math.cos(c)*u,y:n+Math.sin(c)*u}}tooltipPosition(t){return this.getCenterPoint(t)}draw(t){const{options:e,circumference:n}=this,i=(e.offset||0)/4,r=(e.spacing||0)/2,a=e.circular;if(this.pixelMargin="inner"===e.borderAlign?.33:0,this.fullCircles=n>rp?Math.floor(n/rp):0,0===n||this.innerRadius<0||this.outerRadius<0)return;t.save();const s=(this.startAngle+this.endAngle)/2;t.translate(Math.cos(s)*i,Math.sin(s)*i);const o=i*(1-Math.sin(Math.min(ip,n||0)));t.fillStyle=e.backgroundColor,t.strokeStyle=e.borderColor,function(t,e,n,i,r){const{fullCircles:a,startAngle:s,circumference:o}=e;let l=e.endAngle;if(a){Lx(t,e,n,i,l,r);for(let e=0;e<a;++e)t.fill();isNaN(o)||(l=s+(o%rp||rp))}Lx(t,e,n,i,l,r),t.fill()}(t,this,o,r,a),Rx(t,this,o,r,a),t.restore()}}function jx(t,e,n=e){t.lineCap=Vf(n.borderCapStyle,e.borderCapStyle),t.setLineDash(Vf(n.borderDash,e.borderDash)),t.lineDashOffset=Vf(n.borderDashOffset,e.borderDashOffset),t.lineJoin=Vf(n.borderJoinStyle,e.borderJoinStyle),t.lineWidth=Vf(n.borderWidth,e.borderWidth),t.strokeStyle=Vf(n.borderColor,e.borderColor)}function Ax(t,e,n){t.lineTo(n.x,n.y)}function Fx(t,e,n={}){const i=t.length,{start:r=0,end:a=i-1}=n,{start:s,end:o}=e,l=Math.max(r,s),c=Math.min(a,o),u=r<s&&a<s||r>o&&a>o;return{count:i,start:l,loop:e.loop,ilen:c<l&&!u?i+c-l:c-l}}function Ix(t,e,n,i){const{points:r,options:a}=e,{count:s,start:o,loop:l,ilen:c}=Fx(r,n,i),u=function(t){return t.stepped?fg:t.tension||"monotone"===t.cubicInterpolationMode?pg:Ax}(a);let d,h,f,{move:p=!0,reverse:g}=i||{};for(d=0;d<=c;++d)h=r[(o+(g?c-d:d))%s],h.skip||(p?(t.moveTo(h.x,h.y),p=!1):u(t,f,h,g,a.stepped),f=h);return l&&(h=r[(o+(g?c:0))%s],u(t,f,h,g,a.stepped)),!!l}function Vx(t,e,n,i){const r=e.points,{count:a,start:s,ilen:o}=Fx(r,n,i),{move:l=!0,reverse:c}=i||{};let u,d,h,f,p,g,m=0,b=0;const x=t=>(s+(c?o-t:t))%a,v=()=>{f!==p&&(t.lineTo(m,p),t.lineTo(m,f),t.lineTo(m,g))};for(l&&(d=r[x(0)],t.moveTo(d.x,d.y)),u=0;u<=o;++u){if(d=r[x(u)],d.skip)continue;const e=d.x,n=d.y,i=0|e;i===h?(n<f?f=n:n>p&&(p=n),m=(b*m+e)/++b):(v(),t.lineTo(e,n),h=i,b=0,f=p=n),g=n}v()}function Bx(t){const e=t.options,n=e.borderDash&&e.borderDash.length;return!(t._decimated||t._loop||e.tension||"monotone"===e.cubicInterpolationMode||e.stepped||n)?Vx:Ix}e(zx,"id","arc"),e(zx,"defaults",{borderAlign:"center",borderColor:"#fff",borderDash:[],borderDashOffset:0,borderJoinStyle:void 0,borderRadius:0,borderWidth:2,offset:0,spacing:0,angle:void 0,circular:!0}),e(zx,"defaultRoutes",{backgroundColor:"backgroundColor"}),e(zx,"descriptors",{_scriptable:!0,_indexable:t=>"borderDash"!==t});const Wx="function"==typeof Path2D;function Hx(t,e,n,i){Wx&&!e.options.segment?function(t,e,n,i){let r=e._path;r||(r=e._path=new Path2D,e.path(r,n,i)&&r.closePath()),jx(t,e.options),t.stroke(r)}(t,e,n,i):function(t,e,n,i){const{segments:r,options:a}=e,s=Bx(e);for(const o of r)jx(t,a,o.style),t.beginPath(),s(t,e,o,{start:n,end:n+i-1})&&t.closePath(),t.stroke()}(t,e,n,i)}class $x extends Wb{constructor(t){super(),this.animated=!0,this.options=void 0,this._chart=void 0,this._loop=void 0,this._fullLoop=void 0,this._path=void 0,this._points=void 0,this._segments=void 0,this._decimated=!1,this._pointsUpdated=!1,this._datasetIndex=void 0,t&&Object.assign(this,t)}updateControlPoints(t,e){const n=this.options;if((n.tension||"monotone"===n.cubicInterpolationMode)&&!n.stepped&&!this._pointsUpdated){const i=n.spanGaps?this._loop:this._fullLoop;Xg(this._points,n,t,i,e),this._pointsUpdated=!0}}set points(t){this._points=t,delete this._segments,delete this._path,this._pointsUpdated=!1}get points(){return this._points}get segments(){return this._segments||(this._segments=function(t,e){const n=t.points,i=t.options.spanGaps,r=n.length;if(!r)return[];const a=!!t._loop,{start:s,end:o}=function(t,e,n,i){let r=0,a=e-1;if(n&&!i)for(;r<e&&!t[r].skip;)r++;for(;r<e&&t[r].skip;)r++;for(r%=e,n&&(a+=r);a>r&&t[a%e].skip;)a--;return a%=e,{start:r,end:a}}(n,r,a,i);return xm(t,!0===i?[{start:s,end:o,loop:a}]:function(t,e,n,i){const r=t.length,a=[];let s,o=e,l=t[e];for(s=e+1;s<=n;++s){const n=t[s%r];n.skip||n.stop?l.skip||(i=!1,a.push({start:e%r,end:(s-1)%r,loop:i}),e=o=n.stop?s:null):(o=s,l.skip&&(e=s)),l=n}return null!==o&&a.push({start:e%r,end:o%r,loop:i}),a}(n,s,o<s?o+r:o,!!t._fullLoop&&0===s&&o===r-1),n,e)}(this,this.options.segment))}first(){const t=this.segments,e=this.points;return t.length&&e[t[0].start]}last(){const t=this.segments,e=this.points,n=t.length;return n&&e[t[n-1].end]}interpolate(t,e){const n=this.options,i=t[e],r=this.points,a=bm(this,{property:e,start:i,end:i});if(!a.length)return;const s=[],o=function(t){return t.stepped?cm:t.tension||"monotone"===t.cubicInterpolationMode?um:lm}(n);let l,c;for(l=0,c=a.length;l<c;++l){const{start:c,end:u}=a[l],d=r[c],h=r[u];if(d===h){s.push(d);continue}const f=o(d,h,Math.abs((i-d[e])/(h[e]-d[e])),n.stepped);f[e]=t[e],s.push(f)}return 1===s.length?s[0]:s}pathSegment(t,e,n){return Bx(this)(t,this,e,n)}path(t,e,n){const i=this.segments,r=Bx(this);let a=this._loop;e=e||0,n=n||this.points.length-e;for(const s of i)a&=r(t,this,s,{start:e,end:e+n-1});return!!a}draw(t,e,n,i){const r=this.options||{};(this.points||[]).length&&r.borderWidth&&(t.save(),Hx(t,this,n,i),t.restore()),this.animated&&(this._pointsUpdated=!1,this._path=void 0)}}function Ux(t,e,n,i){const r=t.options,{[n]:a}=t.getProps([n],i);return Math.abs(e-a)<r.radius+r.hitRadius}e($x,"id","line"),e($x,"defaults",{borderCapStyle:"butt",borderDash:[],borderDashOffset:0,borderJoinStyle:"miter",borderWidth:3,capBezierPoints:!0,cubicInterpolationMode:"default",fill:!1,spanGaps:!1,stepped:!1,tension:0}),e($x,"defaultRoutes",{backgroundColor:"backgroundColor",borderColor:"borderColor"}),e($x,"descriptors",{_scriptable:!0,_indexable:t=>"borderDash"!==t&&"fill"!==t});class Yx extends Wb{constructor(t){super(),e(this,"parsed"),e(this,"skip"),e(this,"stop"),this.options=void 0,this.parsed=void 0,this.skip=void 0,this.stop=void 0,t&&Object.assign(this,t)}inRange(t,e,n){const i=this.options,{x:r,y:a}=this.getProps(["x","y"],n);return Math.pow(t-r,2)+Math.pow(e-a,2)<Math.pow(i.hitRadius+i.radius,2)}inXRange(t,e){return Ux(this,t,"x",e)}inYRange(t,e){return Ux(this,t,"y",e)}getCenterPoint(t){const{x:e,y:n}=this.getProps(["x","y"],t);return{x:e,y:n}}size(t){let e=(t=t||this.options||{}).radius||0;e=Math.max(e,e&&t.hoverRadius||0);return 2*(e+(e&&t.borderWidth||0))}draw(t,e){const n=this.options;this.skip||n.radius<.1||!ug(this,e,this.size(n)/2)||(t.strokeStyle=n.borderColor,t.lineWidth=n.borderWidth,t.fillStyle=n.backgroundColor,lg(t,n,this.x,this.y))}getRange(){const t=this.options||{};return t.radius+t.hitRadius}}function Qx(t,e){const{x:n,y:i,base:r,width:a,height:s}=t.getProps(["x","y","base","width","height"],e);let o,l,c,u,d;return t.horizontal?(d=s/2,o=Math.min(n,r),l=Math.max(n,r),c=i-d,u=i+d):(d=a/2,o=n-d,l=n+d,c=Math.min(i,r),u=Math.max(i,r)),{left:o,top:c,right:l,bottom:u}}function qx(t,e,n,i){return t?0:Cp(e,n,i)}function Xx(t){const e=Qx(t),n=e.right-e.left,i=e.bottom-e.top,r=function(t,e,n){const i=t.options.borderWidth,r=t.borderSkipped,a=kg(i);return{t:qx(r.top,a.top,0,n),r:qx(r.right,a.right,0,e),b:qx(r.bottom,a.bottom,0,n),l:qx(r.left,a.left,0,e)}}(t,n/2,i/2),a=function(t,e,n){const{enableBorderRadius:i}=t.getProps(["enableBorderRadius"]),r=t.options.borderRadius,a=Sg(r),s=Math.min(e,n),o=t.borderSkipped,l=i||Af(r);return{topLeft:qx(!l||o.top||o.left,a.topLeft,0,s),topRight:qx(!l||o.top||o.right,a.topRight,0,s),bottomLeft:qx(!l||o.bottom||o.left,a.bottomLeft,0,s),bottomRight:qx(!l||o.bottom||o.right,a.bottomRight,0,s)}}(t,n/2,i/2);return{outer:{x:e.left,y:e.top,w:n,h:i,radius:a},inner:{x:e.left+r.l,y:e.top+r.t,w:n-r.l-r.r,h:i-r.t-r.b,radius:{topLeft:Math.max(0,a.topLeft-Math.max(r.t,r.l)),topRight:Math.max(0,a.topRight-Math.max(r.t,r.r)),bottomLeft:Math.max(0,a.bottomLeft-Math.max(r.b,r.l)),bottomRight:Math.max(0,a.bottomRight-Math.max(r.b,r.r))}}}}function Kx(t,e,n,i){const r=null===e,a=null===n,s=t&&!(r&&a)&&Qx(t,i);return s&&(r||Mp(e,s.left,s.right))&&(a||Mp(n,s.top,s.bottom))}function Gx(t,e){t.rect(e.x,e.y,e.w,e.h)}function Jx(t,e,n={}){const i=t.x!==n.x?-e:0,r=t.y!==n.y?-e:0,a=(t.x+t.w!==n.x+n.w?e:0)-i,s=(t.y+t.h!==n.y+n.h?e:0)-r;return{x:t.x+i,y:t.y+r,w:t.w+a,h:t.h+s,radius:t.radius}}e(Yx,"id","point"),e(Yx,"defaults",{borderWidth:1,hitRadius:1,hoverBorderWidth:1,hoverRadius:4,pointStyle:"circle",radius:3,rotation:0}),e(Yx,"defaultRoutes",{backgroundColor:"backgroundColor",borderColor:"borderColor"});class Zx extends Wb{constructor(t){super(),this.options=void 0,this.horizontal=void 0,this.base=void 0,this.width=void 0,this.height=void 0,this.inflateAmount=void 0,t&&Object.assign(this,t)}draw(t){const{inflateAmount:e,options:{borderColor:n,backgroundColor:i}}=this,{inner:r,outer:a}=Xx(this),s=(o=a.radius).topLeft||o.topRight||o.bottomLeft||o.bottomRight?xg:Gx;var o;t.save(),a.w===r.w&&a.h===r.h||(t.beginPath(),s(t,Jx(a,e,r)),t.clip(),s(t,Jx(r,-e,a)),t.fillStyle=n,t.fill("evenodd")),t.beginPath(),s(t,Jx(r,e)),t.fillStyle=i,t.fill(),t.restore()}inRange(t,e,n){return Kx(this,t,e,n)}inXRange(t,e){return Kx(this,t,null,e)}inYRange(t,e){return Kx(this,null,t,e)}getCenterPoint(t){const{x:e,y:n,base:i,horizontal:r}=this.getProps(["x","y","base","horizontal"],t);return{x:r?(e+i)/2:e,y:r?n:(n+i)/2}}getRange(t){return"x"===t?this.width/2:this.height/2}}e(Zx,"id","bar"),e(Zx,"defaults",{borderSkipped:"start",borderWidth:0,borderRadius:0,inflateAmount:"auto",pointStyle:void 0}),e(Zx,"defaultRoutes",{backgroundColor:"backgroundColor",borderColor:"borderColor"});var tv=Object.freeze({__proto__:null,ArcElement:zx,BarElement:Zx,LineElement:$x,PointElement:Yx});const ev=["rgb(54, 162, 235)","rgb(255, 99, 132)","rgb(255, 159, 64)","rgb(255, 205, 86)","rgb(75, 192, 192)","rgb(153, 102, 255)","rgb(201, 203, 207)"],nv=ev.map((t=>t.replace("rgb(","rgba(").replace(")",", 0.5)")));function iv(t){return ev[t%ev.length]}function rv(t){return nv[t%nv.length]}function av(t){let e=0;return(n,i)=>{const r=t.getDatasetMeta(i).controller;r instanceof Xm?e=function(t,e){return t.backgroundColor=t.data.map((()=>iv(e++))),e}(n,e):r instanceof Gm?e=function(t,e){return t.backgroundColor=t.data.map((()=>rv(e++))),e}(n,e):r&&(e=function(t,e){return t.borderColor=iv(e),t.backgroundColor=rv(e),++e}(n,e))}}function sv(t){let e;for(e in t)if(t[e].borderColor||t[e].backgroundColor)return!0;return!1}var ov={id:"colors",defaults:{enabled:!0,forceOverride:!1},beforeLayout(t,e,n){if(!n.enabled)return;const{data:{datasets:i},options:r}=t.config,{elements:a}=r,s=sv(i)||(o=r)&&(o.borderColor||o.backgroundColor)||a&&sv(a)||"rgba(0,0,0,0.1)"!==ig.borderColor||"rgba(0,0,0,0.1)"!==ig.backgroundColor;var o;if(!n.forceOverride&&s)return;const l=av(t);i.forEach(l)}};function lv(t){if(t._decimated){const e=t._data;delete t._decimated,delete t._data,Object.defineProperty(t,"data",{configurable:!0,enumerable:!0,writable:!0,value:e})}}function cv(t){t.data.datasets.forEach((t=>{lv(t)}))}var uv={id:"decimation",defaults:{algorithm:"min-max",enabled:!1},beforeElementsUpdate:(t,e,n)=>{if(!n.enabled)return void cv(t);const i=t.width;t.data.datasets.forEach(((e,r)=>{const{_data:a,indexAxis:s}=e,o=t.getDatasetMeta(r),l=a||e.data;if("y"===Eg([s,t.options.indexAxis]))return;if(!o.controller.supportsDecimation)return;const c=t.scales[o.xAxisID];if("linear"!==c.type&&"time"!==c.type)return;if(t.options.parsing)return;let{start:u,count:d}=function(t,e){const n=e.length;let i,r=0;const{iScale:a}=t,{min:s,max:o,minDefined:l,maxDefined:c}=a.getUserBounds();return l&&(r=Cp(Pp(e,a.axis,s).lo,0,n-1)),i=c?Cp(Pp(e,a.axis,o).hi+1,r,n)-r:n-r,{start:r,count:i}}(o,l);if(d<=(n.threshold||4*i))return void lv(e);let h;switch(zf(a)&&(e._data=l,delete e.data,Object.defineProperty(e,"data",{configurable:!0,enumerable:!0,get:function(){return this._decimated},set:function(t){this._data=t}})),n.algorithm){case"lttb":h=function(t,e,n,i,r){const a=r.samples||i;if(a>=n)return t.slice(e,e+n);const s=[],o=(n-2)/(a-2);let l=0;const c=e+n-1;let u,d,h,f,p,g=e;for(s[l++]=t[g],u=0;u<a-2;u++){let i,r=0,a=0;const c=Math.floor((u+1)*o)+1+e,m=Math.min(Math.floor((u+2)*o)+1,n)+e,b=m-c;for(i=c;i<m;i++)r+=t[i].x,a+=t[i].y;r/=b,a/=b;const x=Math.floor(u*o)+1+e,v=Math.min(Math.floor((u+1)*o)+1,n)+e,{x:y,y:_}=t[g];for(h=f=-1,i=x;i<v;i++)f=.5*Math.abs((y-r)*(t[i].y-_)-(y-t[i].x)*(a-_)),f>h&&(h=f,d=t[i],p=i);s[l++]=d,g=p}return s[l++]=t[c],s}(l,u,d,i,n);break;case"min-max":h=function(t,e,n,i){let r,a,s,o,l,c,u,d,h,f,p=0,g=0;const m=[],b=e+n-1,x=t[e].x,v=t[b].x-x;for(r=e;r<e+n;++r){a=t[r],s=(a.x-x)/v*i,o=a.y;const e=0|s;if(e===l)o<h?(h=o,c=r):o>f&&(f=o,u=r),p=(g*p+a.x)/++g;else{const n=r-1;if(!zf(c)&&!zf(u)){const e=Math.min(c,u),i=Math.max(c,u);e!==d&&e!==n&&m.push({...t[e],x:p}),i!==d&&i!==n&&m.push({...t[i],x:p})}r>0&&n!==d&&m.push(t[n]),m.push(a),l=e,g=0,h=f=o,c=u=d=r}}return m}(l,u,d,i);break;default:throw new Error(`Unsupported decimation algorithm '${n.algorithm}'`)}e._decimated=h}))},destroy(t){cv(t)}};function dv(t,e,n,i){if(i)return;let r=e[t],a=n[t];return"angle"===t&&(r=kp(r),a=kp(a)),{property:t,start:r,end:a}}function hv(t,e,n){for(;e>t;e--){const t=n[e];if(!isNaN(t.x)&&!isNaN(t.y))break}return e}function fv(t,e,n,i){return t&&e?i(t[n],e[n]):t?t[n]:e?e[n]:0}function pv(t,e){let n=[],i=!1;return jf(t)?(i=!0,n=t):n=function(t,e){const{x:n=null,y:i=null}=t||{},r=e.points,a=[];return e.segments.forEach((({start:t,end:e})=>{e=hv(t,e,r);const s=r[t],o=r[e];null!==i?(a.push({x:s.x,y:i}),a.push({x:o.x,y:i})):null!==n&&(a.push({x:n,y:s.y}),a.push({x:n,y:o.y}))})),a}(t,e),n.length?new $x({points:n,options:{tension:0},_loop:i,_fullLoop:i}):null}function gv(t){return t&&!1!==t.fill}function mv(t,e,n){let i=t[e].fill;const r=[e];let a;if(!n)return i;for(;!1!==i&&-1===r.indexOf(i);){if(!Ff(i))return i;if(a=t[i],!a)return!1;if(a.visible)return i;r.push(i),i=a.fill}return!1}function bv(t,e,n){const i=function(t){const e=t.options,n=e.fill;let i=Vf(n&&n.target,n);void 0===i&&(i=!!e.backgroundColor);if(!1===i||null===i)return!1;if(!0===i)return"origin";return i}(t);if(Af(i))return!isNaN(i.value)&&i;let r=parseFloat(i);return Ff(r)&&Math.floor(r)===r?function(t,e,n,i){"-"!==t&&"+"!==t||(n=e+n);if(n===e||n<0||n>=i)return!1;return n}(i[0],e,r,n):["origin","start","end","stack","shape"].indexOf(i)>=0&&i}function xv(t,e,n){const i=[];for(let r=0;r<n.length;r++){const a=n[r],{first:s,last:o,point:l}=vv(a,e,"x");if(!(!l||s&&o))if(s)i.unshift(l);else if(t.push(l),!o)break}t.push(...i)}function vv(t,e,n){const i=t.interpolate(e,n);if(!i)return{};const r=i[n],a=t.segments,s=t.points;let o=!1,l=!1;for(let c=0;c<a.length;c++){const t=a[c],e=s[t.start][n],i=s[t.end][n];if(Mp(r,e,i)){o=r===e,l=r===i;break}}return{first:o,last:l,point:i}}class yv{constructor(t){this.x=t.x,this.y=t.y,this.radius=t.radius}pathSegment(t,e,n){const{x:i,y:r,radius:a}=this;return e=e||{start:0,end:rp},t.arc(i,r,a,e.end,e.start,!0),!n.bounds}interpolate(t){const{x:e,y:n,radius:i}=this,r=t.angle;return{x:e+Math.cos(r)*i,y:n+Math.sin(r)*i,angle:r}}}function _v(t){const{chart:e,fill:n,line:i}=t;if(Ff(n))return function(t,e){const n=t.getDatasetMeta(e),i=n&&t.isDatasetVisible(e);return i?n.dataset:null}(e,n);if("stack"===n)return function(t){const{scale:e,index:n,line:i}=t,r=[],a=i.segments,s=i.points,o=function(t,e){const n=[],i=t.getMatchingVisibleMetas("line");for(let r=0;r<i.length;r++){const t=i[r];if(t.index===e)break;t.hidden||n.unshift(t.dataset)}return n}(e,n);o.push(pv({x:null,y:e.bottom},i));for(let l=0;l<a.length;l++){const t=a[l];for(let e=t.start;e<=t.end;e++)xv(r,s[e],o)}return new $x({points:r,options:{}})}(t);if("shape"===n)return!0;const r=function(t){const e=t.scale||{};if(e.getPointPositionForValue)return function(t){const{scale:e,fill:n}=t,i=e.options,r=e.getLabels().length,a=i.reverse?e.max:e.min,s=function(t,e,n){let i;return i="start"===t?n:"end"===t?e.options.reverse?e.min:e.max:Af(t)?t.value:e.getBaseValue(),i}(n,e,a),o=[];if(i.grid.circular){const t=e.getPointPositionForValue(0,a);return new yv({x:t.x,y:t.y,radius:e.getDistanceFromCenterForValue(s)})}for(let l=0;l<r;++l)o.push(e.getPointPositionForValue(l,s));return o}(t);return function(t){const{scale:e={},fill:n}=t,i=function(t,e){let n=null;return"start"===t?n=e.bottom:"end"===t?n=e.top:Af(t)?n=e.getPixelForValue(t.value):e.getBasePixel&&(n=e.getBasePixel()),n}(n,e);if(Ff(i)){const t=e.isHorizontal();return{x:t?i:null,y:t?null:i}}return null}(t)}(t);return r instanceof yv?r:pv(r,i)}function wv(t,e,n){const i=_v(e),{line:r,scale:a,axis:s}=e,o=r.options,l=o.fill,c=o.backgroundColor,{above:u=c,below:d=c}=l||{};i&&r.points.length&&(dg(t,n),function(t,e){const{line:n,target:i,above:r,below:a,area:s,scale:o}=e,l=n._loop?"angle":e.axis;t.save(),"x"===l&&a!==r&&(kv(t,i,s.top),Sv(t,{line:n,target:i,color:r,scale:o,property:l}),t.restore(),t.save(),kv(t,i,s.bottom));Sv(t,{line:n,target:i,color:a,scale:o,property:l}),t.restore()}(t,{line:r,target:i,above:u,below:d,area:n,scale:a,axis:s}),hg(t))}function kv(t,e,n){const{segments:i,points:r}=e;let a=!0,s=!1;t.beginPath();for(const o of i){const{start:i,end:l}=o,c=r[i],u=r[hv(i,l,r)];a?(t.moveTo(c.x,c.y),a=!1):(t.lineTo(c.x,n),t.lineTo(c.x,c.y)),s=!!e.pathSegment(t,o,{move:s}),s?t.closePath():t.lineTo(u.x,n)}t.lineTo(e.first().x,n),t.closePath(),t.clip()}function Sv(t,e){const{line:n,target:i,property:r,color:a,scale:s}=e,o=function(t,e,n){const i=t.segments,r=t.points,a=e.points,s=[];for(const o of i){let{start:t,end:i}=o;i=hv(t,i,r);const l=dv(n,r[t],r[i],o.loop);if(!e.segments){s.push({source:o,target:l,start:r[t],end:r[i]});continue}const c=bm(e,l);for(const e of c){const t=dv(n,a[e.start],a[e.end],e.loop),i=mm(o,r,t);for(const r of i)s.push({source:r,target:e,start:{[n]:fv(l,t,"start",Math.max)},end:{[n]:fv(l,t,"end",Math.min)}})}}return s}(n,i,r);for(const{source:l,target:c,start:u,end:d}of o){const{style:{backgroundColor:e=a}={}}=l,o=!0!==i;t.save(),t.fillStyle=e,Cv(t,s,o&&dv(r,u,d)),t.beginPath();const h=!!n.pathSegment(t,l);let f;if(o){h?t.closePath():Mv(t,i,d,r);const e=!!i.pathSegment(t,c,{move:h,reverse:!0});f=h&&e,f||Mv(t,i,u,r)}t.closePath(),t.fill(f?"evenodd":"nonzero"),t.restore()}}function Cv(t,e,n){const{top:i,bottom:r}=e.chart.chartArea,{property:a,start:s,end:o}=n||{};"x"===a&&(t.beginPath(),t.rect(s,i,o-s,r-i),t.clip())}function Mv(t,e,n,i){const r=e.interpolate(n,i);r&&t.lineTo(r.x,r.y)}var Ev={id:"filler",afterDatasetsUpdate(t,e,n){const i=(t.data.datasets||[]).length,r=[];let a,s,o,l;for(s=0;s<i;++s)a=t.getDatasetMeta(s),o=a.dataset,l=null,o&&o.options&&o instanceof $x&&(l={visible:t.isDatasetVisible(s),index:s,fill:bv(o,s,i),chart:t,axis:a.controller.options.indexAxis,scale:a.vScale,line:o}),a.$filler=l,r.push(l);for(s=0;s<i;++s)l=r[s],l&&!1!==l.fill&&(l.fill=mv(r,s,n.propagate))},beforeDraw(t,e,n){const i="beforeDraw"===n.drawTime,r=t.getSortedVisibleDatasetMetas(),a=t.chartArea;for(let s=r.length-1;s>=0;--s){const e=r[s].$filler;e&&(e.line.updateControlPoints(a,e.axis),i&&e.fill&&wv(t.ctx,e,a))}},beforeDatasetsDraw(t,e,n){if("beforeDatasetsDraw"!==n.drawTime)return;const i=t.getSortedVisibleDatasetMetas();for(let r=i.length-1;r>=0;--r){const e=i[r].$filler;gv(e)&&wv(t.ctx,e,t.chartArea)}},beforeDatasetDraw(t,e,n){const i=e.meta.$filler;gv(i)&&"beforeDatasetDraw"===n.drawTime&&wv(t.ctx,i,t.chartArea)},defaults:{propagate:!0,drawTime:"beforeDatasetDraw"}};const Pv=(t,e)=>{let{boxHeight:n=e,boxWidth:i=e}=t;return t.usePointStyle&&(n=Math.min(n,e),i=t.pointStyleWidth||Math.min(i,e)),{boxWidth:i,boxHeight:n,itemHeight:Math.max(e,n)}};class Nv extends Wb{constructor(t){super(),this._added=!1,this.legendHitBoxes=[],this._hoveredItem=null,this.doughnutMode=!1,this.chart=t.chart,this.options=t.options,this.ctx=t.ctx,this.legendItems=void 0,this.columnSizes=void 0,this.lineWidths=void 0,this.maxHeight=void 0,this.maxWidth=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.height=void 0,this.width=void 0,this._margins=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(t,e,n){this.maxWidth=t,this.maxHeight=e,this._margins=n,this.setDimensions(),this.buildLabels(),this.fit()}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=this._margins.left,this.right=this.width):(this.height=this.maxHeight,this.top=this._margins.top,this.bottom=this.height)}buildLabels(){const t=this.options.labels||{};let e=Wf(t.generateLabels,[this.chart],this)||[];t.filter&&(e=e.filter((e=>t.filter(e,this.chart.data)))),t.sort&&(e=e.sort(((e,n)=>t.sort(e,n,this.chart.data)))),this.options.reverse&&e.reverse(),this.legendItems=e}fit(){const{options:t,ctx:e}=this;if(!t.display)return void(this.width=this.height=0);const n=t.labels,i=Mg(n.font),r=i.size,a=this._computeTitleHeight(),{boxWidth:s,itemHeight:o}=Pv(n,r);let l,c;e.font=i.string,this.isHorizontal()?(l=this.maxWidth,c=this._fitRows(a,r,s,o)+10):(c=this.maxHeight,l=this._fitCols(a,i,s,o)+10),this.width=Math.min(l,t.maxWidth||this.maxWidth),this.height=Math.min(c,t.maxHeight||this.maxHeight)}_fitRows(t,e,n,i){const{ctx:r,maxWidth:a,options:{labels:{padding:s}}}=this,o=this.legendHitBoxes=[],l=this.lineWidths=[0],c=i+s;let u=t;r.textAlign="left",r.textBaseline="middle";let d=-1,h=-c;return this.legendItems.forEach(((t,f)=>{const p=n+e/2+r.measureText(t.text).width;(0===f||l[l.length-1]+p+2*s>a)&&(u+=c,l[l.length-(f>0?0:1)]=0,h+=c,d++),o[f]={left:0,top:h,row:d,width:p,height:i},l[l.length-1]+=p+s})),u}_fitCols(t,e,n,i){const{ctx:r,maxHeight:a,options:{labels:{padding:s}}}=this,o=this.legendHitBoxes=[],l=this.columnSizes=[],c=a-t;let u=s,d=0,h=0,f=0,p=0;return this.legendItems.forEach(((t,a)=>{const{itemWidth:g,itemHeight:m}=function(t,e,n,i,r){const a=function(t,e,n,i){let r=t.text;r&&"string"!=typeof r&&(r=r.reduce(((t,e)=>t.length>e.length?t:e)));return e+n.size/2+i.measureText(r).width}(i,t,e,n),s=function(t,e,n){let i=t;"string"!=typeof e.text&&(i=Dv(e,n));return i}(r,i,e.lineHeight);return{itemWidth:a,itemHeight:s}}(n,e,r,t,i);a>0&&h+m+2*s>c&&(u+=d+s,l.push({width:d,height:h}),f+=d+s,p++,d=h=0),o[a]={left:f,top:h,col:p,width:g,height:m},d=Math.max(d,g),h+=m+s})),u+=d,l.push({width:d,height:h}),u}adjustHitBoxes(){if(!this.options.display)return;const t=this._computeTitleHeight(),{legendHitBoxes:e,options:{align:n,labels:{padding:i},rtl:r}}=this,a=dm(r,this.left,this.width);if(this.isHorizontal()){let r=0,s=jp(n,this.left+i,this.right-this.lineWidths[r]);for(const o of e)r!==o.row&&(r=o.row,s=jp(n,this.left+i,this.right-this.lineWidths[r])),o.top+=this.top+t+i,o.left=a.leftForLtr(a.x(s),o.width),s+=o.width+i}else{let r=0,s=jp(n,this.top+t+i,this.bottom-this.columnSizes[r].height);for(const o of e)o.col!==r&&(r=o.col,s=jp(n,this.top+t+i,this.bottom-this.columnSizes[r].height)),o.top=s,o.left+=this.left+i,o.left=a.leftForLtr(a.x(o.left),o.width),s+=o.height+i}}isHorizontal(){return"top"===this.options.position||"bottom"===this.options.position}draw(){if(this.options.display){const t=this.ctx;dg(t,this),this._draw(),hg(t)}}_draw(){const{options:t,columnSizes:e,lineWidths:n,ctx:i}=this,{align:r,labels:a}=t,s=ig.color,o=dm(t.rtl,this.left,this.width),l=Mg(a.font),{padding:c}=a,u=l.size,d=u/2;let h;this.drawTitle(),i.textAlign=o.textAlign("left"),i.textBaseline="middle",i.lineWidth=.5,i.font=l.string;const{boxWidth:f,boxHeight:p,itemHeight:g}=Pv(a,u),m=this.isHorizontal(),b=this._computeTitleHeight();h=m?{x:jp(r,this.left+c,this.right-n[0]),y:this.top+c+b,line:0}:{x:this.left+c,y:jp(r,this.top+b+c,this.bottom-e[0].height),line:0},hm(this.ctx,t.textDirection);const x=g+c;this.legendItems.forEach(((v,y)=>{i.strokeStyle=v.fontColor,i.fillStyle=v.fontColor;const _=i.measureText(v.text).width,w=o.textAlign(v.textAlign||(v.textAlign=a.textAlign)),k=f+d+_;let S=h.x,C=h.y;o.setWidth(this.width),m?y>0&&S+k+c>this.right&&(C=h.y+=x,h.line++,S=h.x=jp(r,this.left+c,this.right-n[h.line])):y>0&&C+x>this.bottom&&(S=h.x=S+e[h.line].width+c,h.line++,C=h.y=jp(r,this.top+b+c,this.bottom-e[h.line].height));if(function(t,e,n){if(isNaN(f)||f<=0||isNaN(p)||p<0)return;i.save();const r=Vf(n.lineWidth,1);if(i.fillStyle=Vf(n.fillStyle,s),i.lineCap=Vf(n.lineCap,"butt"),i.lineDashOffset=Vf(n.lineDashOffset,0),i.lineJoin=Vf(n.lineJoin,"miter"),i.lineWidth=r,i.strokeStyle=Vf(n.strokeStyle,s),i.setLineDash(Vf(n.lineDash,[])),a.usePointStyle){const s={radius:p*Math.SQRT2/2,pointStyle:n.pointStyle,rotation:n.rotation,borderWidth:r},l=o.xPlus(t,f/2);cg(i,s,l,e+d,a.pointStyleWidth&&f)}else{const a=e+Math.max((u-p)/2,0),s=o.leftForLtr(t,f),l=Sg(n.borderRadius);i.beginPath(),Object.values(l).some((t=>0!==t))?xg(i,{x:s,y:a,w:f,h:p,radius:l}):i.rect(s,a,f,p),i.fill(),0!==r&&i.stroke()}i.restore()}(o.x(S),C,v),S=((t,e,n,i)=>t===(i?"left":"right")?n:"center"===t?(e+n)/2:e)(w,S+f+d,m?S+k:this.right,t.rtl),function(t,e,n){bg(i,n.text,t,e+g/2,l,{strikethrough:n.hidden,textAlign:o.textAlign(n.textAlign)})}(o.x(S),C,v),m)h.x+=k+c;else if("string"!=typeof v.text){const t=l.lineHeight;h.y+=Dv(v,t)+c}else h.y+=x})),fm(this.ctx,t.textDirection)}drawTitle(){const t=this.options,e=t.title,n=Mg(e.font),i=Cg(e.padding);if(!e.display)return;const r=dm(t.rtl,this.left,this.width),a=this.ctx,s=e.position,o=n.size/2,l=i.top+o;let c,u=this.left,d=this.width;if(this.isHorizontal())d=Math.max(...this.lineWidths),c=this.top+l,u=jp(t.align,u,this.right-d);else{const e=this.columnSizes.reduce(((t,e)=>Math.max(t,e.height)),0);c=l+jp(t.align,this.top,this.bottom-e-t.labels.padding-this._computeTitleHeight())}const h=jp(s,u,u+d);a.textAlign=r.textAlign(zp(s)),a.textBaseline="middle",a.strokeStyle=e.color,a.fillStyle=e.color,a.font=n.string,bg(a,e.text,h,c,n)}_computeTitleHeight(){const t=this.options.title,e=Mg(t.font),n=Cg(t.padding);return t.display?e.lineHeight+n.height:0}_getLegendItemAt(t,e){let n,i,r;if(Mp(t,this.left,this.right)&&Mp(e,this.top,this.bottom))for(r=this.legendHitBoxes,n=0;n<r.length;++n)if(i=r[n],Mp(t,i.left,i.left+i.width)&&Mp(e,i.top,i.top+i.height))return this.legendItems[n];return null}handleEvent(t){const e=this.options;if(!function(t,e){if(("mousemove"===t||"mouseout"===t)&&(e.onHover||e.onLeave))return!0;if(e.onClick&&("click"===t||"mouseup"===t))return!0;return!1}(t.type,e))return;const n=this._getLegendItemAt(t.x,t.y);if("mousemove"===t.type||"mouseout"===t.type){const i=this._hoveredItem,r=((t,e)=>null!==t&&null!==e&&t.datasetIndex===e.datasetIndex&&t.index===e.index)(i,n);i&&!r&&Wf(e.onLeave,[t,i,this],this),this._hoveredItem=n,n&&!r&&Wf(e.onHover,[t,n,this],this)}else n&&Wf(e.onClick,[t,n,this],this)}}function Dv(t,e){return e*(t.text?t.text.length:0)}var Tv={id:"legend",_element:Nv,start(t,e,n){const i=t.legend=new Nv({ctx:t.ctx,options:n,chart:t});Sb.configure(t,i,n),Sb.addBox(t,i)},stop(t){Sb.removeBox(t,t.legend),delete t.legend},beforeUpdate(t,e,n){const i=t.legend;Sb.configure(t,i,n),i.options=n},afterUpdate(t){const e=t.legend;e.buildLabels(),e.adjustHitBoxes()},afterEvent(t,e){e.replay||t.legend.handleEvent(e.event)},defaults:{display:!0,position:"top",align:"center",fullSize:!0,reverse:!1,weight:1e3,onClick(t,e,n){const i=e.datasetIndex,r=n.chart;r.isDatasetVisible(i)?(r.hide(i),e.hidden=!0):(r.show(i),e.hidden=!1)},onHover:null,onLeave:null,labels:{color:t=>t.chart.options.color,boxWidth:40,padding:10,generateLabels(t){const e=t.data.datasets,{labels:{usePointStyle:n,pointStyle:i,textAlign:r,color:a,useBorderRadius:s,borderRadius:o}}=t.legend.options;return t._getSortedDatasetMetas().map((t=>{const l=t.controller.getStyle(n?0:void 0),c=Cg(l.borderWidth);return{text:e[t.index].label,fillStyle:l.backgroundColor,fontColor:a,hidden:!t.visible,lineCap:l.borderCapStyle,lineDash:l.borderDash,lineDashOffset:l.borderDashOffset,lineJoin:l.borderJoinStyle,lineWidth:(c.width+c.height)/4,strokeStyle:l.borderColor,pointStyle:i||l.pointStyle,rotation:l.rotation,textAlign:r||l.textAlign,borderRadius:s&&(o||l.borderRadius),datasetIndex:t.index}}),this)}},title:{color:t=>t.chart.options.color,display:!1,position:"center",text:""}},descriptors:{_scriptable:t=>!t.startsWith("on"),labels:{_scriptable:t=>!["generateLabels","filter","sort"].includes(t)}}};class Ov extends Wb{constructor(t){super(),this.chart=t.chart,this.options=t.options,this.ctx=t.ctx,this._padding=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(t,e){const n=this.options;if(this.left=0,this.top=0,!n.display)return void(this.width=this.height=this.right=this.bottom=0);this.width=this.right=t,this.height=this.bottom=e;const i=jf(n.text)?n.text.length:1;this._padding=Cg(n.padding);const r=i*Mg(n.font).lineHeight+this._padding.height;this.isHorizontal()?this.height=r:this.width=r}isHorizontal(){const t=this.options.position;return"top"===t||"bottom"===t}_drawArgs(t){const{top:e,left:n,bottom:i,right:r,options:a}=this,s=a.align;let o,l,c,u=0;return this.isHorizontal()?(l=jp(s,n,r),c=e+t,o=r-n):("left"===a.position?(l=n+t,c=jp(s,i,e),u=-.5*ip):(l=r-t,c=jp(s,e,i),u=.5*ip),o=i-e),{titleX:l,titleY:c,maxWidth:o,rotation:u}}draw(){const t=this.ctx,e=this.options;if(!e.display)return;const n=Mg(e.font),i=n.lineHeight/2+this._padding.top,{titleX:r,titleY:a,maxWidth:s,rotation:o}=this._drawArgs(i);bg(t,e.text,0,0,n,{color:e.color,maxWidth:s,rotation:o,textAlign:zp(e.align),textBaseline:"middle",translation:[r,a]})}}var Lv={id:"title",_element:Ov,start(t,e,n){!function(t,e){const n=new Ov({ctx:t.ctx,options:e,chart:t});Sb.configure(t,n,e),Sb.addBox(t,n),t.titleBlock=n}(t,n)},stop(t){const e=t.titleBlock;Sb.removeBox(t,e),delete t.titleBlock},beforeUpdate(t,e,n){const i=t.titleBlock;Sb.configure(t,i,n),i.options=n},defaults:{align:"center",display:!1,font:{weight:"bold"},fullSize:!0,padding:10,position:"top",text:"",weight:2e3},defaultRoutes:{color:"color"},descriptors:{_scriptable:!0,_indexable:!1}};const Rv=new WeakMap;var zv={id:"subtitle",start(t,e,n){const i=new Ov({ctx:t.ctx,options:n,chart:t});Sb.configure(t,i,n),Sb.addBox(t,i),Rv.set(t,i)},stop(t){Sb.removeBox(t,Rv.get(t)),Rv.delete(t)},beforeUpdate(t,e,n){const i=Rv.get(t);Sb.configure(t,i,n),i.options=n},defaults:{align:"center",display:!1,font:{weight:"normal"},fullSize:!0,padding:0,position:"top",text:"",weight:1500},defaultRoutes:{color:"color"},descriptors:{_scriptable:!0,_indexable:!1}};const jv={average(t){if(!t.length)return!1;let e,n,i=new Set,r=0,a=0;for(e=0,n=t.length;e<n;++e){const n=t[e].element;if(n&&n.hasValue()){const t=n.tooltipPosition();i.add(t.x),r+=t.y,++a}}if(0===a||0===i.size)return!1;const s=[...i].reduce(((t,e)=>t+e))/i.size;return{x:s,y:r/a}},nearest(t,e){if(!t.length)return!1;let n,i,r,a=e.x,s=e.y,o=Number.POSITIVE_INFINITY;for(n=0,i=t.length;n<i;++n){const i=t[n].element;if(i&&i.hasValue()){const t=_p(e,i.getCenterPoint());t<o&&(o=t,r=i)}}if(r){const t=r.tooltipPosition();a=t.x,s=t.y}return{x:a,y:s}}};function Av(t,e){return e&&(jf(e)?Array.prototype.push.apply(t,e):t.push(e)),t}function Fv(t){return("string"==typeof t||t instanceof String)&&t.indexOf("\n")>-1?t.split("\n"):t}function Iv(t,e){const{element:n,datasetIndex:i,index:r}=e,a=t.getDatasetMeta(i).controller,{label:s,value:o}=a.getLabelAndValue(r);return{chart:t,label:s,parsed:a.getParsed(r),raw:t.data.datasets[i].data[r],formattedValue:o,dataset:a.getDataset(),dataIndex:r,datasetIndex:i,element:n}}function Vv(t,e){const n=t.chart.ctx,{body:i,footer:r,title:a}=t,{boxWidth:s,boxHeight:o}=e,l=Mg(e.bodyFont),c=Mg(e.titleFont),u=Mg(e.footerFont),d=a.length,h=r.length,f=i.length,p=Cg(e.padding);let g=p.height,m=0,b=i.reduce(((t,e)=>t+e.before.length+e.lines.length+e.after.length),0);if(b+=t.beforeBody.length+t.afterBody.length,d&&(g+=d*c.lineHeight+(d-1)*e.titleSpacing+e.titleMarginBottom),b){g+=f*(e.displayColors?Math.max(o,l.lineHeight):l.lineHeight)+(b-f)*l.lineHeight+(b-1)*e.bodySpacing}h&&(g+=e.footerMarginTop+h*u.lineHeight+(h-1)*e.footerSpacing);let x=0;const v=function(t){m=Math.max(m,n.measureText(t).width+x)};return n.save(),n.font=c.string,Hf(t.title,v),n.font=l.string,Hf(t.beforeBody.concat(t.afterBody),v),x=e.displayColors?s+2+e.boxPadding:0,Hf(i,(t=>{Hf(t.before,v),Hf(t.lines,v),Hf(t.after,v)})),x=0,n.font=u.string,Hf(t.footer,v),n.restore(),m+=p.width,{width:m,height:g}}function Bv(t,e,n,i){const{x:r,width:a}=n,{width:s,chartArea:{left:o,right:l}}=t;let c="center";return"center"===i?c=r<=(o+l)/2?"left":"right":r<=a/2?c="left":r>=s-a/2&&(c="right"),function(t,e,n,i){const{x:r,width:a}=i,s=n.caretSize+n.caretPadding;return"left"===t&&r+a+s>e.width||"right"===t&&r-a-s<0||void 0}(c,t,e,n)&&(c="center"),c}function Wv(t,e,n){const i=n.yAlign||e.yAlign||function(t,e){const{y:n,height:i}=e;return n<i/2?"top":n>t.height-i/2?"bottom":"center"}(t,n);return{xAlign:n.xAlign||e.xAlign||Bv(t,e,n,i),yAlign:i}}function Hv(t,e,n,i){const{caretSize:r,caretPadding:a,cornerRadius:s}=t,{xAlign:o,yAlign:l}=n,c=r+a,{topLeft:u,topRight:d,bottomLeft:h,bottomRight:f}=Sg(s);let p=function(t,e){let{x:n,width:i}=t;return"right"===e?n-=i:"center"===e&&(n-=i/2),n}(e,o);const g=function(t,e,n){let{y:i,height:r}=t;return"top"===e?i+=n:i-="bottom"===e?r+n:r/2,i}(e,l,c);return"center"===l?"left"===o?p+=c:"right"===o&&(p-=c):"left"===o?p-=Math.max(u,h)+r:"right"===o&&(p+=Math.max(d,f)+r),{x:Cp(p,0,i.width-e.width),y:Cp(g,0,i.height-e.height)}}function $v(t,e,n){const i=Cg(n.padding);return"center"===e?t.x+t.width/2:"right"===e?t.x+t.width-i.right:t.x+i.left}function Uv(t){return Av([],Fv(t))}function Yv(t,e){const n=e&&e.dataset&&e.dataset.tooltip&&e.dataset.tooltip.callbacks;return n?t.override(n):t}const Qv={beforeTitle:Lf,title(t){if(t.length>0){const e=t[0],n=e.chart.data.labels,i=n?n.length:0;if(this&&this.options&&"dataset"===this.options.mode)return e.dataset.label||"";if(e.label)return e.label;if(i>0&&e.dataIndex<i)return n[e.dataIndex]}return""},afterTitle:Lf,beforeBody:Lf,beforeLabel:Lf,label(t){if(this&&this.options&&"dataset"===this.options.mode)return t.label+": "+t.formattedValue||t.formattedValue;let e=t.dataset.label||"";e&&(e+=": ");const n=t.formattedValue;return zf(n)||(e+=n),e},labelColor(t){const e=t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);return{borderColor:e.borderColor,backgroundColor:e.backgroundColor,borderWidth:e.borderWidth,borderDash:e.borderDash,borderDashOffset:e.borderDashOffset,borderRadius:0}},labelTextColor(){return this.options.bodyColor},labelPointStyle(t){const e=t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);return{pointStyle:e.pointStyle,rotation:e.rotation}},afterLabel:Lf,afterBody:Lf,beforeFooter:Lf,footer:Lf,afterFooter:Lf};function qv(t,e,n,i){const r=t[e].call(n,i);return void 0===r?Qv[e].call(n,i):r}class Xv extends Wb{constructor(t){super(),this.opacity=0,this._active=[],this._eventPosition=void 0,this._size=void 0,this._cachedAnimations=void 0,this._tooltipItems=[],this.$animations=void 0,this.$context=void 0,this.chart=t.chart,this.options=t.options,this.dataPoints=void 0,this.title=void 0,this.beforeBody=void 0,this.body=void 0,this.afterBody=void 0,this.footer=void 0,this.xAlign=void 0,this.yAlign=void 0,this.x=void 0,this.y=void 0,this.height=void 0,this.width=void 0,this.caretX=void 0,this.caretY=void 0,this.labelColors=void 0,this.labelPointStyles=void 0,this.labelTextColors=void 0}initialize(t){this.options=t,this._cachedAnimations=void 0,this.$context=void 0}_resolveAnimations(){const t=this._cachedAnimations;if(t)return t;const e=this.chart,n=this.options.setContext(this.getContext()),i=n.enabled&&e.options.animation&&n.animations,r=new Mm(this.chart,i);return i._cacheable&&(this._cachedAnimations=Object.freeze(r)),r}getContext(){return this.$context||(this.$context=(t=this.chart.getContext(),e=this,n=this._tooltipItems,Pg(t,{tooltip:e,tooltipItems:n,type:"tooltip"})));var t,e,n}getTitle(t,e){const{callbacks:n}=e,i=qv(n,"beforeTitle",this,t),r=qv(n,"title",this,t),a=qv(n,"afterTitle",this,t);let s=[];return s=Av(s,Fv(i)),s=Av(s,Fv(r)),s=Av(s,Fv(a)),s}getBeforeBody(t,e){return Uv(qv(e.callbacks,"beforeBody",this,t))}getBody(t,e){const{callbacks:n}=e,i=[];return Hf(t,(t=>{const e={before:[],lines:[],after:[]},r=Yv(n,t);Av(e.before,Fv(qv(r,"beforeLabel",this,t))),Av(e.lines,qv(r,"label",this,t)),Av(e.after,Fv(qv(r,"afterLabel",this,t))),i.push(e)})),i}getAfterBody(t,e){return Uv(qv(e.callbacks,"afterBody",this,t))}getFooter(t,e){const{callbacks:n}=e,i=qv(n,"beforeFooter",this,t),r=qv(n,"footer",this,t),a=qv(n,"afterFooter",this,t);let s=[];return s=Av(s,Fv(i)),s=Av(s,Fv(r)),s=Av(s,Fv(a)),s}_createItems(t){const e=this._active,n=this.chart.data,i=[],r=[],a=[];let s,o,l=[];for(s=0,o=e.length;s<o;++s)l.push(Iv(this.chart,e[s]));return t.filter&&(l=l.filter(((e,i,r)=>t.filter(e,i,r,n)))),t.itemSort&&(l=l.sort(((e,i)=>t.itemSort(e,i,n)))),Hf(l,(e=>{const n=Yv(t.callbacks,e);i.push(qv(n,"labelColor",this,e)),r.push(qv(n,"labelPointStyle",this,e)),a.push(qv(n,"labelTextColor",this,e))})),this.labelColors=i,this.labelPointStyles=r,this.labelTextColors=a,this.dataPoints=l,l}update(t,e){const n=this.options.setContext(this.getContext()),i=this._active;let r,a=[];if(i.length){const t=jv[n.position].call(this,i,this._eventPosition);a=this._createItems(n),this.title=this.getTitle(a,n),this.beforeBody=this.getBeforeBody(a,n),this.body=this.getBody(a,n),this.afterBody=this.getAfterBody(a,n),this.footer=this.getFooter(a,n);const e=this._size=Vv(this,n),s=Object.assign({},t,e),o=Wv(this.chart,n,s),l=Hv(n,s,o,this.chart);this.xAlign=o.xAlign,this.yAlign=o.yAlign,r={opacity:1,x:l.x,y:l.y,width:e.width,height:e.height,caretX:t.x,caretY:t.y}}else 0!==this.opacity&&(r={opacity:0});this._tooltipItems=a,this.$context=void 0,r&&this._resolveAnimations().update(this,r),t&&n.external&&n.external.call(this,{chart:this.chart,tooltip:this,replay:e})}drawCaret(t,e,n,i){const r=this.getCaretPosition(t,n,i);e.lineTo(r.x1,r.y1),e.lineTo(r.x2,r.y2),e.lineTo(r.x3,r.y3)}getCaretPosition(t,e,n){const{xAlign:i,yAlign:r}=this,{caretSize:a,cornerRadius:s}=n,{topLeft:o,topRight:l,bottomLeft:c,bottomRight:u}=Sg(s),{x:d,y:h}=t,{width:f,height:p}=e;let g,m,b,x,v,y;return"center"===r?(v=h+p/2,"left"===i?(g=d,m=g-a,x=v+a,y=v-a):(g=d+f,m=g+a,x=v-a,y=v+a),b=g):(m="left"===i?d+Math.max(o,c)+a:"right"===i?d+f-Math.max(l,u)-a:this.caretX,"top"===r?(x=h,v=x-a,g=m-a,b=m+a):(x=h+p,v=x+a,g=m+a,b=m-a),y=x),{x1:g,x2:m,x3:b,y1:x,y2:v,y3:y}}drawTitle(t,e,n){const i=this.title,r=i.length;let a,s,o;if(r){const l=dm(n.rtl,this.x,this.width);for(t.x=$v(this,n.titleAlign,n),e.textAlign=l.textAlign(n.titleAlign),e.textBaseline="middle",a=Mg(n.titleFont),s=n.titleSpacing,e.fillStyle=n.titleColor,e.font=a.string,o=0;o<r;++o)e.fillText(i[o],l.x(t.x),t.y+a.lineHeight/2),t.y+=a.lineHeight+s,o+1===r&&(t.y+=n.titleMarginBottom-s)}}_drawColorBox(t,e,n,i,r){const a=this.labelColors[n],s=this.labelPointStyles[n],{boxHeight:o,boxWidth:l}=r,c=Mg(r.bodyFont),u=$v(this,"left",r),d=i.x(u),h=o<c.lineHeight?(c.lineHeight-o)/2:0,f=e.y+h;if(r.usePointStyle){const e={radius:Math.min(l,o)/2,pointStyle:s.pointStyle,rotation:s.rotation,borderWidth:1},n=i.leftForLtr(d,l)+l/2,c=f+o/2;t.strokeStyle=r.multiKeyBackground,t.fillStyle=r.multiKeyBackground,lg(t,e,n,c),t.strokeStyle=a.borderColor,t.fillStyle=a.backgroundColor,lg(t,e,n,c)}else{t.lineWidth=Af(a.borderWidth)?Math.max(...Object.values(a.borderWidth)):a.borderWidth||1,t.strokeStyle=a.borderColor,t.setLineDash(a.borderDash||[]),t.lineDashOffset=a.borderDashOffset||0;const e=i.leftForLtr(d,l),n=i.leftForLtr(i.xPlus(d,1),l-2),s=Sg(a.borderRadius);Object.values(s).some((t=>0!==t))?(t.beginPath(),t.fillStyle=r.multiKeyBackground,xg(t,{x:e,y:f,w:l,h:o,radius:s}),t.fill(),t.stroke(),t.fillStyle=a.backgroundColor,t.beginPath(),xg(t,{x:n,y:f+1,w:l-2,h:o-2,radius:s}),t.fill()):(t.fillStyle=r.multiKeyBackground,t.fillRect(e,f,l,o),t.strokeRect(e,f,l,o),t.fillStyle=a.backgroundColor,t.fillRect(n,f+1,l-2,o-2))}t.fillStyle=this.labelTextColors[n]}drawBody(t,e,n){const{body:i}=this,{bodySpacing:r,bodyAlign:a,displayColors:s,boxHeight:o,boxWidth:l,boxPadding:c}=n,u=Mg(n.bodyFont);let d=u.lineHeight,h=0;const f=dm(n.rtl,this.x,this.width),p=function(n){e.fillText(n,f.x(t.x+h),t.y+d/2),t.y+=d+r},g=f.textAlign(a);let m,b,x,v,y,_,w;for(e.textAlign=a,e.textBaseline="middle",e.font=u.string,t.x=$v(this,g,n),e.fillStyle=n.bodyColor,Hf(this.beforeBody,p),h=s&&"right"!==g?"center"===a?l/2+c:l+2+c:0,v=0,_=i.length;v<_;++v){for(m=i[v],b=this.labelTextColors[v],e.fillStyle=b,Hf(m.before,p),x=m.lines,s&&x.length&&(this._drawColorBox(e,t,v,f,n),d=Math.max(u.lineHeight,o)),y=0,w=x.length;y<w;++y)p(x[y]),d=u.lineHeight;Hf(m.after,p)}h=0,d=u.lineHeight,Hf(this.afterBody,p),t.y-=r}drawFooter(t,e,n){const i=this.footer,r=i.length;let a,s;if(r){const o=dm(n.rtl,this.x,this.width);for(t.x=$v(this,n.footerAlign,n),t.y+=n.footerMarginTop,e.textAlign=o.textAlign(n.footerAlign),e.textBaseline="middle",a=Mg(n.footerFont),e.fillStyle=n.footerColor,e.font=a.string,s=0;s<r;++s)e.fillText(i[s],o.x(t.x),t.y+a.lineHeight/2),t.y+=a.lineHeight+n.footerSpacing}}drawBackground(t,e,n,i){const{xAlign:r,yAlign:a}=this,{x:s,y:o}=t,{width:l,height:c}=n,{topLeft:u,topRight:d,bottomLeft:h,bottomRight:f}=Sg(i.cornerRadius);e.fillStyle=i.backgroundColor,e.strokeStyle=i.borderColor,e.lineWidth=i.borderWidth,e.beginPath(),e.moveTo(s+u,o),"top"===a&&this.drawCaret(t,e,n,i),e.lineTo(s+l-d,o),e.quadraticCurveTo(s+l,o,s+l,o+d),"center"===a&&"right"===r&&this.drawCaret(t,e,n,i),e.lineTo(s+l,o+c-f),e.quadraticCurveTo(s+l,o+c,s+l-f,o+c),"bottom"===a&&this.drawCaret(t,e,n,i),e.lineTo(s+h,o+c),e.quadraticCurveTo(s,o+c,s,o+c-h),"center"===a&&"left"===r&&this.drawCaret(t,e,n,i),e.lineTo(s,o+u),e.quadraticCurveTo(s,o,s+u,o),e.closePath(),e.fill(),i.borderWidth>0&&e.stroke()}_updateAnimationTarget(t){const e=this.chart,n=this.$animations,i=n&&n.x,r=n&&n.y;if(i||r){const n=jv[t.position].call(this,this._active,this._eventPosition);if(!n)return;const a=this._size=Vv(this,t),s=Object.assign({},n,this._size),o=Wv(e,t,s),l=Hv(t,s,o,e);i._to===l.x&&r._to===l.y||(this.xAlign=o.xAlign,this.yAlign=o.yAlign,this.width=a.width,this.height=a.height,this.caretX=n.x,this.caretY=n.y,this._resolveAnimations().update(this,l))}}_willRender(){return!!this.opacity}draw(t){const e=this.options.setContext(this.getContext());let n=this.opacity;if(!n)return;this._updateAnimationTarget(e);const i={width:this.width,height:this.height},r={x:this.x,y:this.y};n=Math.abs(n)<.001?0:n;const a=Cg(e.padding),s=this.title.length||this.beforeBody.length||this.body.length||this.afterBody.length||this.footer.length;e.enabled&&s&&(t.save(),t.globalAlpha=n,this.drawBackground(r,t,i,e),hm(t,e.textDirection),r.y+=a.top,this.drawTitle(r,t,e),this.drawBody(r,t,e),this.drawFooter(r,t,e),fm(t,e.textDirection),t.restore())}getActiveElements(){return this._active||[]}setActiveElements(t,e){const n=this._active,i=t.map((({datasetIndex:t,index:e})=>{const n=this.chart.getDatasetMeta(t);if(!n)throw new Error("Cannot find a dataset at index "+t);return{datasetIndex:t,element:n.data[e],index:e}})),r=!$f(n,i),a=this._positionChanged(i,e);(r||a)&&(this._active=i,this._eventPosition=e,this._ignoreReplayEvents=!0,this.update(!0))}handleEvent(t,e,n=!0){if(e&&this._ignoreReplayEvents)return!1;this._ignoreReplayEvents=!1;const i=this.options,r=this._active||[],a=this._getActiveElements(t,r,e,n),s=this._positionChanged(a,t),o=e||!$f(a,r)||s;return o&&(this._active=a,(i.enabled||i.external)&&(this._eventPosition={x:t.x,y:t.y},this.update(!0,e))),o}_getActiveElements(t,e,n,i){const r=this.options;if("mouseout"===t.type)return[];if(!i)return e.filter((t=>this.chart.data.datasets[t.datasetIndex]&&void 0!==this.chart.getDatasetMeta(t.datasetIndex).controller.getParsed(t.index)));const a=this.chart.getElementsAtEventForMode(t,r.mode,r,n);return r.reverse&&a.reverse(),a}_positionChanged(t,e){const{caretX:n,caretY:i,options:r}=this,a=jv[r.position].call(this,t,e);return!1!==a&&(n!==a.x||i!==a.y)}}e(Xv,"positioners",jv);var Kv={id:"tooltip",_element:Xv,positioners:jv,afterInit(t,e,n){n&&(t.tooltip=new Xv({chart:t,options:n}))},beforeUpdate(t,e,n){t.tooltip&&t.tooltip.initialize(n)},reset(t,e,n){t.tooltip&&t.tooltip.initialize(n)},afterDraw(t){const e=t.tooltip;if(e&&e._willRender()){const n={tooltip:e};if(!1===t.notifyPlugins("beforeTooltipDraw",{...n,cancelable:!0}))return;e.draw(t.ctx),t.notifyPlugins("afterTooltipDraw",n)}},afterEvent(t,e){if(t.tooltip){const n=e.replay;t.tooltip.handleEvent(e.event,n,e.inChartArea)&&(e.changed=!0)}},defaults:{enabled:!0,external:null,position:"average",backgroundColor:"rgba(0,0,0,0.8)",titleColor:"#fff",titleFont:{weight:"bold"},titleSpacing:2,titleMarginBottom:6,titleAlign:"left",bodyColor:"#fff",bodySpacing:2,bodyFont:{},bodyAlign:"left",footerColor:"#fff",footerSpacing:2,footerMarginTop:6,footerFont:{weight:"bold"},footerAlign:"left",padding:6,caretPadding:2,caretSize:5,cornerRadius:6,boxHeight:(t,e)=>e.bodyFont.size,boxWidth:(t,e)=>e.bodyFont.size,multiKeyBackground:"#fff",displayColors:!0,boxPadding:0,borderColor:"rgba(0,0,0,0)",borderWidth:0,animation:{duration:400,easing:"easeOutQuart"},animations:{numbers:{type:"number",properties:["x","y","width","height","caretX","caretY"]},opacity:{easing:"linear",duration:200}},callbacks:Qv},defaultRoutes:{bodyFont:"font",footerFont:"font",titleFont:"font"},descriptors:{_scriptable:t=>"filter"!==t&&"itemSort"!==t&&"external"!==t,_indexable:!1,callbacks:{_scriptable:!1,_indexable:!1},animation:{_fallback:!1},animations:{_fallback:"animation"}},additionalOptionScopes:["interaction"]},Gv=Object.freeze({__proto__:null,Colors:ov,Decimation:uv,Filler:Ev,Legend:Tv,SubTitle:zv,Title:Lv,Tooltip:Kv});function Jv(t,e,n,i){const r=t.indexOf(e);if(-1===r)return((t,e,n,i)=>("string"==typeof e?(n=t.push(e)-1,i.unshift({index:n,label:e})):isNaN(e)&&(n=null),n))(t,e,n,i);return r!==t.lastIndexOf(e)?n:r}function Zv(t){const e=this.getLabels();return t>=0&&t<e.length?e[t]:t}class ty extends Jb{constructor(t){super(t),this._startValue=void 0,this._valueRange=0,this._addedLabels=[]}init(t){const e=this._addedLabels;if(e.length){const t=this.getLabels();for(const{index:n,label:i}of e)t[n]===i&&t.splice(n,1);this._addedLabels=[]}super.init(t)}parse(t,e){if(zf(t))return null;const n=this.getLabels();return((t,e)=>null===t?null:Cp(Math.round(t),0,e))(e=isFinite(e)&&n[e]===t?e:Jv(n,t,Vf(e,t),this._addedLabels),n.length-1)}determineDataLimits(){const{minDefined:t,maxDefined:e}=this.getUserBounds();let{min:n,max:i}=this.getMinMax(!0);"ticks"===this.options.bounds&&(t||(n=0),e||(i=this.getLabels().length-1)),this.min=n,this.max=i}buildTicks(){const t=this.min,e=this.max,n=this.options.offset,i=[];let r=this.getLabels();r=0===t&&e===r.length-1?r:r.slice(t,e+1),this._valueRange=Math.max(r.length-(n?0:1),1),this._startValue=this.min-(n?.5:0);for(let a=t;a<=e;a++)i.push({value:a});return i}getLabelForValue(t){return Zv.call(this,t)}configure(){super.configure(),this.isHorizontal()||(this._reversePixels=!this._reversePixels)}getPixelForValue(t){return"number"!=typeof t&&(t=this.parse(t)),null===t?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}getPixelForTick(t){const e=this.ticks;return t<0||t>e.length-1?null:this.getPixelForValue(e[t].value)}getValueForPixel(t){return Math.round(this._startValue+this.getDecimalForPixel(t)*this._valueRange)}getBasePixel(){return this.bottom}}function ey(t,e){const n=[],{bounds:i,step:r,min:a,max:s,precision:o,count:l,maxTicks:c,maxDigits:u,includeBounds:d}=t,h=r||1,f=c-1,{min:p,max:g}=e,m=!zf(a),b=!zf(s),x=!zf(l),v=(g-p)/(u+1);let y,_,w,k,S=pp((g-p)/f/h)*h;if(S<1e-14&&!m&&!b)return[{value:p},{value:g}];k=Math.ceil(g/S)-Math.floor(p/S),k>f&&(S=pp(k*S/f/h)*h),zf(o)||(y=Math.pow(10,o),S=Math.ceil(S*y)/y),"ticks"===i?(_=Math.floor(p/S)*S,w=Math.ceil(g/S)*S):(_=p,w=g),m&&b&&r&&function(t,e){const n=Math.round(t);return n-e<=t&&n+e>=t}((s-a)/r,S/1e3)?(k=Math.round(Math.min((s-a)/S,c)),S=(s-a)/k,_=a,w=s):x?(_=m?a:_,w=b?s:w,k=l-1,S=(w-_)/k):(k=(w-_)/S,k=fp(k,Math.round(k),S/1e3)?Math.round(k):Math.ceil(k));const C=Math.max(vp(S),vp(_));y=Math.pow(10,zf(o)?C:o),_=Math.round(_*y)/y,w=Math.round(w*y)/y;let M=0;for(m&&(d&&_!==a?(n.push({value:a}),_<a&&M++,fp(Math.round((_+M*S)*y)/y,a,ny(a,v,t))&&M++):_<a&&M++);M<k;++M){const t=Math.round((_+M*S)*y)/y;if(b&&t>s)break;n.push({value:t})}return b&&d&&w!==s?n.length&&fp(n[n.length-1].value,s,ny(s,v,t))?n[n.length-1].value=s:n.push({value:s}):b&&w!==s||n.push({value:w}),n}function ny(t,e,{horizontal:n,minRotation:i}){const r=bp(i),a=(n?Math.sin(r):Math.cos(r))||.001,s=.75*e*(""+t).length;return Math.min(e/a,s)}e(ty,"id","category"),e(ty,"defaults",{ticks:{callback:Zv}});class iy extends Jb{constructor(t){super(t),this.start=void 0,this.end=void 0,this._startValue=void 0,this._endValue=void 0,this._valueRange=0}parse(t,e){return zf(t)||("number"==typeof t||t instanceof Number)&&!isFinite(+t)?null:+t}handleTickRangeOptions(){const{beginAtZero:t}=this.options,{minDefined:e,maxDefined:n}=this.getUserBounds();let{min:i,max:r}=this;const a=t=>i=e?i:t,s=t=>r=n?r:t;if(t){const t=hp(i),e=hp(r);t<0&&e<0?s(0):t>0&&e>0&&a(0)}if(i===r){let e=0===r?1:Math.abs(.05*r);s(r+e),t||a(i-e)}this.min=i,this.max=r}getTickLimit(){const t=this.options.ticks;let e,{maxTicksLimit:n,stepSize:i}=t;return i?(e=Math.ceil(this.max/i)-Math.floor(this.min/i)+1,e>1e3&&(console.warn(`scales.${this.id}.ticks.stepSize: ${i} would result generating up to ${e} ticks. Limiting to 1000.`),e=1e3)):(e=this.computeTickLimit(),n=n||11),n&&(e=Math.min(n,e)),e}computeTickLimit(){return Number.POSITIVE_INFINITY}buildTicks(){const t=this.options,e=t.ticks;let n=this.getTickLimit();n=Math.max(2,n);const i=ey({maxTicks:n,bounds:t.bounds,min:t.min,max:t.max,precision:e.precision,step:e.stepSize,count:e.count,maxDigits:this._maxDigits(),horizontal:this.isHorizontal(),minRotation:e.minRotation||0,includeBounds:!1!==e.includeBounds},this._range||this);return"ticks"===t.bounds&&mp(i,this,"value"),t.reverse?(i.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),i}configure(){const t=this.ticks;let e=this.min,n=this.max;if(super.configure(),this.options.offset&&t.length){const i=(n-e)/Math.max(t.length-1,1)/2;e-=i,n+=i}this._startValue=e,this._endValue=n,this._valueRange=n-e}getLabelForValue(t){return Xp(t,this.chart.options.locale,this.options.ticks.format)}}class ry extends iy{determineDataLimits(){const{min:t,max:e}=this.getMinMax(!0);this.min=Ff(t)?t:0,this.max=Ff(e)?e:1,this.handleTickRangeOptions()}computeTickLimit(){const t=this.isHorizontal(),e=t?this.width:this.height,n=bp(this.options.ticks.minRotation),i=(t?Math.sin(n):Math.cos(n))||.001,r=this._resolveTickFontOptions(0);return Math.ceil(e/Math.min(40,r.lineHeight/i))}getPixelForValue(t){return null===t?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}getValueForPixel(t){return this._startValue+this.getDecimalForPixel(t)*this._valueRange}}e(ry,"id","linear"),e(ry,"defaults",{ticks:{callback:Gp.formatters.numeric}});const ay=t=>Math.floor(dp(t)),sy=(t,e)=>Math.pow(10,ay(t)+e);function oy(t){return 1===t/Math.pow(10,ay(t))}function ly(t,e,n){const i=Math.pow(10,n),r=Math.floor(t/i);return Math.ceil(e/i)-r}function cy(t,{min:e,max:n}){e=If(t.min,e);const i=[],r=ay(e);let a=function(t,e){let n=ay(e-t);for(;ly(t,e,n)>10;)n++;for(;ly(t,e,n)<10;)n--;return Math.min(n,ay(t))}(e,n),s=a<0?Math.pow(10,Math.abs(a)):1;const o=Math.pow(10,a),l=r>a?Math.pow(10,r):0,c=Math.round((e-l)*s)/s,u=Math.floor((e-l)/o/10)*o*10;let d=Math.floor((c-u)/Math.pow(10,a)),h=If(t.min,Math.round((l+u+d*Math.pow(10,a))*s)/s);for(;h<n;)i.push({value:h,major:oy(h),significand:d}),d>=10?d=d<15?15:20:d++,d>=20&&(a++,d=2,s=a>=0?1:s),h=Math.round((l+u+d*Math.pow(10,a))*s)/s;const f=If(t.max,h);return i.push({value:f,major:oy(f),significand:d}),i}class uy extends Jb{constructor(t){super(t),this.start=void 0,this.end=void 0,this._startValue=void 0,this._valueRange=0}parse(t,e){const n=iy.prototype.parse.apply(this,[t,e]);if(0!==n)return Ff(n)&&n>0?n:null;this._zero=!0}determineDataLimits(){const{min:t,max:e}=this.getMinMax(!0);this.min=Ff(t)?Math.max(0,t):null,this.max=Ff(e)?Math.max(0,e):null,this.options.beginAtZero&&(this._zero=!0),this._zero&&this.min!==this._suggestedMin&&!Ff(this._userMin)&&(this.min=t===sy(this.min,0)?sy(this.min,-1):sy(this.min,0)),this.handleTickRangeOptions()}handleTickRangeOptions(){const{minDefined:t,maxDefined:e}=this.getUserBounds();let n=this.min,i=this.max;const r=e=>n=t?n:e,a=t=>i=e?i:t;n===i&&(n<=0?(r(1),a(10)):(r(sy(n,-1)),a(sy(i,1)))),n<=0&&r(sy(i,-1)),i<=0&&a(sy(n,1)),this.min=n,this.max=i}buildTicks(){const t=this.options,e=cy({min:this._userMin,max:this._userMax},this);return"ticks"===t.bounds&&mp(e,this,"value"),t.reverse?(e.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),e}getLabelForValue(t){return void 0===t?"0":Xp(t,this.chart.options.locale,this.options.ticks.format)}configure(){const t=this.min;super.configure(),this._startValue=dp(t),this._valueRange=dp(this.max)-dp(t)}getPixelForValue(t){return void 0!==t&&0!==t||(t=this.min),null===t||isNaN(t)?NaN:this.getPixelForDecimal(t===this.min?0:(dp(t)-this._startValue)/this._valueRange)}getValueForPixel(t){const e=this.getDecimalForPixel(t);return Math.pow(10,this._startValue+e*this._valueRange)}}function dy(t){const e=t.ticks;if(e.display&&t.display){const t=Cg(e.backdropPadding);return Vf(e.font&&e.font.size,ig.font.size)+t.height}return 0}function hy(t,e,n,i,r){return t===i||t===r?{start:e-n/2,end:e+n/2}:t<i||t>r?{start:e-n,end:e}:{start:e,end:e+n}}function fy(t){const e={l:t.left+t._padding.left,r:t.right-t._padding.right,t:t.top+t._padding.top,b:t.bottom-t._padding.bottom},n=Object.assign({},e),i=[],r=[],a=t._pointLabels.length,s=t.options.pointLabels,o=s.centerPointLabels?ip/a:0;for(let d=0;d<a;d++){const a=s.setContext(t.getPointLabelContext(d));r[d]=a.padding;const h=t.getPointPosition(d,t.drawingArea+r[d],o),f=Mg(a.font),p=(l=t.ctx,c=f,u=jf(u=t._pointLabels[d])?u:[u],{w:ag(l,c.string,u),h:u.length*c.lineHeight});i[d]=p;const g=kp(t.getIndexAngle(d)+o),m=Math.round(xp(g));py(n,e,g,hy(m,h.x,p.w,0,180),hy(m,h.y,p.h,90,270))}var l,c,u;t.setCenterPoint(e.l-n.l,n.r-e.r,e.t-n.t,n.b-e.b),t._pointLabelItems=function(t,e,n){const i=[],r=t._pointLabels.length,a=t.options,{centerPointLabels:s,display:o}=a.pointLabels,l={extra:dy(a)/2,additionalAngle:s?ip/r:0};let c;for(let u=0;u<r;u++){l.padding=n[u],l.size=e[u];const r=gy(t,u,l);i.push(r),"auto"===o&&(r.visible=my(r,c),r.visible&&(c=r))}return i}(t,i,r)}function py(t,e,n,i,r){const a=Math.abs(Math.sin(n)),s=Math.abs(Math.cos(n));let o=0,l=0;i.start<e.l?(o=(e.l-i.start)/a,t.l=Math.min(t.l,e.l-o)):i.end>e.r&&(o=(i.end-e.r)/a,t.r=Math.max(t.r,e.r+o)),r.start<e.t?(l=(e.t-r.start)/s,t.t=Math.min(t.t,e.t-l)):r.end>e.b&&(l=(r.end-e.b)/s,t.b=Math.max(t.b,e.b+l))}function gy(t,e,n){const i=t.drawingArea,{extra:r,additionalAngle:a,padding:s,size:o}=n,l=t.getPointPosition(e,i+r+s,a),c=Math.round(xp(kp(l.angle+lp))),u=function(t,e,n){90===n||270===n?t-=e/2:(n>270||n<90)&&(t-=e);return t}(l.y,o.h,c),d=function(t){if(0===t||180===t)return"center";if(t<180)return"left";return"right"}(c),h=function(t,e,n){"right"===n?t-=e:"center"===n&&(t-=e/2);return t}(l.x,o.w,d);return{visible:!0,x:l.x,y:u,textAlign:d,left:h,top:u,right:h+o.w,bottom:u+o.h}}function my(t,e){if(!e)return!0;const{left:n,top:i,right:r,bottom:a}=t;return!(ug({x:n,y:i},e)||ug({x:n,y:a},e)||ug({x:r,y:i},e)||ug({x:r,y:a},e))}function by(t,e,n){const{left:i,top:r,right:a,bottom:s}=n,{backdropColor:o}=e;if(!zf(o)){const n=Sg(e.borderRadius),l=Cg(e.backdropPadding);t.fillStyle=o;const c=i-l.left,u=r-l.top,d=a-i+l.width,h=s-r+l.height;Object.values(n).some((t=>0!==t))?(t.beginPath(),xg(t,{x:c,y:u,w:d,h:h,radius:n}),t.fill()):t.fillRect(c,u,d,h)}}function xy(t,e,n,i){const{ctx:r}=t;if(n)r.arc(t.xCenter,t.yCenter,e,0,rp);else{let n=t.getPointPosition(0,e);r.moveTo(n.x,n.y);for(let a=1;a<i;a++)n=t.getPointPosition(a,e),r.lineTo(n.x,n.y)}}e(uy,"id","logarithmic"),e(uy,"defaults",{ticks:{callback:Gp.formatters.logarithmic,major:{enabled:!0}}});class vy extends iy{constructor(t){super(t),this.xCenter=void 0,this.yCenter=void 0,this.drawingArea=void 0,this._pointLabels=[],this._pointLabelItems=[]}setDimensions(){const t=this._padding=Cg(dy(this.options)/2),e=this.width=this.maxWidth-t.width,n=this.height=this.maxHeight-t.height;this.xCenter=Math.floor(this.left+e/2+t.left),this.yCenter=Math.floor(this.top+n/2+t.top),this.drawingArea=Math.floor(Math.min(e,n)/2)}determineDataLimits(){const{min:t,max:e}=this.getMinMax(!1);this.min=Ff(t)&&!isNaN(t)?t:0,this.max=Ff(e)&&!isNaN(e)?e:0,this.handleTickRangeOptions()}computeTickLimit(){return Math.ceil(this.drawingArea/dy(this.options))}generateTickLabels(t){iy.prototype.generateTickLabels.call(this,t),this._pointLabels=this.getLabels().map(((t,e)=>{const n=Wf(this.options.pointLabels.callback,[t,e],this);return n||0===n?n:""})).filter(((t,e)=>this.chart.getDataVisibility(e)))}fit(){const t=this.options;t.display&&t.pointLabels.display?fy(this):this.setCenterPoint(0,0,0,0)}setCenterPoint(t,e,n,i){this.xCenter+=Math.floor((t-e)/2),this.yCenter+=Math.floor((n-i)/2),this.drawingArea-=Math.min(this.drawingArea/2,Math.max(t,e,n,i))}getIndexAngle(t){return kp(t*(rp/(this._pointLabels.length||1))+bp(this.options.startAngle||0))}getDistanceFromCenterForValue(t){if(zf(t))return NaN;const e=this.drawingArea/(this.max-this.min);return this.options.reverse?(this.max-t)*e:(t-this.min)*e}getValueForDistanceFromCenter(t){if(zf(t))return NaN;const e=t/(this.drawingArea/(this.max-this.min));return this.options.reverse?this.max-e:this.min+e}getPointLabelContext(t){const e=this._pointLabels||[];if(t>=0&&t<e.length){const n=e[t];return function(t,e,n){return Pg(t,{label:n,index:e,type:"pointLabel"})}(this.getContext(),t,n)}}getPointPosition(t,e,n=0){const i=this.getIndexAngle(t)-lp+n;return{x:Math.cos(i)*e+this.xCenter,y:Math.sin(i)*e+this.yCenter,angle:i}}getPointPositionForValue(t,e){return this.getPointPosition(t,this.getDistanceFromCenterForValue(e))}getBasePosition(t){return this.getPointPositionForValue(t||0,this.getBaseValue())}getPointLabelPosition(t){const{left:e,top:n,right:i,bottom:r}=this._pointLabelItems[t];return{left:e,top:n,right:i,bottom:r}}drawBackground(){const{backgroundColor:t,grid:{circular:e}}=this.options;if(t){const n=this.ctx;n.save(),n.beginPath(),xy(this,this.getDistanceFromCenterForValue(this._endValue),e,this._pointLabels.length),n.closePath(),n.fillStyle=t,n.fill(),n.restore()}}drawGrid(){const t=this.ctx,e=this.options,{angleLines:n,grid:i,border:r}=e,a=this._pointLabels.length;let s,o,l;if(e.pointLabels.display&&function(t,e){const{ctx:n,options:{pointLabels:i}}=t;for(let r=e-1;r>=0;r--){const e=t._pointLabelItems[r];if(!e.visible)continue;const a=i.setContext(t.getPointLabelContext(r));by(n,a,e);const s=Mg(a.font),{x:o,y:l,textAlign:c}=e;bg(n,t._pointLabels[r],o,l+s.lineHeight/2,s,{color:a.color,textAlign:c,textBaseline:"middle"})}}(this,a),i.display&&this.ticks.forEach(((t,e)=>{if(0!==e||0===e&&this.min<0){o=this.getDistanceFromCenterForValue(t.value);const n=this.getContext(e),s=i.setContext(n),l=r.setContext(n);!function(t,e,n,i,r){const a=t.ctx,s=e.circular,{color:o,lineWidth:l}=e;!s&&!i||!o||!l||n<0||(a.save(),a.strokeStyle=o,a.lineWidth=l,a.setLineDash(r.dash||[]),a.lineDashOffset=r.dashOffset,a.beginPath(),xy(t,n,s,i),a.closePath(),a.stroke(),a.restore())}(this,s,o,a,l)}})),n.display){for(t.save(),s=a-1;s>=0;s--){const i=n.setContext(this.getPointLabelContext(s)),{color:r,lineWidth:a}=i;a&&r&&(t.lineWidth=a,t.strokeStyle=r,t.setLineDash(i.borderDash),t.lineDashOffset=i.borderDashOffset,o=this.getDistanceFromCenterForValue(e.reverse?this.min:this.max),l=this.getPointPosition(s,o),t.beginPath(),t.moveTo(this.xCenter,this.yCenter),t.lineTo(l.x,l.y),t.stroke())}t.restore()}}drawBorder(){}drawLabels(){const t=this.ctx,e=this.options,n=e.ticks;if(!n.display)return;const i=this.getIndexAngle(0);let r,a;t.save(),t.translate(this.xCenter,this.yCenter),t.rotate(i),t.textAlign="center",t.textBaseline="middle",this.ticks.forEach(((i,s)=>{if(0===s&&this.min>=0&&!e.reverse)return;const o=n.setContext(this.getContext(s)),l=Mg(o.font);if(r=this.getDistanceFromCenterForValue(this.ticks[s].value),o.showLabelBackdrop){t.font=l.string,a=t.measureText(i.label).width,t.fillStyle=o.backdropColor;const e=Cg(o.backdropPadding);t.fillRect(-a/2-e.left,-r-l.size/2-e.top,a+e.width,l.size+e.height)}bg(t,i.label,0,-r,l,{color:o.color,strokeColor:o.textStrokeColor,strokeWidth:o.textStrokeWidth})})),t.restore()}drawTitle(){}}e(vy,"id","radialLinear"),e(vy,"defaults",{display:!0,animate:!0,position:"chartArea",angleLines:{display:!0,lineWidth:1,borderDash:[],borderDashOffset:0},grid:{circular:!1},startAngle:0,ticks:{showLabelBackdrop:!0,callback:Gp.formatters.numeric},pointLabels:{backdropColor:void 0,backdropPadding:2,display:!0,font:{size:10},callback:t=>t,padding:5,centerPointLabels:!1}}),e(vy,"defaultRoutes",{"angleLines.color":"borderColor","pointLabels.color":"color","ticks.color":"color"}),e(vy,"descriptors",{angleLines:{_fallback:"grid"}});const yy={millisecond:{common:!0,size:1,steps:1e3},second:{common:!0,size:1e3,steps:60},minute:{common:!0,size:6e4,steps:60},hour:{common:!0,size:36e5,steps:24},day:{common:!0,size:864e5,steps:30},week:{common:!1,size:6048e5,steps:4},month:{common:!0,size:2628e6,steps:12},quarter:{common:!1,size:7884e6,steps:4},year:{common:!0,size:3154e7}},_y=Object.keys(yy);function wy(t,e){return t-e}function ky(t,e){if(zf(e))return null;const n=t._adapter,{parser:i,round:r,isoWeekday:a}=t._parseOpts;let s=e;return"function"==typeof i&&(s=i(s)),Ff(s)||(s="string"==typeof i?n.parse(s,i):n.parse(s)),null===s?null:(r&&(s="week"!==r||!gp(a)&&!0!==a?n.startOf(s,r):n.startOf(s,"isoWeek",a)),+s)}function Sy(t,e,n,i){const r=_y.length;for(let a=_y.indexOf(t);a<r-1;++a){const t=yy[_y[a]],r=t.steps?t.steps:Number.MAX_SAFE_INTEGER;if(t.common&&Math.ceil((n-e)/(r*t.size))<=i)return _y[a]}return _y[r-1]}function Cy(t,e,n){if(n){if(n.length){const{lo:i,hi:r}=Ep(n,e);t[n[i]>=e?n[i]:n[r]]=!0}}else t[e]=!0}function My(t,e,n){const i=[],r={},a=e.length;let s,o;for(s=0;s<a;++s)o=e[s],r[o]=s,i.push({value:o,major:!1});return 0!==a&&n?function(t,e,n,i){const r=t._adapter,a=+r.startOf(e[0].value,i),s=e[e.length-1].value;let o,l;for(o=a;o<=s;o=+r.add(o,1,i))l=n[o],l>=0&&(e[l].major=!0);return e}(t,i,r,n):i}class Ey extends Jb{constructor(t){super(t),this._cache={data:[],labels:[],all:[]},this._unit="day",this._majorUnit=void 0,this._offsets={},this._normalized=!1,this._parseOpts=void 0}init(t,e={}){const n=t.time||(t.time={}),i=this._adapter=new rb(t.adapters.date);i.init(e),Xf(n.displayFormats,i.formats()),this._parseOpts={parser:n.parser,round:n.round,isoWeekday:n.isoWeekday},super.init(t),this._normalized=e.normalized}parse(t,e){return void 0===t?null:ky(this,t)}beforeLayout(){super.beforeLayout(),this._cache={data:[],labels:[],all:[]}}determineDataLimits(){const t=this.options,e=this._adapter,n=t.time.unit||"day";let{min:i,max:r,minDefined:a,maxDefined:s}=this.getUserBounds();function o(t){a||isNaN(t.min)||(i=Math.min(i,t.min)),s||isNaN(t.max)||(r=Math.max(r,t.max))}a&&s||(o(this._getLabelBounds()),"ticks"===t.bounds&&"labels"===t.ticks.source||o(this.getMinMax(!1))),i=Ff(i)&&!isNaN(i)?i:+e.startOf(Date.now(),n),r=Ff(r)&&!isNaN(r)?r:+e.endOf(Date.now(),n)+1,this.min=Math.min(i,r-1),this.max=Math.max(i+1,r)}_getLabelBounds(){const t=this.getLabelTimestamps();let e=Number.POSITIVE_INFINITY,n=Number.NEGATIVE_INFINITY;return t.length&&(e=t[0],n=t[t.length-1]),{min:e,max:n}}buildTicks(){const t=this.options,e=t.time,n=t.ticks,i="labels"===n.source?this.getLabelTimestamps():this._generate();"ticks"===t.bounds&&i.length&&(this.min=this._userMin||i[0],this.max=this._userMax||i[i.length-1]);const r=this.min,a=function(t,e,n){let i=0,r=t.length;for(;i<r&&t[i]<e;)i++;for(;r>i&&t[r-1]>n;)r--;return i>0||r<t.length?t.slice(i,r):t}(i,r,this.max);return this._unit=e.unit||(n.autoSkip?Sy(e.minUnit,this.min,this.max,this._getLabelCapacity(r)):function(t,e,n,i,r){for(let a=_y.length-1;a>=_y.indexOf(n);a--){const n=_y[a];if(yy[n].common&&t._adapter.diff(r,i,n)>=e-1)return n}return _y[n?_y.indexOf(n):0]}(this,a.length,e.minUnit,this.min,this.max)),this._majorUnit=n.major.enabled&&"year"!==this._unit?function(t){for(let e=_y.indexOf(t)+1,n=_y.length;e<n;++e)if(yy[_y[e]].common)return _y[e]}(this._unit):void 0,this.initOffsets(i),t.reverse&&a.reverse(),My(this,a,this._majorUnit)}afterAutoSkip(){this.options.offsetAfterAutoskip&&this.initOffsets(this.ticks.map((t=>+t.value)))}initOffsets(t=[]){let e,n,i=0,r=0;this.options.offset&&t.length&&(e=this.getDecimalForValue(t[0]),i=1===t.length?1-e:(this.getDecimalForValue(t[1])-e)/2,n=this.getDecimalForValue(t[t.length-1]),r=1===t.length?n:(n-this.getDecimalForValue(t[t.length-2]))/2);const a=t.length<3?.5:.25;i=Cp(i,0,a),r=Cp(r,0,a),this._offsets={start:i,end:r,factor:1/(i+1+r)}}_generate(){const t=this._adapter,e=this.min,n=this.max,i=this.options,r=i.time,a=r.unit||Sy(r.minUnit,e,n,this._getLabelCapacity(e)),s=Vf(i.ticks.stepSize,1),o="week"===a&&r.isoWeekday,l=gp(o)||!0===o,c={};let u,d,h=e;if(l&&(h=+t.startOf(h,"isoWeek",o)),h=+t.startOf(h,l?"day":a),t.diff(n,e,a)>1e5*s)throw new Error(e+" and "+n+" are too far apart with stepSize of "+s+" "+a);const f="data"===i.ticks.source&&this.getDataTimestamps();for(u=h,d=0;u<n;u=+t.add(u,s,a),d++)Cy(c,u,f);return u!==n&&"ticks"!==i.bounds&&1!==d||Cy(c,u,f),Object.keys(c).sort(wy).map((t=>+t))}getLabelForValue(t){const e=this._adapter,n=this.options.time;return n.tooltipFormat?e.format(t,n.tooltipFormat):e.format(t,n.displayFormats.datetime)}format(t,e){const n=this.options.time.displayFormats,i=this._unit,r=e||n[i];return this._adapter.format(t,r)}_tickFormatFunction(t,e,n,i){const r=this.options,a=r.ticks.callback;if(a)return Wf(a,[t,e,n],this);const s=r.time.displayFormats,o=this._unit,l=this._majorUnit,c=o&&s[o],u=l&&s[l],d=n[e],h=l&&u&&d&&d.major;return this._adapter.format(t,i||(h?u:c))}generateTickLabels(t){let e,n,i;for(e=0,n=t.length;e<n;++e)i=t[e],i.label=this._tickFormatFunction(i.value,e,t)}getDecimalForValue(t){return null===t?NaN:(t-this.min)/(this.max-this.min)}getPixelForValue(t){const e=this._offsets,n=this.getDecimalForValue(t);return this.getPixelForDecimal((e.start+n)*e.factor)}getValueForPixel(t){const e=this._offsets,n=this.getDecimalForPixel(t)/e.factor-e.end;return this.min+n*(this.max-this.min)}_getLabelSize(t){const e=this.options.ticks,n=this.ctx.measureText(t).width,i=bp(this.isHorizontal()?e.maxRotation:e.minRotation),r=Math.cos(i),a=Math.sin(i),s=this._resolveTickFontOptions(0).size;return{w:n*r+s*a,h:n*a+s*r}}_getLabelCapacity(t){const e=this.options.time,n=e.displayFormats,i=n[e.unit]||n.millisecond,r=this._tickFormatFunction(t,0,My(this,[t],this._majorUnit),i),a=this._getLabelSize(r),s=Math.floor(this.isHorizontal()?this.width/a.w:this.height/a.h)-1;return s>0?s:1}getDataTimestamps(){let t,e,n=this._cache.data||[];if(n.length)return n;const i=this.getMatchingVisibleMetas();if(this._normalized&&i.length)return this._cache.data=i[0].controller.getAllParsedValues(this);for(t=0,e=i.length;t<e;++t)n=n.concat(i[t].controller.getAllParsedValues(this));return this._cache.data=this.normalize(n)}getLabelTimestamps(){const t=this._cache.labels||[];let e,n;if(t.length)return t;const i=this.getLabels();for(e=0,n=i.length;e<n;++e)t.push(ky(this,i[e]));return this._cache.labels=this._normalized?t:this.normalize(t)}normalize(t){return Op(t.sort(wy))}}function Py(t,e,n){let i,r,a,s,o=0,l=t.length-1;n?(e>=t[o].pos&&e<=t[l].pos&&({lo:o,hi:l}=Pp(t,"pos",e)),({pos:i,time:a}=t[o]),({pos:r,time:s}=t[l])):(e>=t[o].time&&e<=t[l].time&&({lo:o,hi:l}=Pp(t,"time",e)),({time:i,pos:a}=t[o]),({time:r,pos:s}=t[l]));const c=r-i;return c?a+(s-a)*(e-i)/c:a}e(Ey,"id","time"),e(Ey,"defaults",{bounds:"data",adapters:{},time:{parser:!1,unit:!1,round:!1,isoWeekday:!1,minUnit:"millisecond",displayFormats:{}},ticks:{source:"auto",callback:!1,major:{enabled:!1}}});class Ny extends Ey{constructor(t){super(t),this._table=[],this._minPos=void 0,this._tableRange=void 0}initOffsets(){const t=this._getTimestampsForTable(),e=this._table=this.buildLookupTable(t);this._minPos=Py(e,this.min),this._tableRange=Py(e,this.max)-this._minPos,super.initOffsets(t)}buildLookupTable(t){const{min:e,max:n}=this,i=[],r=[];let a,s,o,l,c;for(a=0,s=t.length;a<s;++a)l=t[a],l>=e&&l<=n&&i.push(l);if(i.length<2)return[{time:e,pos:0},{time:n,pos:1}];for(a=0,s=i.length;a<s;++a)c=i[a+1],o=i[a-1],l=i[a],Math.round((c+o)/2)!==l&&r.push({time:l,pos:a/(s-1)});return r}_generate(){const t=this.min,e=this.max;let n=super.getDataTimestamps();return n.includes(t)&&n.length||n.splice(0,0,t),n.includes(e)&&1!==n.length||n.push(e),n.sort(((t,e)=>t-e))}_getTimestampsForTable(){let t=this._cache.all||[];if(t.length)return t;const e=this.getDataTimestamps(),n=this.getLabelTimestamps();return t=e.length&&n.length?this.normalize(e.concat(n)):e.length?e:n,t=this._cache.all=t,t}getDecimalForValue(t){return(Py(this._table,t)-this._minPos)/this._tableRange}getValueForPixel(t){const e=this._offsets,n=this.getDecimalForPixel(t)/e.factor-e.end;return Py(this._table,n*this._tableRange+this._minPos,!0)}}e(Ny,"id","timeseries"),e(Ny,"defaults",Ey.defaults);const Dy=[eb,tv,Gv,Object.freeze({__proto__:null,CategoryScale:ty,LinearScale:ry,LogarithmicScale:uy,RadialLinearScale:vy,TimeScale:Ey,TimeSeriesScale:Ny})];Nx.register(...Dy);const Ty=({type:t,data:e})=>{const n=V.useRef(null),i=V.useRef(null);return V.useEffect((()=>{if(i.current&&i.current.destroy(),n.current&&e){const r=n.current.getContext("2d");r&&(i.current=new Nx(r,{type:t,data:e,options:{responsive:!0,maintainAspectRatio:!1,plugins:{legend:{position:"bottom",labels:{boxWidth:12,padding:15}},tooltip:{backgroundColor:"#0F172A",titleColor:"#FFFFFF",bodyColor:"#FFFFFF",padding:12,cornerRadius:4}}}}))}return()=>{i.current&&i.current.destroy()}}),[t,e]),e?G.jsx("div",{className:"w-full h-full",children:G.jsx("canvas",{ref:n})}):G.jsx("div",{className:"flex items-center justify-center h-full",children:G.jsx("p",{className:"text-slate-500",children:"No data available"})})},Oy=()=>{const[t,e]=V.useState([]),[n,i]=V.useState(null),[r,a]=V.useState([]),[s,o]=V.useState(null),[l,c]=V.useState(null),[u,d]=V.useState("bar"),[h,f]=V.useState({}),[p,g]=V.useState(null),[m,b]=V.useState(!1),[x,v]=V.useState(null);V.useEffect((()=>{(async()=>{try{b(!0);const t=await jh();e(t),v(null)}catch(t){v(t instanceof Error?t.message:"Failed to load connections")}finally{b(!1)}})()}),[]),V.useEffect((()=>{(async()=>{if(n)try{b(!0);const t=await Ih(n);a(t),v(null)}catch(t){v(t instanceof Error?t.message:"Failed to load tables")}finally{b(!1)}})()}),[n]),V.useEffect((()=>{(async()=>{if(n&&s)try{b(!0);const t=await Vh(n,s);c(t),v(null)}catch(t){v(t instanceof Error?t.message:"Failed to load table schema")}finally{b(!1)}})()}),[n,s]),V.useEffect((()=>{(async()=>{if(n&&s&&l&&0!==Object.keys(h).length)try{b(!0);const t=await Wh(n,s),e=[],i=[];t.data.forEach((t=>{"bar"===u||"line"===u?(e.push(t[h.x]),i.push(parseFloat(t[h.y])||0)):"pie"===u||"doughnut"===u?(e.push(t[h.labels]),i.push(parseFloat(t[h.values])||0)):"scatter"===u&&(e.push(t[h.x]),i.push(parseFloat(t[h.y])||0))}));g({labels:e,datasets:[{label:"Dataset",data:i,backgroundColor:"bar"===u?"#2563EB":"line"===u?"rgba(37, 99, 235, 0.2)":["#2563EB","#D946EF","#F59E0B","#10B981","#6366F1","#EF4444","#8B5CF6","#EC4899","#06B6D4","#84CC16"],borderColor:"line"===u?"#2563EB":void 0,borderWidth:2}]}),v(null)}catch(t){v(t instanceof Error?t.message:"Failed to generate chart data")}finally{b(!1)}})()}),[n,s,u,h,l]);return G.jsxs("div",{className:"space-y-6",children:[G.jsx("div",{className:"flex justify-between items-center",children:G.jsx("h1",{className:"text-3xl font-semibold text-slate-900",children:"Visualization Builder"})}),x&&G.jsx("div",{className:"p-4 bg-red-50 border border-red-200 rounded-md text-red-700",children:x}),G.jsxs("div",{className:"grid grid-cols-1 lg:grid-cols-3 gap-6",children:[G.jsxs("div",{className:"lg:col-span-1 space-y-6",children:[G.jsxs("div",{className:"bg-white p-6 rounded-md border border-slate-200",children:[G.jsx("h2",{className:"text-xl font-medium text-slate-900 mb-4",children:"Data Source"}),G.jsxs("div",{className:"space-y-4",children:[G.jsxs("div",{className:"space-y-1",children:[G.jsx("label",{className:"block text-sm font-medium text-slate-700",children:"Connection"}),G.jsxs("select",{className:"w-full px-3 py-2 border border-slate-300 rounded-sm text-sm",value:n||"",onChange:t=>{return e=t.target.value,i(e),o(null),c(null),f({}),void g(null);var e},disabled:m,children:[G.jsx("option",{value:"",children:"Select a connection"}),t.map((t=>G.jsx("option",{value:t.id.toString(),children:t.name},t.id)))]})]}),n&&G.jsxs("div",{className:"space-y-1",children:[G.jsx("label",{className:"block text-sm font-medium text-slate-700",children:"Table"}),G.jsxs("select",{className:"w-full px-3 py-2 border border-slate-300 rounded-sm text-sm",value:s||"",onChange:t=>{return e=t.target.value,o(e),f({}),void g(null);var e},disabled:m||0===r.length,children:[G.jsx("option",{value:"",children:"Select a table"}),r.map((t=>G.jsx("option",{value:t.name,children:t.name},t.name)))]})]})]})]}),G.jsxs("div",{className:"bg-white p-6 rounded-md border border-slate-200",children:[G.jsx("h2",{className:"text-xl font-medium text-slate-900 mb-4",children:"Chart Type"}),G.jsx(Gh,{selected:u,onChange:t=>{d(t),f({}),g(null)}})]}),G.jsxs("div",{className:"bg-white p-6 rounded-md border border-slate-200",children:[G.jsx("h2",{className:"text-xl font-medium text-slate-900 mb-4",children:"Field Mapping"}),l?G.jsx(Jh,{schema:l,chartType:u,mappings:h,onChange:t=>{f(t)}}):G.jsx("p",{className:"text-slate-500",children:"Select a table to map fields"})]})]}),G.jsx("div",{className:"lg:col-span-2",children:G.jsxs("div",{className:"bg-white p-6 rounded-md border border-slate-200 h-full",children:[G.jsxs("div",{className:"flex justify-between items-center mb-4",children:[G.jsx("h2",{className:"text-xl font-medium text-slate-900",children:"Chart Preview"}),p&&G.jsx("button",{className:"px-4 py-2 bg-primary text-white rounded text-sm font-medium hover:bg-primary-dark transition-colors",onClick:async()=>{if(n&&s&&p)try{b(!0);const t={name:`${s} ${u} chart`,type:u,connection_id:parseInt(n,10),table_name:s,config:JSON.stringify({mappings:h,chartType:u})};await $h(t),alert("Visualization saved successfully!"),v(null)}catch(t){v(t instanceof Error?t.message:"Failed to save visualization")}finally{b(!1)}else v("Cannot save visualization: missing data")},disabled:m,children:"Save Visualization"})]}),G.jsx("div",{className:"h-[500px] flex items-center justify-center",children:m?G.jsx("p",{className:"text-slate-500",children:"Loading chart data..."}):p?G.jsx(Ty,{type:u,data:p}):G.jsx("p",{className:"text-slate-500",children:"Select data source and map fields to generate a chart"})})]})})]})]})},Ly=()=>{const t=Zd(),[e,n]=V.useState([]),[i,r]=V.useState(!0),[a,s]=V.useState(null);V.useEffect((()=>{(async()=>{try{r(!0);const t=(await Hh()).map((t=>({id:t.id,name:t.name,type:t.type,connectionId:t.connection_id||0,tableName:t.table_name||"",config:"string"==typeof t.config?JSON.parse(t.config):t.config,createdAt:t.created_at,updatedAt:t.updated_at})));n(t),s(null)}catch(t){s(t instanceof Error?t.message:"Failed to load visualizations")}finally{r(!1)}})()}),[]);return G.jsxs("div",{className:"space-y-6",children:[G.jsxs("div",{className:"flex justify-between items-center",children:[G.jsx("h1",{className:"text-3xl font-semibold text-slate-900",children:"Saved Visualizations"}),G.jsx("button",{className:"px-4 py-2 bg-primary text-white rounded text-sm font-medium hover:bg-primary-dark transition-colors",onClick:()=>t("/visualize"),children:"Create New Visualization"})]}),a&&G.jsx("div",{className:"p-4 bg-red-50 border border-red-200 rounded-md text-red-700",children:a}),i?G.jsx("div",{className:"text-center p-6",children:G.jsx("p",{className:"text-slate-500",children:"Loading visualizations..."})}):e.length>0?G.jsx("div",{className:"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6",children:e.map((i=>G.jsxs("div",{className:"bg-white p-6 rounded-md border border-slate-200 shadow-sm",children:[G.jsx("div",{className:"h-48 bg-slate-100 mb-4 rounded flex items-center justify-center",children:G.jsx("span",{className:"text-slate-400",children:"Chart Preview"})}),G.jsx("h3",{className:"text-lg font-medium text-slate-900 mb-1",children:i.name}),G.jsxs("p",{className:"text-sm text-slate-500 mb-4",children:[i.type," chart showing ",i.tableName," data"]}),G.jsxs("div",{className:"flex space-x-2",children:[G.jsx("button",{className:"px-3 py-1.5 text-xs bg-slate-100 text-slate-700 rounded hover:bg-slate-200",onClick:()=>{return t=i.id,void alert(`Viewing visualization ${t}`);var t},children:"View"}),G.jsx("button",{className:"px-3 py-1.5 text-xs bg-blue-50 text-blue-700 rounded hover:bg-blue-100",onClick:()=>{return e=i.id,void t(`/visualize?edit=${e}`);var e},children:"Edit"}),G.jsx("button",{className:"px-3 py-1.5 text-xs bg-red-50 text-red-700 rounded hover:bg-red-100",onClick:()=>(async t=>{try{await Uh(t.toString()),n(e.filter((e=>e.id!==t)))}catch(i){s(i instanceof Error?i.message:"Failed to delete visualization")}})(i.id),children:"Delete"})]})]},i.id)))}):G.jsxs("div",{className:"bg-white p-6 rounded-md border border-slate-200 text-center",children:[G.jsx("p",{className:"text-slate-500 mb-4",children:"No saved visualizations yet"}),G.jsx("button",{className:"px-4 py-2 bg-primary text-white rounded text-sm font-medium hover:bg-primary-dark transition-colors",onClick:()=>t("/visualize"),children:"Create Your First Visualization"})]})]})},Ry=()=>{const t=Zd(),[e,n]=V.useState([]),[i,r]=V.useState([]),[a,s]=V.useState(null),[o,l]=V.useState(!0),[c,u]=V.useState(null);V.useEffect((()=>{(async()=>{try{l(!0);const[t,e]=await Promise.all([Yh(),jh()]);n(t),r(e),u(null)}catch(t){u(t instanceof Error?t.message:"Failed to load data")}finally{l(!1)}})()}),[]);return G.jsxs("div",{className:"space-y-6",children:[G.jsx("div",{className:"flex justify-between items-center",children:G.jsx("h1",{className:"text-3xl font-semibold text-slate-900",children:"Insight Templates"})}),c&&G.jsx("div",{className:"p-4 bg-red-50 border border-red-200 rounded-md text-red-700",children:c}),G.jsxs("div",{className:"bg-white p-6 rounded-md border border-slate-200",children:[G.jsx("h2",{className:"text-lg font-medium text-slate-900 mb-4",children:"Select Database Connection"}),G.jsxs("select",{className:"w-full px-3 py-2 border border-slate-300 rounded-sm text-sm",value:a||"",onChange:t=>s(t.target.value),disabled:o||0===i.length,children:[G.jsx("option",{value:"",children:"Select a connection"}),i.map((t=>G.jsx("option",{value:t.id.toString(),children:t.name},t.id)))]})]}),o?G.jsx("div",{className:"text-center p-6",children:G.jsx("p",{className:"text-slate-500",children:"Loading templates..."})}):e.length>0?G.jsx("div",{className:"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6",children:e.map((e=>G.jsxs("div",{className:"bg-white p-6 rounded-md border border-slate-200 shadow-sm",children:[G.jsx("h3",{className:"text-lg font-medium text-slate-900 mb-1",children:e.name}),G.jsx("p",{className:"text-sm text-slate-500 mb-4",children:e.description}),G.jsxs("div",{className:"text-xs text-slate-500 mb-4",children:[G.jsxs("span",{className:"inline-block px-2 py-1 bg-blue-50 text-blue-700 rounded mr-2",children:[e.type," Chart"]}),e.category&&G.jsx("span",{className:"inline-block px-2 py-1 bg-green-50 text-green-700 rounded",children:e.category})]}),G.jsx("button",{className:"w-full px-4 py-2 bg-primary text-white rounded text-sm font-medium hover:bg-primary-dark transition-colors disabled:opacity-50 disabled:cursor-not-allowed",disabled:!a,onClick:()=>{return n=e.id,void(a?t(`/templates/${n}/apply?connection=${a}`):u("Please select a connection first"));var n},children:"Apply Template"})]},e.id)))}):G.jsx("div",{className:"bg-white p-6 rounded-md border border-slate-200 text-center",children:G.jsx("p",{className:"text-slate-500",children:"No templates available"})})]})},zy=()=>G.jsxs("div",{className:"flex flex-col items-center justify-center py-12",children:[G.jsx("h1",{className:"text-5xl font-bold text-slate-900 mb-4",children:"404"}),G.jsx("p",{className:"text-xl text-slate-600 mb-8",children:"Page not found"}),G.jsx(Ch,{to:"/",className:"px-4 py-2 bg-primary text-white rounded text-sm font-medium hover:bg-primary-dark transition-colors",children:"Go back home"})]}),jy=()=>G.jsx(ph,{children:G.jsxs(hh,{path:"/",element:G.jsx(Oh,{}),children:[G.jsx(hh,{index:!0,element:G.jsx(Qh,{})}),G.jsx(hh,{path:"connections/:id/tables",element:G.jsx(Kh,{})}),G.jsx(hh,{path:"visualize",element:G.jsx(Oy,{})}),G.jsx(hh,{path:"gallery",element:G.jsx(Ly,{})}),G.jsx(hh,{path:"templates",element:G.jsx(Ry,{})}),G.jsx(hh,{path:"*",element:G.jsx(zy,{})})]})});document.addEventListener("DOMContentLoaded",(()=>{const t=document.getElementById("root");if(t){t.innerHTML="";J.createRoot(t).render(G.jsx(wh,{children:G.jsx(jy,{})}))}}));
</file>

<file path="client/dist/assets/index-991a2c60.css">
@tailwind base;@tailwind components;@tailwind utilities;@layer base{:root{--chart-height-sm: 200px;--chart-height-md: 300px;--chart-height-lg: 400px;--transition-duration-default: .15s;--transition-duration-long: .3s;--shadow-color: 215 25% 27%}html{@apply text-slate-900;}body{@apply bg-slate-50;}h1,h2,h3,h4,h5,h6{@apply font-medium;}}@layer components{.btn-primary{@apply px-4 py-2 bg-primary text-white rounded hover:bg-primary-dark focus:outline-none focus:ring-2 focus:ring-primary focus:ring-opacity-50 transition-colors font-medium text-sm;}.btn-secondary{@apply px-4 py-2 bg-white text-slate-900 border border-slate-300 rounded hover:bg-slate-50 focus:outline-none focus:ring-2 focus:ring-primary focus:ring-opacity-50 transition-colors font-medium text-sm;}.btn-tertiary{@apply px-3 py-1.5 text-primary rounded hover:bg-blue-50 focus:outline-none focus:ring-2 focus:ring-primary focus:ring-opacity-50 transition-colors font-medium text-sm;}.form-input{@apply w-full px-3 py-2 border border-slate-300 rounded-sm text-sm text-slate-900 placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-primary focus:border-primary;}.card{@apply bg-white border border-slate-200 rounded p-4 shadow-sm;}.card-interactive{@apply bg-white border border-slate-200 rounded p-4 shadow-sm hover:shadow transition-shadow;}.tab-active{@apply py-3 border-b-2 border-primary font-medium text-sm text-primary;}.tab-inactive{@apply py-3 border-b-2 border-transparent font-medium text-sm text-slate-500 hover:text-slate-700 hover:border-slate-300;}}.chart-container{position:relative;height:var(--chart-height-md);width:100%}.hover-transition{@apply transition-colors duration-150 ease-in-out;}.modal-transition{@apply transition-opacity duration-300 ease-in-out;}.expand-transition{@apply transition-all duration-300 ease-out;}
</file>

<file path="client/dist/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="/vite.svg" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <title>SQLite Visualizer</title>
  <style>
    /* Ensure we only display one sidebar */
    #root > div:not(:first-child) {
      display: none;
    }
  </style>
  <script type="module" crossorigin src="/assets/index-967cdcaf.js"></script>
  <link rel="stylesheet" href="/assets/index-991a2c60.css">
</head>
<body>
  <!-- Single root element for React application -->
  <div id="root"></div>
  
</body>
</html>
</file>

<file path="client/dist/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="client/public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="client/src/components/common/ExportButton.tsx">
import { FC, useState } from 'react';
import { Download, ChevronDown, FileText, FileJson } from 'lucide-react';
import { API_BASE_URL } from '../../config';

export interface ExportFormat {
  id: string;
  name: string;
  extension: string;
  mimeType: string;
}

export interface ExportButtonProps {
  /**
   * Type of export (table or visualization)
   */
  type: 'table' | 'visualization';
  
  /**
   * ID of the connection (for table exports)
   */
  connectionId?: number;
  
  /**
   * Table name (for table exports)
   */
  tableName?: string;
  
  /**
   * Visualization ID (for visualization exports)
   */
  visualizationId?: number;
  
  /**
   * Filters to apply to table export
   */
  filters?: Record<string, any>;
  
  /**
   * Sort configuration for table export
   */
  sort?: {
    column: string;
    direction: 'asc' | 'desc';
  };
  
  /**
   * Max rows to export (for table exports)
   */
  limit?: number;
  
  /**
   * CSS classes for the button
   */
  className?: string;
  
  /**
   * Whether to include schema metadata (for JSON exports)
   */
  includeSchema?: boolean;
}

/**
 * ExportButton Component
 * 
 * A dropdown button that allows exporting data in various formats.
 * Supports exporting both tables and visualizations.
 */
const ExportButton: FC<ExportButtonProps> = ({
  type,
  connectionId,
  tableName,
  visualizationId,
  filters = {},
  sort,
  limit = 1000,
  className = '',
  includeSchema = true
}) => {
  // Local state
  const [isOpen, setIsOpen] = useState(false);
  const [isExporting, setIsExporting] = useState(false);
  
  // Available export formats
  const formats: ExportFormat[] = [
    { id: 'csv', name: 'CSV (Comma Separated Values)', extension: 'csv', mimeType: 'text/csv' },
    { id: 'json', name: 'JSON (JavaScript Object Notation)', extension: 'json', mimeType: 'application/json' }
  ];
  
  // Toggle dropdown
  const toggleDropdown = () => {
    setIsOpen(!isOpen);
  };
  
  // Close dropdown
  const closeDropdown = () => {
    setIsOpen(false);
  };
  
  // Handle export
  const handleExport = async (format: ExportFormat) => {
    closeDropdown();
    setIsExporting(true);
    
    try {
      // Build export URL based on type
      let url = `${API_BASE_URL}/export/${format.id}`;
      
      if (type === 'visualization' && visualizationId) {
        // Visualization export
        url = `${url}/${visualizationId}`;
      } else if (type === 'table' && connectionId && tableName) {
        // Table export
        url = `${url}/table/${connectionId}/${tableName}`;
        
        // Add query parameters for filtering, sorting, and pagination
        const queryParams = new URLSearchParams();
        
        // Add limit
        if (limit) {
          queryParams.append('limit', limit.toString());
        }
        
        // Add filters if any
        if (Object.keys(filters).length > 0) {
          queryParams.append('filter', JSON.stringify(filters));
        }
        
        // Add sort if any
        if (sort && sort.column) {
          queryParams.append('sort', JSON.stringify({
            column: sort.column,
            direction: sort.direction || 'asc'
          }));
        }
        
        // Add includeSchema for JSON exports
        if (format.id === 'json') {
          queryParams.append('includeSchema', includeSchema.toString());
        }
        
        // Append query parameters to URL
        if (queryParams.toString()) {
          url = `${url}?${queryParams.toString()}`;
        }
      } else {
        throw new Error('Invalid export configuration');
      }
      
      // Trigger download
      window.open(url, '_blank');
    } catch (error) {
      console.error('Export failed:', error);
      alert('Failed to export data. Please try again.');
    } finally {
      setIsExporting(false);
    }
  };
  
  // Validate props
  if ((type === 'visualization' && !visualizationId) || 
      (type === 'table' && (!connectionId || !tableName))) {
    console.warn('ExportButton: Missing required props for export type', { type, connectionId, tableName, visualizationId });
    return null;
  }
  
  return (
    <div className="relative">
      <button
        className={`px-3 py-2 bg-white border border-slate-300 rounded text-sm text-slate-700 hover:bg-slate-50 focus:outline-none focus:ring-2 focus:ring-primary focus:ring-opacity-50 flex items-center space-x-1 ${className} ${isExporting ? 'opacity-75 cursor-wait' : ''}`}
        onClick={toggleDropdown}
        disabled={isExporting}
        aria-haspopup="true"
        aria-expanded={isOpen}
      >
        <Download className="h-4 w-4 mr-1" />
        <span>Export</span>
        <ChevronDown className="h-4 w-4" />
      </button>
      
      {isOpen && (
        <>
          {/* Backdrop for closing dropdown when clicking away */}
          <div 
            className="fixed inset-0 z-10" 
            onClick={closeDropdown}
          />
          
          {/* Dropdown menu */}
          <div className="absolute right-0 mt-1 py-1 w-60 bg-white border border-slate-200 rounded-md shadow-md z-20">
            <div className="px-3 py-2 text-xs font-medium text-slate-500 border-b border-slate-100">
              Export as:
            </div>
            <div className="py-1">
              {formats.map((format) => (
                <button
                  key={format.id}
                  className="w-full px-3 py-2 text-left text-sm text-slate-700 hover:bg-slate-50 focus:outline-none focus:bg-slate-50 flex items-center"
                  onClick={() => handleExport(format)}
                  disabled={isExporting}
                >
                  {format.id === 'csv' ? (
                    <FileText className="h-4 w-4 mr-2 text-slate-400" />
                  ) : (
                    <FileJson className="h-4 w-4 mr-2 text-slate-400" />
                  )}
                  <span>{format.name}</span>
                </button>
              ))}
            </div>
          </div>
        </>
      )}
      
      {/* Loading indicator (for accessibility) */}
      {isExporting && (
        <span className="sr-only" aria-live="polite">
          Exporting data, please wait...
        </span>
      )}
    </div>
  );
};

export default ExportButton;
</file>

<file path="client/src/components/templates/index.ts">
// Export all template components
export { default as TemplateList } from './TemplateList';
export { default as TemplateConfigurator } from './TemplateConfigurator';
export { default as TemplateApplyButton } from './TemplateApplyButton';
export { default as TemplatePreview } from './TemplatePreview';
export { default as TemplateFieldMapper } from './TemplateFieldMapper';
export { default as TemplateCard } from './TemplateCard';
</file>

<file path="client/src/components/templates/TemplateApplyButton.tsx">
import { FC } from 'react';

interface TemplateApplyButtonProps {
  templateId: string | number;
  connectionId: string | null;
  onClick: (templateId: string | number) => void;
  disabled?: boolean;
  className?: string;
  label?: string;
}

/**
 * TemplateApplyButton Component
 * 
 * A reusable button for applying templates
 */
const TemplateApplyButton: FC<TemplateApplyButtonProps> = ({
  templateId,
  connectionId,
  onClick,
  disabled = false,
  className = '',
  label = 'Apply Template'
}) => {
  return (
    <button 
      className={`px-4 py-2 bg-blue-600 text-white rounded text-sm font-medium 
                 hover:bg-blue-700 transition-colors 
                 disabled:opacity-50 disabled:cursor-not-allowed ${className}`}
      disabled={!connectionId || disabled}
      onClick={() => onClick(templateId)}
      title={!connectionId ? 'Select a database connection first' : undefined}
    >
      {label}
    </button>
  );
};

export default TemplateApplyButton;
</file>

<file path="client/src/components/templates/TemplateCard.tsx">
import { FC } from 'react';
import { Template } from '../../types';
import TemplateApplyButton from './TemplateApplyButton';

interface TemplateCardProps {
  template: Template;
  connectionId: string | null;
  onApply: (templateId: string | number) => void;
  className?: string;
}

/**
 * TemplateCard Component
 * 
 * Displays a single template card with description and apply button
 */
const TemplateCard: FC<TemplateCardProps> = ({
  template,
  connectionId,
  onApply,
  className = ''
}) => {
  // Get appropriate icon based on chart type
  const getChartIcon = (type: string): string => {
    switch (type.toLowerCase()) {
      case 'bar':
        return '📊';
      case 'line':
        return '📈';
      case 'pie':
      case 'doughnut':
        return '🍩';
      case 'scatter':
        return '🔵';
      case 'radar':
        return '🕸️';
      case 'area':
        return '📉';
      default:
        return '📊';
    }
  };
  
  return (
    <div className={`bg-white p-6 rounded-md border border-slate-200 shadow-sm hover:shadow transition-shadow ${className}`}>
      <div className="flex justify-between items-start mb-2">
        <h3 className="text-lg font-medium text-slate-900">{template.name}</h3>
        <span className="text-2xl" title={`${template.type} Chart`}>
          {getChartIcon(template.type)}
        </span>
      </div>
      
      <p className="text-sm text-slate-500 mb-4">
        {template.description || 'No description available'}
      </p>
      
      <div className="flex flex-wrap gap-2 mb-4">
        <span className="inline-block px-2 py-1 bg-blue-50 text-blue-700 text-xs rounded capitalize">
          {template.type} Chart
        </span>
        
        {template.category && (
          <span className="inline-block px-2 py-1 bg-green-50 text-green-700 text-xs rounded capitalize">
            {template.category}
          </span>
        )}
        
        {template.isDefault && (
          <span className="inline-block px-2 py-1 bg-amber-50 text-amber-700 text-xs rounded">
            Built-in
          </span>
        )}
      </div>
      
      <TemplateApplyButton 
        templateId={template.id}
        connectionId={connectionId}
        onClick={onApply}
        className="w-full"
      />
    </div>
  );
};

export default TemplateCard;
</file>

<file path="client/src/components/visualization/ChartRenderer.tsx.backup">
import { useRef, useEffect } from 'react';
import Chart from 'chart.js/auto';

/**
 * Chart Renderer Component
 * 
 * Renders various types of charts using Chart.js
 */
function ChartRenderer({ type, data }) {
  const chartRef = useRef(null);
  const chartInstance = useRef(null);
  
  useEffect(() => {
    // Destroy existing chart if it exists
    if (chartInstance.current) {
      chartInstance.current.destroy();
    }
    
    // Create new chart
    if (chartRef.current && data) {
      const ctx = chartRef.current.getContext('2d');
      
      chartInstance.current = new Chart(ctx, {
        type: type,
        data: data,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'bottom',
              labels: {
                boxWidth: 12,
                padding: 15
              }
            },
            tooltip: {
              backgroundColor: '#0F172A',
              titleColor: '#FFFFFF',
              bodyColor: '#FFFFFF',
              padding: 12,
              cornerRadius: 4
            }
          }
        }
      });
    }
    
    // Cleanup on unmount
    return () => {
      if (chartInstance.current) {
        chartInstance.current.destroy();
      }
    };
  }, [type, data]);
  
  if (!data) {
    return (
      <div className="flex items-center justify-center h-full">
        <p className="text-slate-500">No data available</p>
      </div>
    );
  }
  
  return (
    <div className="w-full h-full">
      <canvas ref={chartRef}></canvas>
    </div>
  );
}

export default ChartRenderer;
</file>

<file path="client/src/pages/SavedVisualizations.tsx.backup">
import { useState, useEffect } from 'react'
import { useNavigate, useParams } from 'react-router-dom'
import { toast } from 'react-hot-toast'
import { visualizationApi, exportApi } from '../services/api'
import ChartRenderer from '../components/visualization/ChartRenderer'

// TypeScript interfaces
interface Visualization {
  id: number;
  connection_id: number;
  name: string;
  type: string;
  config: string;
  table_name: string;
  created_at: string;
  updated_at: string;
}

interface ChartData {
  labels?: string[];
  datasets: {
    label?: string;
    data: any[];
    backgroundColor?: string | string[];
    borderColor?: string;
    borderWidth?: number;
    tension?: number;
    fill?: boolean;
    pointRadius?: number;
    pointHoverRadius?: number;
  }[];
}

/**
 * Saved Visualizations Page
 * 
 * Displays and manages saved visualizations
 */
function SavedVisualizations() {
  const navigate = useNavigate();
  const [visualizations, setVisualizations] = useState<Visualization[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [previewData, setPreviewData] = useState<Record<number, ChartData | null>>({});
  const [previewLoading, setPreviewLoading] = useState<Record<number, boolean>>({});
  const [selectedVisualization, setSelectedVisualization] = useState<Visualization | null>(null);
  const [viewMode, setViewMode] = useState<boolean>(false);
  const [fullChartData, setFullChartData] = useState<ChartData | null>(null);
  const [fullChartLoading, setFullChartLoading] = useState<boolean>(false);
  
  // Fetch all saved visualizations on component mount
  useEffect(() => {
    const fetchVisualizations = async () => {
      try {
        setLoading(true);
        setError(null);
        const data = await visualizationApi.getAll();
        setVisualizations(data);
      } catch (err: any) {
        console.error('Failed to fetch visualizations:', err);
        setError(err.message || 'Failed to load saved visualizations');
      } finally {
        setLoading(false);
      }
    };

    fetchVisualizations();
  }, []);
  
  // Load visualization previews after we have the visualization list
  useEffect(() => {
    const loadVisualizationPreviews = async () => {
      // Only load previews for the first few visualizations to avoid too many requests
      const visualizationsToPreview = visualizations.slice(0, 6);
      
      for (const viz of visualizationsToPreview) {
        await generatePreviewData(viz);
      }
    };
    
    if (visualizations.length > 0) {
      loadVisualizationPreviews();
    }
  }, [visualizations]);
  
  // Generate preview data for a visualization
  const generatePreviewData = async (visualization: Visualization) => {
    if (previewData[visualization.id]) return;
    
    try {
      setPreviewLoading(prev => ({ ...prev, [visualization.id]: true }));
      
      // Get the config data
      const config = JSON.parse(visualization.config);
      
      // Fetch a sample of the data from the table
      const tableSample = await visualizationApi.getSampleData(
        visualization.connection_id,
        visualization.table_name,
        config.mappings
      );
      
      // Generate chart data based on the sample and config
      const chartData = generateChartData(
        tableSample,
        config.mappings,
        visualization.type
      );
      
      setPreviewData(prev => ({ ...prev, [visualization.id]: chartData }));
    } catch (err) {
      console.error(`Failed to generate preview for visualization ${visualization.id}:`, err);
    } finally {
      setPreviewLoading(prev => ({ ...prev, [visualization.id]: false }));
    }
  };
  
  // Generate chart data based on sample data, mappings, and chart type
  const generateChartData = (
    sampleData: any[], 
    mappings: Record<string, string>, 
    chartType: string
  ): ChartData | null => {
    if (!sampleData || !sampleData.length || !mappings) return null;
    
    try {
      // Process data based on chart type
      if (chartType === 'bar' || chartType === 'line') {
        // Extract values
        const labels = sampleData.map(row => row[mappings.x]);
        const values = sampleData.map(row => row[mappings.y]);
        
        // Create dataset
        return {
          labels,
          datasets: [
            {
              label: mappings.y,
              data: values,
              backgroundColor: chartType === 'bar' 
                ? [
                    '#2563EB', '#D946EF', '#F59E0B', '#10B981', '#6366F1',
                    '#EF4444', '#8B5CF6', '#EC4899', '#06B6D4', '#84CC16'
                  ]
                : '#2563EB',
              borderColor: chartType === 'line' ? '#2563EB' : undefined,
              borderWidth: chartType === 'line' ? 2 : undefined,
              tension: chartType === 'line' ? 0.2 : undefined,
              fill: chartType === 'line' ? false : undefined,
            }
          ]
        };
      } else if (chartType === 'pie' || chartType === 'doughnut') {
        // Extract values
        const labels = sampleData.map(row => row[mappings.labels]);
        const values = sampleData.map(row => row[mappings.values]);
        
        // Create dataset
        return {
          labels,
          datasets: [
            {
              data: values,
              backgroundColor: [
                '#2563EB', '#D946EF', '#F59E0B', '#10B981', '#6366F1',
                '#EF4444', '#8B5CF6', '#EC4899', '#06B6D4', '#84CC16'
              ],
              borderWidth: 2,
              borderColor: '#FFFFFF'
            }
          ]
        };
      } else if (chartType === 'scatter') {
        // Extract values
        const data = sampleData.map(row => ({
          x: row[mappings.x],
          y: row[mappings.y],
          r: mappings.size ? row[mappings.size] : 5,
        }));
        
        // Create dataset
        return {
          datasets: [
            {
              label: 'Scatter Data',
              data,
              backgroundColor: '#2563EB',
              borderColor: '#1E40AF',
              borderWidth: 1,
              pointRadius: 5,
              pointHoverRadius: 8
            }
          ]
        };
      }
    } catch (err) {
      console.error('Error generating chart data:', err);
    }
    
    return null;
  };
  
  // Load full visualization data for view mode
  const loadFullVisualizationData = async (visualization: Visualization) => {
    try {
      setFullChartLoading(true);
      setError(null);
      
      // Get the config data
      const config = JSON.parse(visualization.config);
      
      // Fetch all data from the table for this visualization
      const response = await visualizationApi.getFullData(
        visualization.connection_id,
        visualization.table_name,
        config.mappings
      );
      
      // Generate chart data based on the full data and config
      const chartData = generateChartData(
        response.data,
        config.mappings,
        visualization.type
      );
      
      setFullChartData(chartData);
    } catch (err: any) {
      console.error('Failed to load full visualization data:', err);
      setError(err.message || 'Failed to load visualization data');
    } finally {
      setFullChartLoading(false);
    }
  };
  
  // Handle visualization deletion
  const handleDeleteVisualization = async (id: number) => {
    if (!window.confirm('Are you sure you want to delete this visualization?')) {
      return;
    }
    
    try {
      await visualizationApi.delete(id);
      setVisualizations(visualizations.filter(viz => viz.id !== id));
      
      // Clear preview data for this visualization
      setPreviewData(prev => {
        const newData = { ...prev };
        delete newData[id];
        return newData;
      });
      
      toast.success('Visualization deleted successfully');
    } catch (err: any) {
      console.error('Failed to delete visualization:', err);
      toast.error(err.message || 'Failed to delete visualization');
    }
  };
  
  // Handle view visualization (opens in full view mode)
  const handleViewVisualization = async (visualization: Visualization) => {
    setSelectedVisualization(visualization);
    setViewMode(true);
    await loadFullVisualizationData(visualization);
  };
  
  // Handle edit visualization (navigates to the builder with the visualization loaded)
  const handleEditVisualization = (visualization: Visualization) => {
    // Parse the config to get the mappings
    const config = JSON.parse(visualization.config);
    
    navigate('/visualize', { 
      state: { 
        editMode: true,
        visualizationId: visualization.id,
        connectionId: visualization.connection_id,
        tableName: visualization.table_name,
        chartType: visualization.type,
        configData: visualization.config,
        name: visualization.name
      } 
    });
  };
  
  // Handle export visualization as CSV
  const handleExportVisualization = (id: number) => {
    const url = exportApi.exportVisualization(id);
    window.open(url, '_blank');
  };
  
  // Handle closing the full view mode
  const handleCloseViewMode = () => {
    setViewMode(false);
    setSelectedVisualization(null);
    setFullChartData(null);
  };
  
  // Render the full view mode component
  const renderFullView = () => {
    if (!selectedVisualization) return null;
    
    return (
      <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-6">
        <div className="bg-white rounded-lg w-full max-w-6xl max-h-[90vh] flex flex-col">
          {/* Header */}
          <div className="px-6 py-4 border-b border-slate-200 flex justify-between items-center">
            <h2 className="text-xl font-semibold text-slate-900">
              {selectedVisualization.name}
            </h2>
            
            <div className="flex items-center space-x-2">
              <button 
                className="px-3 py-1.5 text-xs bg-green-50 text-green-700 rounded hover:bg-green-100"
                onClick={() => handleExportVisualization(selectedVisualization.id)}
              >
                Export CSV
              </button>
              <button 
                className="px-3 py-1.5 text-xs bg-blue-50 text-blue-700 rounded hover:bg-blue-100"
                onClick={() => {
                  handleCloseViewMode();
                  handleEditVisualization(selectedVisualization);
                }}
              >
                Edit
              </button>
              <button
                className="p-2 text-slate-500 hover:text-slate-700"
                onClick={handleCloseViewMode}
                aria-label="Close"
              >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clipRule="evenodd" />
                </svg>
              </button>
            </div>
          </div>
          
          {/* Chart container */}
          <div className="flex-1 overflow-hidden p-6">
            {fullChartLoading ? (
              <div className="h-full flex items-center justify-center">
                <p className="text-slate-500">Loading visualization data...</p>
              </div>
            ) : error ? (
              <div className="h-full flex items-center justify-center">
                <p className="text-red-600">{error}</p>
              </div>
            ) : fullChartData ? (
              <div className="h-full">
                <ChartRenderer 
                  type={selectedVisualization.type}
                  data={fullChartData}
                />
              </div>
            ) : (
              <div className="h-full flex items-center justify-center">
                <p className="text-slate-500">No visualization data available</p>
              </div>
            )}
          </div>
          
          {/* Footer with info */}
          <div className="px-6 py-3 bg-slate-50 border-t border-slate-200 text-xs text-slate-500">
            <p>Table: <span className="font-medium">{selectedVisualization.table_name}</span></p>
            <p>Last updated: <span className="font-medium">{new Date(selectedVisualization.updated_at).toLocaleString()}</span></p>
          </div>
        </div>
      </div>
    );
  };
  
  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h1 className="text-3xl font-semibold text-slate-900">Saved Visualizations</h1>
        <button
          className="px-4 py-2 bg-primary text-white rounded text-sm font-medium hover:bg-primary-dark transition-colors"
          onClick={() => navigate('/visualize')}
        >
          Create New Visualization
        </button>
      </div>
      
      {error && (
        <div className="p-4 bg-red-50 border border-red-200 rounded-md text-red-700">
          <p>{error}</p>
        </div>
      )}
      
      {loading ? (
        <div className="text-center p-6 bg-white rounded-md border border-slate-200">
          <p className="text-slate-500">Loading visualizations...</p>
        </div>
      ) : visualizations.length > 0 ? (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {visualizations.map(visualization => (
            <div 
              key={visualization.id} 
              className="bg-white p-6 rounded-md border border-slate-200 shadow-sm hover:shadow transition-shadow"
            >
              <div 
                className="h-48 bg-slate-50 mb-4 rounded flex items-center justify-center relative cursor-pointer"
                onClick={() => handleViewVisualization(visualization)}
              >
                {previewLoading[visualization.id] ? (
                  <p className="text-slate-400">Loading preview...</p>
                ) : previewData[visualization.id] ? (
                  <ChartRenderer 
                    type={visualization.type}
                    data={previewData[visualization.id]!}
                  />
                ) : (
                  <div className="text-center">
                    <p className="text-slate-400">{visualization.type.charAt(0).toUpperCase() + visualization.type.slice(1)} Chart</p>
                    <button
                      className="mt-2 text-xs text-primary hover:underline"
                      onClick={(e) => {
                        e.stopPropagation();
                        generatePreviewData(visualization);
                      }}
                    >
                      Load Preview
                    </button>
                  </div>
                )}
                
                {/* View overlay on hover */}
                <div className="absolute inset-0 bg-slate-900 bg-opacity-0 hover:bg-opacity-40 flex items-center justify-center opacity-0 hover:opacity-100 transition-opacity rounded">
                  <span className="px-4 py-2 bg-white text-slate-900 font-medium rounded text-sm">
                    View Full Visualization
                  </span>
                </div>
              </div>
              
              <h3 className="text-lg font-medium text-slate-900 mb-1">{visualization.name}</h3>
              <p className="text-sm text-slate-500 mb-4">
                {visualization.type.charAt(0).toUpperCase() + visualization.type.slice(1)} chart 
                using <span className="font-medium">{visualization.table_name}</span> table
              </p>
              
              <div className="flex flex-wrap gap-2">
                <button 
                  className="px-3 py-1.5 text-xs bg-slate-100 text-slate-700 rounded hover:bg-slate-200"
                  onClick={() => handleViewVisualization(visualization)}
                >
                  View
                </button>
                <button 
                  className="px-3 py-1.5 text-xs bg-blue-50 text-blue-700 rounded hover:bg-blue-100"
                  onClick={() => handleEditVisualization(visualization)}
                >
                  Edit
                </button>
                <button 
                  className="px-3 py-1.5 text-xs bg-green-50 text-green-700 rounded hover:bg-green-100"
                  onClick={() => handleExportVisualization(visualization.id)}
                >
                  Export CSV
                </button>
                <button 
                  className="px-3 py-1.5 text-xs bg-red-50 text-red-700 rounded hover:bg-red-100"
                  onClick={() => handleDeleteVisualization(visualization.id)}
                >
                  Delete
                </button>
              </div>
            </div>
          ))}
        </div>
      ) : (
        <div className="bg-white p-8 rounded-md border border-slate-200 text-center">
          <div className="mb-6">
            <svg xmlns="http://www.w3.org/2000/svg" className="h-16 w-16 mx-auto text-slate-300" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
            </svg>
          </div>
          <p className="text-slate-500 mb-6">No saved visualizations yet</p>
          <button
            className="px-4 py-2 bg-primary text-white rounded text-sm font-medium hover:bg-primary-dark transition-colors"
            onClick={() => navigate('/visualize')}
          >
            Create Your First Visualization
          </button>
        </div>
      )}
      
      {/* Render full view modal when in view mode */}
      {viewMode && renderFullView()}
    </div>
  )
}

export default SavedVisualizations
</file>

<file path="client/src/pages/TemplateApplication.tsx">
import { FC } from 'react';
import { useNavigate } from 'react-router-dom';
import TemplateConfigurator from '../components/templates/TemplateConfigurator';

/**
 * TemplateApplication Page
 * 
 * Page for applying templates to data
 */
const TemplateApplication: FC = () => {
  const navigate = useNavigate();
  
  const handleBack = () => {
    navigate('/templates');
  };
  
  return (
    <div className="container mx-auto px-4 py-6">
      <TemplateConfigurator onBack={handleBack} />
    </div>
  );
};

export default TemplateApplication;
</file>

<file path="client/src/types/index.ts">
// Connection Types
export interface Connection {
  id: string | number;
  name: string;
  path: string;
  last_accessed?: string;
  size_bytes?: number;
  table_count?: number;
  is_valid?: boolean;
}

// Table Types
export interface TableInfo {
  name: string;
  rowCount?: number;
  hasTimestamp?: boolean;
}

// Column Types
export interface ColumnInfo {
  name: string;
  type: string;
  isNumeric?: boolean;
  isText?: boolean;
  isDate?: boolean;
}

// Table Schema
export interface TableSchema {
  columns: ColumnInfo[];
}

// Table Data Types
export interface TableDataResponse {
  data: any[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

// Visualization Types
export interface Visualization {
  id: string | number;
  name: string;
  type: string;
  connectionId: string | number;
  tableName: string;
  config: any;
  createdAt?: string;
  updatedAt?: string;
}

// Template Types
export interface Template {
  id: string | number;
  name: string;
  description?: string;
  type: string;
  category?: string;
  config: any;
  isDefault?: boolean;
}

// Field Mapping Types
export interface FieldMapping {
  [key: string]: string;
}

// Chart Data
export interface ChartData {
  labels: string[];
  datasets: Array<{
    label: string;
    data: any[];
    backgroundColor?: string | string[];
    borderColor?: string | string[];
    borderWidth?: number;
  }>;
}
</file>

<file path="client/src/config.ts">
/**
 * Application Configuration
 */

// Detect server port from environment or fallback to default
const getServerPort = () => {
  // Always use the default port in development
  // This ensures we connect to the Express server running on port 8765
  return 8765;
};

// Base URL for API requests
const getApiUrl = () => {
  if (process.env.NODE_ENV === 'production') {
    return ''; // Same domain in production
  }
  
  // For development
  const serverPort = getServerPort();
  return `http://localhost:${serverPort}`;
};

// API Base URL
export const API_BASE_URL = `${getApiUrl()}/api`;

// Constants for the application
export const APP_CONFIG = {
  APP_NAME: 'SQLite Visualizer',
  DEFAULT_PAGE_SIZE: 100,
  MAX_EXPORT_ROWS: 100000,
  AVAILABLE_EXPORT_FORMATS: [
    { id: 'csv', name: 'CSV (Comma Separated Values)', extension: 'csv', mimeType: 'text/csv' },
    { id: 'json', name: 'JSON (JavaScript Object Notation)', extension: 'json', mimeType: 'application/json' }
  ]
};

export default {
  API_BASE_URL,
  APP_CONFIG
};
</file>

<file path="client/.vite-port">
3001
</file>

<file path="client/tsconfig.json">
{
  "compilerOptions": {
    "target": "ESNext",
    "useDefineForClassFields": true,
    "lib": ["DOM", "DOM.Iterable", "ESNext"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "moduleResolution": "Node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="client/tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="docs/data-validator.md">
# Data Validator Middleware Documentation

## Overview

The `dataValidator.js` middleware provides request validation for the SQLite Visualizer application. It uses the popular [Joi](https://joi.dev/) validation library to ensure that the data received by the API endpoints meets the expected format and constraints.

## Features

- Validates request body, query parameters, and path parameters
- Returns standardized error responses
- Sanitizes input data
- Includes pre-defined schemas for common application entities

## Usage

### Basic Usage

```javascript
const { validateBody, validateParams, validateQuery, schemas } = require('../middleware/dataValidator');

// Example route with body validation
router.post('/resource', 
  validateBody(someSchema),
  (req, res) => {
    // req.body is now validated and sanitized
    // ...
  }
);

// Example route with path parameter validation
router.get('/resource/:id', 
  validateParams(someParamSchema),
  (req, res) => {
    // req.params is now validated
    // ...
  }
);

// Example route with query validation
router.get('/resources', 
  validateQuery(someQuerySchema),
  (req, res) => {
    // req.query is now validated and sanitized
    // ...
  }
);
```

### Validation Options

The validator middleware uses the following Joi options:

- `abortEarly: false` - Returns all errors instead of stopping at the first error
- `stripUnknown: true` - Removes unknown keys from the validated object
- `errors.wrap.label: ''` - Improves error message readability

## Pre-defined Schemas

### Connection Schemas

- `schemas.connection.create` - For creating a new connection
  - Required fields: `name`, `path`
  
- `schemas.connection.id` - For validating connection IDs
  - Required fields: `id` (positive integer)

### Visualization Schemas

- `schemas.visualization.create` - For creating a new visualization
  - Required fields: `connection_id`, `name`, `type`, `config`, `table_name`
  - Valid visualization types: `bar`, `pie`, `line`, `scatter`, `area`
  
- `schemas.visualization.id` - For validating visualization IDs
  - Required fields: `id` (positive integer)
  
- `schemas.visualization.update` - For updating a visualization
  - Optional fields: `name`, `type`, `config`
  - At least one field must be provided

### Table Data Schemas

- `schemas.table.query` - For querying table data
  - Optional fields: `page`, `limit`, `sort`, `order`, `filter`
  - Default values: `page=1`, `limit=100`, `order='asc'`

### Export Schemas

- `schemas.export.csv` - For CSV export options
  - Optional fields: `format`
  - Default values: `format='csv'`

## Example Error Response

When validation fails, the middleware returns a response with status code 400 and a JSON body:

```json
{
  "success": false,
  "message": "Validation Error",
  "errors": [
    "Connection name is required",
    "Database path is required"
  ]
}
```

## Custom Validation Schemas

You can create custom validation schemas for specific routes:

```javascript
const Joi = require('joi');

const customSchema = Joi.object({
  field1: Joi.string().required()
    .messages({
      'string.empty': 'Field 1 is required'
    }),
  field2: Joi.number().min(1).max(100)
    .messages({
      'number.min': 'Field 2 must be at least 1',
      'number.max': 'Field 2 cannot exceed 100'
    })
});

router.post('/custom-endpoint', 
  validateBody(customSchema),
  (req, res) => {
    // Handle request
  }
);
```

## Best Practices

1. Use specific error messages that guide the user on how to fix the issue
2. Keep validation logic separate from business logic
3. Use schema composition to reuse common validation patterns
4. Consider performance implications of complex validations
5. Always validate and sanitize user input to prevent security issues

## Extending the Validator

To add new schemas, modify the `schemas` object in `dataValidator.js`:

```javascript
// Add new schema
schemas.newResource = {
  create: Joi.object({ /* ... */ }),
  update: Joi.object({ /* ... */ }),
  id: Joi.object({ /* ... */ })
};
```
</file>

<file path="scripts/create_test_db.js">
/**
 * Create Test SQLite Database Script
 * 
 * This script creates a test SQLite database with sample sales data
 * for use with the SQLite Visualizer application.
 */

const Database = require('better-sqlite3');
const path = require('path');
const fs = require('fs');

// Database path
const dbDir = path.join(__dirname, '../data');
const dbPath = path.join(dbDir, 'sales_db.sqlite');

// Ensure data directory exists
if (!fs.existsSync(dbDir)) {
  console.log(`Creating data directory: ${dbDir}`);
  fs.mkdirSync(dbDir, { recursive: true });
}

// Connect to database
console.log(`Setting up database at: ${dbPath}`);
const db = new Database(dbPath);

// Enable foreign keys
db.pragma('foreign_keys = ON');

// Create tables
console.log('Creating tables...');

// Stores table
db.exec(`
  CREATE TABLE IF NOT EXISTS stores (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    location TEXT NOT NULL,
    opened_date DATE NOT NULL
  );
`);

// Products table
db.exec(`
  CREATE TABLE IF NOT EXISTS products (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    model TEXT NOT NULL,
    price DECIMAL(10, 2) NOT NULL,
    introduced_date DATE NOT NULL
  );
`);

// Sales table
db.exec(`
  CREATE TABLE IF NOT EXISTS sales (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    store_id INTEGER NOT NULL,
    product_id INTEGER NOT NULL,
    year INTEGER NOT NULL,
    quarter INTEGER NOT NULL,
    quantity INTEGER NOT NULL,
    total_revenue DECIMAL(12, 2) NOT NULL,
    FOREIGN KEY (store_id) REFERENCES stores(id) ON DELETE CASCADE,
    FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE
  );
`);

// Insert sample data
console.log('Inserting sample data...');

// Add stores
const insertStore = db.prepare(`
  INSERT INTO stores (name, location, opened_date)
  VALUES (?, ?, ?)
`);

const stores = [
  { name: 'Downtown Store', location: 'New York', openedDate: '2019-01-15' },
  { name: 'West Mall', location: 'Los Angeles', openedDate: '2018-03-21' },
  { name: 'East End', location: 'Chicago', openedDate: '2020-05-10' },
  { name: 'North Plaza', location: 'Miami', openedDate: '2017-11-30' },
  { name: 'South Center', location: 'Houston', openedDate: '2019-09-05' }
];

stores.forEach(store => {
  insertStore.run(store.name, store.location, store.openedDate);
});

// Add products
const insertProduct = db.prepare(`
  INSERT INTO products (name, model, price, introduced_date)
  VALUES (?, ?, ?, ?)
`);

const products = [
  { name: 'Basic Blender', model: 'BB-100', price: 49.99, introducedDate: '2019-01-01' },
  { name: 'Deluxe Blender', model: 'DB-200', price: 89.99, introducedDate: '2019-03-15' },
  { name: 'Professional Blender', model: 'PB-300', price: 149.99, introducedDate: '2020-02-28' },
  { name: 'Smart Blender', model: 'SB-400', price: 199.99, introducedDate: '2021-01-10' },
  { name: 'Ultra Blender', model: 'UB-500', price: 249.99, introducedDate: '2022-05-20' }
];

products.forEach(product => {
  insertProduct.run(product.name, product.model, product.price, product.introducedDate);
});

// Generate quarterly sales data for each product at each store (3 years worth)
const insertSale = db.prepare(`
  INSERT INTO sales (store_id, product_id, year, quarter, quantity, total_revenue)
  VALUES (?, ?, ?, ?, ?, ?)
`);

// Use a transaction for bulk insert
const insertSalesTransaction = db.transaction(() => {
  // For each store
  for (let storeId = 1; storeId <= 5; storeId++) {
    // For each product
    for (let productId = 1; productId <= 5; productId++) {
      // For years 2021-2023
      for (let year = 2021; year <= 2023; year++) {
        // For each quarter
        for (let quarter = 1; quarter <= 4; quarter++) {
          // Generate random sales data
          const baseQuantity = Math.floor(Math.random() * 50) + 10; // 10-60 units
          
          // Add some trends and variability:
          // - Higher-end models sell less but have higher revenue
          // - Sales generally increase over time (with some randomness)
          // - Q4 typically has higher sales (holiday season)
          const modelFactor = 1 - ((productId - 1) * 0.1); // Higher models sell fewer units
          const yearFactor = 1 + ((year - 2021) * 0.2); // Sales increase year over year
          const quarterFactor = (quarter === 4) ? 1.3 : 1.0; // Q4 boost
          
          const quantity = Math.floor(baseQuantity * modelFactor * yearFactor * quarterFactor);
          
          // Get product price from the products array
          const price = products[productId - 1].price;
          const totalRevenue = parseFloat((quantity * price).toFixed(2));
          
          // Insert the sale record
          insertSale.run(storeId, productId, year, quarter, quantity, totalRevenue);
        }
      }
    }
  }
});

// Execute the transaction
insertSalesTransaction();

// Verify data was inserted
const storeCount = db.prepare('SELECT COUNT(*) as count FROM stores').get();
const productCount = db.prepare('SELECT COUNT(*) as count FROM products').get();
const salesCount = db.prepare('SELECT COUNT(*) as count FROM sales').get();

console.log(`Inserted ${storeCount.count} stores`);
console.log(`Inserted ${productCount.count} products`);
console.log(`Inserted ${salesCount.count} sales records`);

// Create some useful views
console.log('Creating views...');

// Quarterly sales by product
db.exec(`
  CREATE VIEW IF NOT EXISTS quarterly_sales_by_product AS
  SELECT
    p.id as product_id,
    p.name as product_name,
    p.model as product_model,
    s.year,
    s.quarter,
    SUM(s.quantity) as total_quantity,
    SUM(s.total_revenue) as total_revenue
  FROM
    sales s
    JOIN products p ON s.product_id = p.id
  GROUP BY
    p.id, s.year, s.quarter
  ORDER BY
    p.id, s.year, s.quarter;
`);

// Quarterly sales by store
db.exec(`
  CREATE VIEW IF NOT EXISTS quarterly_sales_by_store AS
  SELECT
    st.id as store_id,
    st.name as store_name,
    st.location as store_location,
    s.year,
    s.quarter,
    SUM(s.quantity) as total_quantity,
    SUM(s.total_revenue) as total_revenue
  FROM
    sales s
    JOIN stores st ON s.store_id = st.id
  GROUP BY
    st.id, s.year, s.quarter
  ORDER BY
    st.id, s.year, s.quarter;
`);

// Product performance by store
db.exec(`
  CREATE VIEW IF NOT EXISTS product_performance_by_store AS
  SELECT
    st.id as store_id,
    st.name as store_name,
    p.id as product_id,
    p.name as product_name,
    p.model as product_model,
    SUM(s.quantity) as total_quantity,
    SUM(s.total_revenue) as total_revenue,
    SUM(s.total_revenue) / SUM(s.quantity) as average_unit_revenue
  FROM
    sales s
    JOIN stores st ON s.store_id = st.id
    JOIN products p ON s.product_id = p.id
  GROUP BY
    st.id, p.id
  ORDER BY
    st.id, total_revenue DESC;
`);

console.log('Database setup complete!');

// Close the database connection
db.close();
</file>

<file path="scripts/start-dev.js">
/**
 * Start Development Environment Script
 * 
 * This script orchestrates the startup of server and client with proper
 * port coordination and handles cleanup on exit.
 */

const { spawn } = require('child_process');
const fs = require('fs');
const path = require('path');
const os = require('os');

// Path to store process info and server port
const PROCESS_INFO_FILE = path.join(os.tmpdir(), 'sqlite-visualizer-processes.json');
const PORT_INFO_FILE = path.join(os.tmpdir(), 'sqlite-visualizer-server-port.txt');

// Clean up any existing files from previous runs
const cleanupFiles = () => {
  try {
    if (fs.existsSync(PROCESS_INFO_FILE)) {
      fs.unlinkSync(PROCESS_INFO_FILE);
    }
    if (fs.existsSync(PORT_INFO_FILE)) {
      fs.unlinkSync(PORT_INFO_FILE);
    }
  } catch (err) {
    console.warn('Error cleaning up old files:', err);
  }
};

// Wait for server to start and get port
const waitForServer = () => {
  return new Promise((resolve) => {
    let attempts = 0;
    const maxAttempts = 30;
    const checkInterval = 500; // 500ms

    const checkServerPort = () => {
      attempts++;
      
      try {
        if (fs.existsSync(PORT_INFO_FILE)) {
          const portData = fs.readFileSync(PORT_INFO_FILE, 'utf8');
          const port = parseInt(portData, 10);
          
          if (!isNaN(port)) {
            console.log(`Server detected on port ${port}`);
            return resolve(port);
          }
        }
      } catch (err) {
        console.warn('Error reading server port file:', err);
      }
      
      // If we've reached max attempts, give up
      if (attempts >= maxAttempts) {
        console.warn('Timed out waiting for server to start. Continuing anyway...');
        return resolve(null);
      }
      
      // Try again after interval
      setTimeout(checkServerPort, checkInterval);
    };
    
    // Start checking
    checkServerPort();
  });
};

// Start the application components
const startApplication = async () => {
  // Clean up any existing files first
  cleanupFiles();
  
  // Start server
  console.log('Starting server...');
  const server = spawn('nodemon', ['server/app.js'], {
    stdio: 'inherit',
    shell: true,
    env: { ...process.env, FORCE_COLOR: '1' }
  });
  
  // Wait for server to start and get its port
  const serverPort = await waitForServer();
  
  // Start client with server port info if available
  console.log('Starting client...');
  const clientEnv = { ...process.env, FORCE_COLOR: '1' };
  
  if (serverPort) {
    clientEnv.ACTUAL_SERVER_PORT = serverPort.toString();
  }
  
  const client = spawn('cd client && npm run dev', {
    stdio: 'inherit',
    shell: true,
    env: clientEnv
  });
  
  // Save process info for cleanup
  const processInfo = {
    server: server.pid,
    client: client.pid,
    timestamp: new Date().toISOString()
  };
  
  fs.writeFileSync(PROCESS_INFO_FILE, JSON.stringify(processInfo, null, 2));
  
  // Handle process exits
  server.on('close', (code) => {
    console.log(`Server process exited with code ${code}`);
    cleanup();
  });
  
  client.on('close', (code) => {
    console.log(`Client process exited with code ${code}`);
    cleanup();
  });
};

// Function to clean up processes
function cleanup() {
  try {
    console.log('Cleaning up processes and temporary files...');
    
    // Read process info if it exists
    if (fs.existsSync(PROCESS_INFO_FILE)) {
      const processInfo = JSON.parse(fs.readFileSync(PROCESS_INFO_FILE, 'utf8'));
      
      // Try to kill processes if still running
      try {
        process.kill(processInfo.server, 'SIGINT');
      } catch (err) {
        // Process might not exist, which is fine
      }
      
      try {
        process.kill(processInfo.client, 'SIGINT');
      } catch (err) {
        // Process might not exist, which is fine
      }
      
      // Remove process info file
      fs.unlinkSync(PROCESS_INFO_FILE);
    }
    
    // Remove server port file if it exists
    if (fs.existsSync(PORT_INFO_FILE)) {
      fs.unlinkSync(PORT_INFO_FILE);
    }
    
    // Exit after a short delay to allow processes to terminate
    setTimeout(() => {
      process.exit(0);
    }, 500);
  } catch (err) {
    console.error('Error during cleanup:', err);
    process.exit(1);
  }
}

// Handle signals for graceful shutdown
process.on('SIGINT', cleanup);
process.on('SIGTERM', cleanup);

// Start the application
startApplication().catch((err) => {
  console.error('Error starting application:', err);
  cleanup();
  process.exit(1);
});
</file>

<file path="scripts/stop-processes.js">
/**
 * Process Cleanup Script
 * 
 * This script finds and terminates any stray development processes
 * for the SQLite Visualizer application.
 */

const findProcess = require('find-process');
const { exec } = require('child_process');
const fs = require('fs');
const path = require('path');
const os = require('os');

// Path where process info is stored
const PROCESS_INFO_FILE = path.join(os.tmpdir(), 'sqlite-visualizer-processes.json');

// Execute a command
const execute = (command) => {
  return new Promise((resolve, reject) => {
    exec(command, (error, stdout, stderr) => {
      if (error) {
        console.warn(`Command failed: ${command}`);
        console.warn(stderr);
        resolve(null);
        return;
      }
      resolve(stdout.trim());
    });
  });
};

// Kill a process by PID
const killProcess = async (pid, name) => {
  try {
    if (process.platform === 'win32') {
      await execute(`taskkill /F /PID ${pid}`);
    } else {
      await execute(`kill -9 ${pid}`);
    }
    console.log(`Killed ${name} process with PID ${pid}`);
    return true;
  } catch (err) {
    console.error(`Failed to kill ${name} process:`, err);
    return false;
  }
};

// Find and kill all Node.js processes related to the application
const findAndKillProcesses = async () => {
  // First check if we have stored PIDs
  if (fs.existsSync(PROCESS_INFO_FILE)) {
    try {
      const data = JSON.parse(fs.readFileSync(PROCESS_INFO_FILE, 'utf8'));
      console.log('Found process info file, attempting to kill processes...');
      
      if (data.server) {
        await killProcess(data.server, 'server');
      }
      
      if (data.client) {
        await killProcess(data.client, 'client');
      }
      
      // Remove the file regardless of success
      fs.unlinkSync(PROCESS_INFO_FILE);
    } catch (err) {
      console.error('Error reading process info file:', err);
    }
  }

  // As a fallback, search for related processes
  console.log('Searching for SQLite Visualizer processes...');
  
  // Look for Vite dev server processes
  const viteProcesses = await findProcess('name', 'vite');
  const clientProcesses = viteProcesses.filter(proc => 
    proc.cmd.includes('sqlite-visualizer') || 
    proc.cmd.includes('vite')
  );
  
  // Look for server processes (nodemon or node)
  const nodeProcesses = await findProcess('name', 'node');
  const serverProcesses = nodeProcesses.filter(proc => 
    proc.cmd.includes('sqlite-visualizer') || 
    (proc.cmd.includes('node') && proc.cmd.includes('app.js'))
  );
  
  console.log(`Found ${clientProcesses.length} client processes and ${serverProcesses.length} server processes`);
  
  let killCount = 0;
  
  // Kill client processes
  for (const proc of clientProcesses) {
    const killed = await killProcess(proc.pid, 'client');
    if (killed) killCount++;
  }
  
  // Kill server processes
  for (const proc of serverProcesses) {
    const killed = await killProcess(proc.pid, 'server');
    if (killed) killCount++;
  }
  
  return killCount;
};

// Run the cleanup
findAndKillProcesses()
  .then(count => {
    console.log(`Terminated ${count} processes.`);
    console.log('Cleanup complete.');
  })
  .catch(err => {
    console.error('Error during cleanup:', err);
    process.exit(1);
  });
</file>

<file path="server/examples/validationExample.js">
/**
 * Validation Middleware Example
 * 
 * This file demonstrates how to use the dataValidator middleware in routes
 */

const express = require('express');
const router = express.Router();
const { validateBody, validateParams, validateQuery, schemas } = require('../middleware/dataValidator');

// Example 1: Validate request body when creating a connection
router.post('/connections', 
  validateBody(schemas.connection.create),
  (req, res) => {
    // By this point, req.body has been validated and sanitized
    const { name, path } = req.body;
    
    // Your connection creation logic here
    
    res.status(201).json({
      success: true,
      message: 'Connection created successfully',
      data: { id: 1, name, path }
    });
  }
);

// Example 2: Validate path parameters when getting a connection
router.get('/connections/:id', 
  validateParams(schemas.connection.id),
  (req, res) => {
    // By this point, req.params.id has been validated as a positive integer
    const { id } = req.params;
    
    // Your get connection logic here
    
    res.json({
      success: true,
      data: {
        id: Number(id),
        name: 'Sample Database',
        path: '/path/to/database.sqlite'
      }
    });
  }
);

// Example 3: Validate query parameters when listing table data
router.get('/connections/:id/tables/:table/data', 
  validateParams(schemas.connection.id),
  validateQuery(schemas.table.query),
  (req, res) => {
    const { id } = req.params;
    const { page, limit, sort, order } = req.query;
    
    // Your table data retrieval logic here
    
    res.json({
      success: true,
      data: {
        pagination: {
          page,
          limit,
          total: 100
        },
        sort: sort || null,
        order: order || 'asc',
        rows: []
      }
    });
  }
);

// Example 4: Validate request body when creating a visualization with nested objects
router.post('/visualizations', 
  validateBody(schemas.visualization.create),
  (req, res) => {
    // By this point, the complex nested objects in req.body have been validated
    const { connection_id, name, type, config, table_name } = req.body;
    
    // Your visualization creation logic here
    
    res.status(201).json({
      success: true,
      message: 'Visualization created successfully',
      data: {
        id: 1,
        connection_id,
        name,
        type,
        table_name
      }
    });
  }
);

// Example 5: Validate partial updates
router.patch('/visualizations/:id',
  validateParams(schemas.visualization.id),
  validateBody(schemas.visualization.update),
  (req, res) => {
    const { id } = req.params;
    
    // Any fields in req.body have been validated
    // This schema requires at least one field to be provided
    
    res.json({
      success: true,
      message: 'Visualization updated successfully',
      data: {
        id: Number(id),
        ...req.body
      }
    });
  }
);

module.exports = router;

// Usage in app.js:
/*
const app = express();
const validationExampleRoutes = require('./examples/validationExample');

app.use('/api/examples', validationExampleRoutes);
*/
</file>

<file path="server/utils/responseFormatter.js">
/**
 * Response Formatter
 * 
 * Utilities for formatting API responses
 */

/**
 * Format successful response
 * @param {any} data - Response data
 * @param {string} message - Success message
 */
function success(data, message = '') {
  // TODO: Implement formatting successful response
  return {
    success: true,
    data,
    message
  };
}

/**
 * Format error response
 * @param {string} message - Error message
 * @param {number} statusCode - HTTP status code
 * @param {Object} errors - Additional error details
 */
function error(message, statusCode = 500, errors = {}) {
  // TODO: Implement formatting error response
  return {
    success: false,
    message,
    statusCode,
    errors
  };
}

/**
 * Format paginated response
 * @param {Array} data - Paginated data
 * @param {number} total - Total items
 * @param {number} page - Current page
 * @param {number} limit - Items per page
 */
function paginated(data, total, page, limit) {
  // TODO: Implement formatting paginated response
  const totalPages = Math.ceil(total / limit);
  
  return {
    success: true,
    data,
    pagination: {
      total,
      page,
      limit,
      totalPages,
      hasNext: page < totalPages,
      hasPrev: page > 1
    }
  };
}

module.exports = {
  success,
  error,
  paginated
};
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Build, Test, and Lint Commands

### Client (React/TypeScript)
- Development: `npm run dev:client` or in client directory: `npm run dev`
- Build: `npm run build` (in root) or in client directory: `npm run build`
- Lint: `npm run lint` (in client directory)
- Fix lint issues: `npm run lint:fix` (in client directory)

### Server (Node.js/Express)
- Development: `npm run dev:server`
- Start: `npm start`
- Setup database: `npm run setup-db`

### Full Application
- Development (both): `npm run dev`

## Code Style Guidelines

- **TypeScript**: Use strict type checking, prefer explicit types over `any`
- **Components**: Use functional React components with hooks
- **Formatting**: Follow existing indent style (2 spaces)
- **Naming**: 
  - React components: PascalCase
  - Functions/variables: camelCase
  - Files: Match component names (PascalCase) or feature.type.ts pattern
- **Imports**: Group by external libraries first, then internal modules
- **Error Handling**: Use try/catch with next(error) pattern in Express routes
- **Documentation**: Use JSDoc comments for functions, especially in server code
- **Styling**: Use Tailwind CSS utility classes following existing patterns
</file>

<file path="SQLite_Visualizer_Masterplan.md">
# SQLite Database Visualizer Masterplan

## App Overview and Objectives

**Project Name:** SQLite Visualizer

**Objective:** Create a clean, user-friendly web application that visualizes SQLite database content in both tabular and chart formats, allowing for simple data exploration and insight generation without requiring SQL knowledge.

**Target Users:** A small team of 5 office-based professionals who need to analyze SQLite database data visually.

**Deployment Environment:** Locally hosted on a Mac within an office network.

## Current Implementation Status

The SQLite Visualizer is now a functioning application with the following features implemented:

### Database Connection
- ✅ Connect to SQLite databases via localhost with file selection
- ✅ Store and display recently connected databases with timestamps
- ✅ Automatic database health/size checks with validity indicators
- ✅ Support for databases of various sizes with optimized loading

### Data Viewing Options
1. **Table View**
   - ✅ Responsive data tables with clean styling
   - ✅ Column sorting and filtering functionality
   - ✅ Pagination for efficient handling of large datasets
   - ✅ Table selector with metadata display

2. **Visualization View**
   - ✅ On-the-fly chart generation with the following types:
     - Bar charts
     - Line graphs
     - Pie/Doughnut charts
     - Scatter plots
     - Radar charts
     - Polar area charts
   - ✅ Visualization configuration with field mapping
   - ✅ Saving visualizations for future reference
   - ✅ CSV export functionality

### Insight Templates
- ✅ Pre-configured templates implemented:
  - Top Selling Products (bar chart)
  - Monthly Sales Trend (line chart)
  - Customer Distribution (pie chart)
- ✅ Template application with field mapping suggestions
- ✅ Template categorization and filtering

### User Experience
- ✅ Clean UI using Tailwind CSS with consistent styling
- ✅ Intuitive point-and-click interface throughout
- ✅ Responsive design for various screen sizes
- ✅ Clear error handling and user feedback

## Technical Stack

### Frontend
- ✅ **Framework:** React with TypeScript
- ✅ **Styling:** Tailwind CSS with consistent design system
- ✅ **UI Components:** Custom components inspired by shadcn UI design patterns
- ✅ **Visualization Library:** Chart.js with optimized configurations

### Backend
- ✅ **Runtime:** Node.js
- ✅ **Server Framework:** Express.js with RESTful API design
- ✅ **Database:** 
  - SQLite for visualized databases (read-only access)
  - Application SQLite database for configuration and saved items

## Implemented Data Model

### Application Database (SQLite)
- ✅ **Connections**
  - id (primary key)
  - name (text)
  - path (text)
  - last_accessed (timestamp)
  - size_bytes (integer)
  - table_count (integer)
  - is_valid (boolean)

- ✅ **SavedVisualizations**
  - id (primary key)
  - connection_id (foreign key)
  - name (text)
  - type (text) - chart type
  - config (text) - JSON configuration
  - table_name (text)
  - created_at (timestamp)
  - updated_at (timestamp)

- ✅ **InsightTemplates**
  - id (primary key)
  - name (text)
  - description (text)
  - type (text) - chart type
  - config (text) - JSON template configuration
  - category (text)
  - is_default (boolean)

## API Endpoints

The application implements a comprehensive RESTful API:

### Connection Management
- ✅ `GET /api/connections` - List all saved connections
- ✅ `POST /api/connections` - Create a new connection
- ✅ `GET /api/connections/:id` - Get connection details
- ✅ `DELETE /api/connections/:id` - Remove a connection
- ✅ `GET /api/connections/:id/health` - Check database health/size

### Database Exploration
- ✅ `GET /api/connections/:id/tables` - List all tables in the database
- ✅ `GET /api/connections/:id/tables/:table/schema` - Get table schema
- ✅ `GET /api/connections/:id/tables/:table/data` - Get table data (with pagination)
- ✅ `GET /api/connections/:id/tables/:table/data/sample` - Get a sample of table data

### Visualization Management
- ✅ `POST /api/visualizations` - Create a new visualization
- ✅ `GET /api/visualizations` - List all saved visualizations
- ✅ `GET /api/visualizations/:id` - Get visualization details
- ✅ `PUT /api/visualizations/:id` - Update a visualization
- ✅ `DELETE /api/visualizations/:id` - Delete a visualization
- ✅ `GET /api/templates` - List all insight templates
- ✅ `GET /api/templates/:id` - Get template details
- ✅ `POST /api/templates/:id/apply` - Apply template to selected data

### Export Functionality
- ✅ `GET /api/export/csv/:vizId` - Export visualization as CSV
- ✅ `GET /api/export/csv/table/:connectionId/:tableName` - Export table as CSV

## Security Implementation

- ✅ Local network deployment with no external access
- ✅ Read-only database access to prevent data corruption
- ✅ Comprehensive input validation and sanitization
- ✅ Proper error handling to avoid exposing sensitive information
- ✅ Security headers with helmet middleware

## Deployment Configuration

The application can be deployed in the following ways:

1. **Development Mode**
   - Concurrent Node.js and React development servers
   - Hot reloading for both frontend and backend
   - Debug logging and detailed error reporting

2. **Production Mode**
   - Built React frontend served by Express
   - Optimized build with minimized assets
   - Graceful error handling for production environment
   - Port management to avoid conflicts

## Performance Optimizations

Several performance optimizations have been implemented:

- ✅ Efficient SQLite connection management
- ✅ Data pagination for large datasets
- ✅ Data sampling for visualization previews
- ✅ Client-side caching of frequently used data
- ✅ Optimized Chart.js configurations for rendering performance

## Next Steps and Future Improvements

While the core functionality is implemented, the following enhancements could be considered:

- Adding more advanced chart types (heatmaps, treemaps)
- Implementing more complex data transformations
- Adding user authentication for broader deployment
- Supporting additional database types (MySQL, PostgreSQL)
- Developing scheduled reports or snapshots
- Creating more specialized insight templates for various business domains

## Technical Implementation Details

### Database Connection
- Using better-sqlite3 for optimal performance
- Read-only connections to ensure data safety
- Database health checks to prevent errors
- Connection pooling for efficient resource usage

### UI Implementation
- Consistent design using Tailwind utility classes
- Responsive layouts for various screen sizes
- Loading states for asynchronous operations
- Error boundaries for graceful failure handling

### Chart Generation
- Chart.js with optimized configurations
- Style guide-compliant color schemes
- Responsive chart sizing and legend positioning
- Data transformation utilities for various chart types

The SQLite Visualizer application is now a fully functional tool that meets the core requirements specified in the original masterplan. It provides an intuitive, visual way to explore SQLite database content without requiring SQL knowledge.
</file>

<file path="client/src/components/templates/TemplateFieldMapper.tsx">
import { FC } from 'react';
import { ColumnInfo } from '../../types';

interface FieldDefinition {
  name: string;
  label: string;
  required?: boolean;
  description?: string;
}

interface TemplateFieldMapperProps {
  field: FieldDefinition;
  columns: ColumnInfo[];
  value: string;
  onChange: (fieldName: string, columnName: string) => void;
  disabled?: boolean;
  className?: string;
}

/**
 * TemplateFieldMapper Component
 * 
 * Maps template fields to database columns with intelligent suggestions
 */
const TemplateFieldMapper: FC<TemplateFieldMapperProps> = ({
  field,
  columns,
  value,
  onChange,
  disabled = false,
  className = ''
}) => {
  // Helper to check if a column type is numeric
  const isNumericType = (type: string): boolean => {
    return /int|float|double|decimal|number|real/i.test(type);
  };
  
  // Helper to check if a column type is text
  const isTextType = (type: string): boolean => {
    return /text|char|string|var/i.test(type);
  };
  
  // Helper to check if a column type is a date
  const isDateType = (type: string): boolean => {
    return /date|time/i.test(type);
  };
  
  // Helper to heuristically score column names for specific fields
  const getColumnScore = (columnName: string, columnType: string, fieldName: string): number => {
    const colNameLower = columnName.toLowerCase();
    const fieldNameLower = fieldName.toLowerCase();
    let score = 0;
    
    // Direct name matches get highest score
    if (colNameLower === fieldNameLower) {
      score += 100;
    }
    
    // Partial name matches
    if (colNameLower.includes(fieldNameLower) || fieldNameLower.includes(colNameLower)) {
      score += 50;
    }
    
    // For x-axis and labels fields
    if (['x', 'labels', 'categories', 'dimension', 'group'].includes(fieldNameLower)) {
      // Common category column names
      if (colNameLower.includes('name') || 
          colNameLower.includes('category') || 
          colNameLower.includes('type') || 
          colNameLower.includes('department') ||
          colNameLower.includes('group') ||
          colNameLower.includes('class') ||
          colNameLower.includes('region')) {
        score += 30;
      }
      
      // Date columns are often good for x-axis
      if (isDateType(columnType)) {
        score += 25;
      }
      
      // String columns are good for labels
      if (isTextType(columnType)) {
        score += 20;
      }
      
      // ID columns are usually not good for labels
      if (colNameLower === 'id' || colNameLower.endsWith('_id')) {
        score -= 20;
      }
    }
    
    // For y-axis and values fields
    if (['y', 'values', 'metrics', 'measure', 'value'].includes(fieldNameLower)) {
      // Common metric column names
      if (colNameLower.includes('count') || 
          colNameLower.includes('total') || 
          colNameLower.includes('sum') || 
          colNameLower.includes('amount') ||
          colNameLower.includes('price') ||
          colNameLower.includes('cost') ||
          colNameLower.includes('revenue') ||
          colNameLower.includes('profit') ||
          colNameLower.includes('sales')) {
        score += 30;
      }
      
      // Numeric columns are essential for values
      if (isNumericType(columnType)) {
        score += 40;
      } else {
        // Non-numeric columns shouldn't be used for values
        score -= 50;
      }
    }
    
    return score;
  };
  
  // Determine which columns to recommend based on field name
  const getRecommendedColumns = (): ColumnInfo[] => {
    const fieldNameLower = field.name.toLowerCase();
    
    // Create a scored list of columns
    const scoredColumns = columns.map(col => ({
      ...col,
      score: getColumnScore(col.name, col.type, field.name)
    }));
    
    // Filter based on field type and score
    let relevantColumns: ColumnInfo[];
    
    // For x-axis, labels, categories, etc. - recommend text and date columns
    if (['x', 'labels', 'categories', 'dimension', 'group'].includes(fieldNameLower)) {
      relevantColumns = scoredColumns.filter(col => 
        col.isText || col.isDate || isTextType(col.type) || isDateType(col.type));
    }
    // For y-axis, values, metrics, etc. - recommend numeric columns
    else if (['y', 'values', 'metrics', 'measure', 'value'].includes(fieldNameLower)) {
      relevantColumns = scoredColumns.filter(col => col.isNumeric || isNumericType(col.type));
    }
    // For date fields - recommend date columns
    else if (['date', 'time', 'timestamp', 'datetime'].includes(fieldNameLower)) {
      relevantColumns = scoredColumns.filter(col => col.isDate || isDateType(col.type));
    }
    // Default case - use all columns
    else {
      relevantColumns = scoredColumns;
    }
    
    // Sort by score (highest first) and return
    return relevantColumns.sort((a, b) => (b as any).score - (a as any).score);
  };
  
  const recommendedColumns = getRecommendedColumns();
  
  // Find if there's a perfect match
  const perfectMatch = value ? 
    columns.find(col => col.name === value) : 
    (recommendedColumns.length > 0 && (recommendedColumns[0] as any).score >= 90) ? 
      recommendedColumns[0] : null;
  
  return (
    <div className={`space-y-1 ${className}`}>
      <div className="flex items-center justify-between">
        <label className="text-sm font-medium text-slate-700">
          {field.label}
          {field.required && <span className="text-red-500 ml-1">*</span>}
        </label>
        
        {perfectMatch && !value && (
          <button 
            className="text-xs text-blue-600 hover:text-blue-800"
            onClick={() => onChange(field.name, perfectMatch.name)}
            type="button"
          >
            Use best match: {perfectMatch.name}
          </button>
        )}
      </div>
      
      <select 
        className={`w-full px-3 py-2 border rounded-sm text-sm 
          ${value ? 'border-green-300 bg-green-50' : 'border-slate-300'} 
          ${field.required && !value ? 'border-amber-300 bg-amber-50' : ''}
          ${disabled ? 'opacity-70 cursor-not-allowed' : 'cursor-pointer'}`}
        value={value || ''}
        onChange={(e) => onChange(field.name, e.target.value)}
        disabled={disabled || columns.length === 0}
      >
        <option value="">
          {columns.length === 0 ? 'No columns available' : `Select a column for ${field.label}`}
        </option>
        
        {/* Show recommended columns first if they exist */}
        {recommendedColumns.length > 0 && (
          <optgroup label="Recommended Columns">
            {recommendedColumns.slice(0, 5).map(col => (
              <option key={`rec-${col.name}`} value={col.name}>
                {col.name} ({col.type})
              </option>
            ))}
          </optgroup>
        )}
        
        {/* Show all columns */}
        {columns.length > 5 && (
          <optgroup label="All Columns">
            {columns
              .filter(col => !recommendedColumns.slice(0, 5).some(rec => rec.name === col.name))
              .map(col => (
                <option key={col.name} value={col.name}>
                  {col.name} ({col.type})
                </option>
              ))}
          </optgroup>
        )}
      </select>
      
      {field.description && (
        <p className="text-xs text-slate-500">{field.description}</p>
      )}
      
      {field.required && !value && (
        <p className="text-xs text-amber-600">This field is required</p>
      )}
      
      {value && (
        <p className="text-xs text-green-600">✓ Field mapped to "{value}"</p>
      )}
    </div>
  );
};

export default TemplateFieldMapper;
</file>

<file path="client/src/components/templates/TemplatePreview.tsx">
import { FC } from 'react';
import { Template, ChartData } from '../../types';
import ChartPreview from '../visualization/ChartPreview';

interface TemplatePreviewProps {
  template: Template;
  previewData: ChartData | null;
  isLoading?: boolean;
  error?: string | null;
  className?: string;
}

/**
 * TemplatePreview Component
 * 
 * Displays a preview of a template with sample data
 */
const TemplatePreview: FC<TemplatePreviewProps> = ({
  template,
  previewData,
  isLoading = false,
  error = null,
  className = ''
}) => {
  // Get placeholder data based on chart type
  const getPlaceholderData = (): ChartData => {
    switch (template.type.toLowerCase()) {
      case 'bar':
      case 'line':
        return {
          labels: ['Category A', 'Category B', 'Category C', 'Category D', 'Category E'],
          datasets: [{
            label: 'Sample Data',
            data: [12, 19, 8, 15, 10],
            backgroundColor: [
              'rgba(37, 99, 235, 0.2)', 
              'rgba(217, 70, 239, 0.2)', 
              'rgba(245, 158, 11, 0.2)', 
              'rgba(16, 185, 129, 0.2)', 
              'rgba(99, 102, 241, 0.2)'
            ],
            borderColor: [
              'rgb(37, 99, 235)', 
              'rgb(217, 70, 239)', 
              'rgb(245, 158, 11)', 
              'rgb(16, 185, 129)', 
              'rgb(99, 102, 241)'
            ],
            borderWidth: 1
          }]
        };
      case 'pie':
      case 'doughnut':
        return {
          labels: ['Category A', 'Category B', 'Category C', 'Category D', 'Category E'],
          datasets: [{
            data: [12, 19, 8, 15, 10],
            backgroundColor: [
              'rgb(37, 99, 235)', 
              'rgb(217, 70, 239)', 
              'rgb(245, 158, 11)', 
              'rgb(16, 185, 129)', 
              'rgb(99, 102, 241)'
            ],
            borderColor: ['white', 'white', 'white', 'white', 'white'],
            borderWidth: 1
          }]
        };
      default:
        return {
          labels: [],
          datasets: []
        };
    }
  };

  // Check if preview data is empty
  const isEmptyData = previewData && 
    (!previewData.datasets || 
     !previewData.labels || 
     previewData.labels.length === 0 || 
     previewData.datasets.length === 0 || 
     previewData.datasets[0].data.length === 0);
  
  // Render loading state
  if (isLoading) {
    return (
      <div className={`bg-white p-4 rounded-md border border-slate-200 ${className}`}>
        <h3 className="text-lg font-medium text-slate-900 mb-4">
          {template.name} <span className="text-blue-600">Preview</span>
        </h3>
        <div className="h-64 flex flex-col items-center justify-center bg-slate-50 rounded border border-slate-200 animate-pulse">
          <div className="w-8 h-8 border-4 border-blue-600 border-t-transparent rounded-full animate-spin"></div>
          <p className="text-slate-500 mt-4">Loading preview data...</p>
        </div>
      </div>
    );
  }
  
  // Render error state
  if (error) {
    return (
      <div className={`bg-white p-4 rounded-md border border-slate-200 ${className}`}>
        <h3 className="text-lg font-medium text-slate-900 mb-4">
          {template.name} <span className="text-blue-600">Preview</span>
        </h3>
        <div className="p-4 bg-red-50 border border-red-200 rounded-md">
          <p className="text-red-700 text-sm">{error}</p>
        </div>
        <div className="h-52 flex items-center justify-center bg-slate-50 rounded border border-slate-200 mt-4">
          <div className="text-center p-4">
            <p className="text-slate-500 mb-2">Unable to generate preview</p>
            <p className="text-xs text-slate-400">Fix the errors above to see a preview</p>
          </div>
        </div>
      </div>
    );
  }
  
  // Render empty state
  if (!previewData || isEmptyData) {
    // Show placeholder data with watermark
    const placeholderData = getPlaceholderData();
    
    return (
      <div className={`bg-white p-4 rounded-md border border-slate-200 ${className}`}>
        <h3 className="text-lg font-medium text-slate-900 mb-4">
          {template.name} <span className="text-blue-600">Preview</span>
        </h3>
        <div className="relative h-64">
          <div className="opacity-30">
            <ChartPreview 
              type={template.type}
              data={placeholderData}
              options={{
                title: template.name,
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                  legend: {
                    display: true,
                    position: 'bottom'
                  }
                }
              }}
            />
          </div>
          <div className="absolute inset-0 flex items-center justify-center">
            <div className="text-center bg-white/80 p-4 rounded">
              <p className="text-slate-700">Complete the mapping to see a preview</p>
              <p className="text-xs text-slate-500 mt-1">Map the required fields to generate a preview</p>
            </div>
          </div>
        </div>
        <p className="text-xs text-slate-500 mt-2 text-center">
          This is a sample layout. Your actual data will appear once fields are mapped.
        </p>
      </div>
    );
  }
  
  // Render preview chart
  return (
    <div className={`bg-white p-4 rounded-md border border-slate-200 ${className}`}>
      <h3 className="text-lg font-medium text-slate-900 mb-4">
        {template.name} <span className="text-blue-600">Preview</span>
      </h3>
      <div className="h-64">
        <ChartPreview 
          type={template.type}
          data={previewData}
          options={{
            title: template.name,
            responsive: true,
            maintainAspectRatio: false,
            animation: {
              duration: 500
            },
            plugins: {
              legend: {
                display: true,
                position: 'bottom'
              },
              tooltip: {
                enabled: true
              }
            }
          }}
        />
      </div>
      <p className="text-xs text-slate-500 mt-2 text-center">
        This is a preview with sample data. Apply the template to see the full visualization.
      </p>
    </div>
  );
};

export default TemplatePreview;
</file>

<file path="client/src/components/visualization/ChartPreview.tsx">
import { FC, useEffect, useRef, useState } from 'react';
import Chart from 'chart.js/auto';
import { ChartData } from '../../types';
import ExportButton from '../common/ExportButton';

interface ChartPreviewProps {
  type: string;
  data: ChartData;
  options?: Record<string, any>;
  visualizationId?: number;
  showExport?: boolean;
}

/**
 * ChartPreview Component
 * 
 * Renders a chart with Chart.js
 */
const ChartPreview: FC<ChartPreviewProps> = ({ 
  type, 
  data, 
  options = {}, 
  visualizationId,
  showExport = false 
}) => {
  const chartRef = useRef<HTMLCanvasElement>(null);
  const chartInstance = useRef<Chart | null>(null);
  
  // Parse chart type to match Chart.js format
  const parseChartType = (chartType: string): Chart.ChartType => {
    switch (chartType.toLowerCase()) {
      case 'bar':
        return 'bar';
      case 'line':
        return 'line';
      case 'pie':
        return 'pie';
      case 'doughnut':
        return 'doughnut';
      default:
        console.warn(`Unsupported chart type: ${chartType}, defaulting to bar`);
        return 'bar';
    }
  };
  
  // Initialize and update chart
  useEffect(() => {
    if (!chartRef.current) return;
    
    // Set up default options based on style guide
    const chartOptions = {
      responsive: true,
      maintainAspectRatio: true,
      plugins: {
        legend: {
          position: 'bottom',
          labels: {
            boxWidth: 12,
            padding: 15,
            font: {
              family: "'Inter', sans-serif"
            }
          }
        },
        tooltip: {
          backgroundColor: '#0F172A', // slate-900
          titleColor: '#FFFFFF',
          bodyColor: '#FFFFFF',
          padding: 12,
          cornerRadius: 4,
          titleFont: {
            weight: 'medium',
            family: "'Inter', sans-serif"
          },
          bodyFont: {
            family: "'Inter', sans-serif"
          }
        },
        title: {
          display: options.title ? true : false,
          text: options.title || '',
          font: {
            weight: 'medium',
            size: 16,
            family: "'Inter', sans-serif"
          },
          color: '#0F172A', // slate-900
          padding: {
            bottom: 16
          }
        }
      },
      // Style based on chart type
      ...(type === 'bar' && {
        scales: {
          y: {
            beginAtZero: true,
            ticks: {
              font: {
                family: "'Inter', sans-serif"
              }
            }
          },
          x: {
            ticks: {
              font: {
                family: "'Inter', sans-serif"
              }
            }
          }
        }
      }),
      ...(type === 'line' && {
        elements: {
          line: {
            tension: 0.2
          },
          point: {
            radius: 3,
            hoverRadius: 5
          }
        },
        scales: {
          y: {
            beginAtZero: true,
            ticks: {
              font: {
                family: "'Inter', sans-serif"
              }
            }
          },
          x: {
            ticks: {
              font: {
                family: "'Inter', sans-serif"
              }
            }
          }
        }
      }),
      ...(type === 'pie' || type === 'doughnut' ? {
        cutout: type === 'doughnut' ? '50%' : undefined
      } : {}),
      // Merge user options
      ...options
    };
    
    // Apply styling to datasets based on style guide
    const styledData = {
      ...data,
      datasets: data.datasets.map((dataset, index) => {
        // Define style guide colors
        const baseColors = [
          '#2563EB', // blue-600
          '#D946EF', // fuchsia-500
          '#F59E0B', // amber-500
          '#10B981', // emerald-500
          '#6366F1', // indigo-500
          '#EF4444', // red-500
          '#8B5CF6', // violet-500
          '#EC4899', // pink-500
          '#06B6D4', // cyan-500
          '#84CC16'  // lime-500
        ];
        
        // Style based on chart type
        if (type === 'bar') {
          return {
            ...dataset,
            backgroundColor: dataset.backgroundColor || baseColors,
            borderColor: dataset.borderColor || baseColors,
            borderWidth: dataset.borderWidth || 0,
            borderRadius: 4,
            maxBarThickness: 40
          };
        } else if (type === 'line') {
          return {
            ...dataset,
            backgroundColor: dataset.backgroundColor || 'rgba(37, 99, 235, 0.1)', // blue-600 with transparency
            borderColor: dataset.borderColor || '#2563EB', // blue-600
            borderWidth: dataset.borderWidth || 2,
            fill: true
          };
        } else if (type === 'pie' || type === 'doughnut') {
          // For pie/doughnut charts, we need an array of colors
          const colors = Array.isArray(dataset.backgroundColor) 
            ? dataset.backgroundColor 
            : baseColors.slice(0, data.labels.length);
          
          return {
            ...dataset,
            backgroundColor: colors,
            borderColor: '#FFFFFF',
            borderWidth: 2
          };
        }
        
        return dataset;
      })
    };
    
    // Destroy existing chart if it exists
    if (chartInstance.current) {
      chartInstance.current.destroy();
    }
    
    // Create new chart
    const ctx = chartRef.current.getContext('2d');
    if (ctx) {
      chartInstance.current = new Chart(ctx, {
        type: parseChartType(type),
        data: styledData,
        options: chartOptions
      });
    }
    
    // Clean up on unmount
    return () => {
      if (chartInstance.current) {
        chartInstance.current.destroy();
      }
    };
  }, [type, data, options]);
  
  return (
    <div className="w-full h-full relative">
      {showExport && visualizationId && (
        <div className="absolute top-2 right-2 z-10">
          <ExportButton
            type="visualization"
            visualizationId={visualizationId}
            className="bg-white/80 hover:bg-white shadow-sm"
          />
        </div>
      )}
      <canvas ref={chartRef} />
    </div>
  );
};

export default ChartPreview;
</file>

<file path="client/src/layouts/MainLayout.tsx">
import { FC } from 'react';
import { Outlet } from 'react-router-dom';
import Sidebar from '../components/common/Sidebar';

/**
 * Main application layout with sidebar navigation
 */
const MainLayout: FC = () => {
  return (
    <div className="h-screen flex overflow-hidden bg-slate-50">
      {/* Sidebar */}
      <Sidebar />
      
      {/* Main content area */}
      <div className="flex-1 overflow-auto">
        <main className="p-6">
          <Outlet />
        </main>
      </div>
    </div>
  );
};

export default MainLayout;
</file>

<file path="client/src/pages/NotFound.tsx">
import { FC } from 'react';
import { Link } from 'react-router-dom';

/**
 * 404 Not Found Page
 */
const NotFound: FC = () => {
  return (
    <div className="flex flex-col items-center justify-center py-12">
      <h1 className="text-5xl font-bold text-slate-900 mb-4">404</h1>
      <p className="text-xl text-slate-600 mb-8">Page not found</p>
      <Link 
        to="/"
        className="px-4 py-2 bg-primary text-white rounded text-sm font-medium hover:bg-primary-dark transition-colors"
      >
        Go back home
      </Link>
    </div>
  );
};

export default NotFound;
</file>

<file path="client/src/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Base styles from design system */
@layer base {
  :root {
    --chart-height-sm: 200px;
    --chart-height-md: 300px;
    --chart-height-lg: 400px;
    
    --transition-duration-default: 150ms;
    --transition-duration-long: 300ms;
    
    --shadow-color: 215 25% 27%;
  }

  html {
    @apply text-slate-900;
  }

  body {
    @apply bg-slate-50;
  }

  h1, h2, h3, h4, h5, h6 {
    @apply font-medium;
  }
}

/* Component styles */
@layer components {
  .btn-primary {
    @apply px-4 py-2 bg-primary text-white rounded hover:bg-primary-dark focus:outline-none focus:ring-2 focus:ring-primary focus:ring-opacity-50 transition-colors font-medium text-sm;
  }
  
  .btn-secondary {
    @apply px-4 py-2 bg-white text-slate-900 border border-slate-300 rounded hover:bg-slate-50 focus:outline-none focus:ring-2 focus:ring-primary focus:ring-opacity-50 transition-colors font-medium text-sm;
  }
  
  .btn-tertiary {
    @apply px-3 py-1.5 text-primary rounded hover:bg-blue-50 focus:outline-none focus:ring-2 focus:ring-primary focus:ring-opacity-50 transition-colors font-medium text-sm;
  }
  
  .form-input {
    @apply w-full px-3 py-2 border border-slate-300 rounded-sm text-sm text-slate-900 placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-primary focus:border-primary;
  }
  
  .card {
    @apply bg-white border border-slate-200 rounded p-4 shadow-sm;
  }
  
  .card-interactive {
    @apply bg-white border border-slate-200 rounded p-4 shadow-sm hover:shadow transition-shadow;
  }
  
  .tab-active {
    @apply py-3 border-b-2 border-primary font-medium text-sm text-primary;
  }
  
  .tab-inactive {
    @apply py-3 border-b-2 border-transparent font-medium text-sm text-slate-500 hover:text-slate-700 hover:border-slate-300;
  }
}

/* Chart.js global styles */
.chart-container {
  position: relative;
  height: var(--chart-height-md);
  width: 100%;
}

/* Hover effects for interactive elements */
.hover-transition {
  @apply transition-colors duration-150 ease-in-out;
}

/* Modal/dialog transitions */
.modal-transition {
  @apply transition-opacity duration-300 ease-in-out;
}

/* Expanding elements transitions */
.expand-transition {
  @apply transition-all duration-300 ease-out;
}
</file>

<file path="client/src/main.tsx">
import React from 'react'
import ReactDOM from 'react-dom/client'
import { BrowserRouter } from 'react-router-dom'
import App from './App'
import './index.css'

// Ensure we have a single clean render
document.addEventListener('DOMContentLoaded', () => {
  const rootElement = document.getElementById('root')
  
  if (rootElement) {
    // Clear any existing content to prevent duplicates
    rootElement.innerHTML = ''
    
    // Create root and render once
    const root = ReactDOM.createRoot(rootElement)
    root.render(
      <BrowserRouter>
        <App />
      </BrowserRouter>
    )
  }
})
</file>

<file path="client/src/types.ts">
/**
 * Type definitions for the SQLite Visualizer application
 */

// Database connection
export interface Connection {
  id: number;
  name: string;
  path: string;
  last_accessed: string;
  size_bytes?: number;
  table_count?: number;
  is_valid: boolean;
}

// Template for pre-configured visualizations
export interface Template {
  id: number;
  name: string;
  description: string;
  type: string;
  config: any;
  category: string;
  is_default: boolean;
}

// Saved visualization
export interface Visualization {
  id: number;
  connection_id: number | null;
  name: string;
  type: string;
  config: any;
  table_name: string | null;
  created_at: string;
  updated_at: string;
}

// Table info
export interface TableInfo {
  name: string;
  type?: string;
  rowCount?: number;
}

// Table schema
export interface TableSchema {
  columns: Column[];
}

// Table column
export interface Column {
  name: string;
  type: string;
  nullable: boolean;
  primaryKey?: boolean;
  defaultValue?: string | null;
}

// Pagination parameters
export interface PaginationParams {
  page: number;
  limit: number;
  sort?: string;
  direction?: 'asc' | 'desc';
}

// API error
export interface ApiError extends Error {
  status?: number;
}

// Chart data
export interface ChartData {
  labels: string[];
  datasets: {
    label: string;
    data: number[];
    backgroundColor: string | string[];
    borderColor?: string | string[];
    borderWidth?: number;
  }[];
}

// Field mapping for charts
export interface FieldMapping {
  [key: string]: string;
}
</file>

<file path="client/tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        // Primary Colors
        primary: {
          DEFAULT: '#2563EB', // blue-600
          dark: '#1E40AF',    // blue-800
          light: '#DBEAFE',   // blue-100
        },
        // Semantic Colors
        success: {
          DEFAULT: '#10B981', // emerald-500
        },
        warning: {
          DEFAULT: '#F59E0B', // amber-500
        },
        error: {
          DEFAULT: '#EF4444', // red-500
        },
        info: {
          DEFAULT: '#0EA5E9', // sky-500
        },
        // Chart Colors
        chart: {
          1: '#2563EB', // blue-600
          2: '#D946EF', // fuchsia-500
          3: '#F59E0B', // amber-500
          4: '#10B981', // emerald-500
          5: '#6366F1', // indigo-500
          6: '#EF4444', // red-500
          7: '#8B5CF6', // violet-500
          8: '#EC4899', // pink-500
          9: '#06B6D4', // cyan-500
          10: '#84CC16', // lime-500
        }
      },
      fontFamily: {
        sans: ['Inter', 'ui-sans-serif', 'system-ui', '-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'Helvetica Neue', 'Arial', 'sans-serif'],
      },
      boxShadow: {
        'focus': '0 0 0 2px rgba(37, 99, 235, 0.5)', // Custom focus shadow for primary color
      },
    },
  },
  plugins: [
    require('@tailwindcss/forms')
  ],
}
</file>

<file path="scripts/setup-db.js">
/**
 * Database Setup Script
 * 
 * Creates and initializes the application database with required tables
 */

const Database = require('better-sqlite3');
const path = require('path');
const fs = require('fs');

// Database path
const dbDir = path.join(__dirname, '../data');
const dbPath = path.join(dbDir, 'app.sqlite');

// Ensure data directory exists
if (!fs.existsSync(dbDir)) {
  console.log(`Creating data directory: ${dbDir}`);
  fs.mkdirSync(dbDir, { recursive: true });
}

// Connect to database
console.log(`Setting up database at: ${dbPath}`);
const db = new Database(dbPath);

// Enable foreign keys
db.pragma('foreign_keys = ON');

// Create tables
console.log('Creating tables...');

// Connections table
db.exec(`
  CREATE TABLE IF NOT EXISTS connections (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    path TEXT NOT NULL,
    last_accessed TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    size_bytes INTEGER,
    table_count INTEGER,
    is_valid INTEGER DEFAULT 1
  );
`);

// Saved visualizations table
db.exec(`
  CREATE TABLE IF NOT EXISTS saved_visualizations (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    connection_id INTEGER,
    name TEXT NOT NULL,
    type TEXT NOT NULL,
    config TEXT NOT NULL,
    table_name TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (connection_id) REFERENCES connections(id) ON DELETE CASCADE
  );
`);

// Insight templates table
db.exec(`
  CREATE TABLE IF NOT EXISTS insight_templates (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    description TEXT,
    type TEXT NOT NULL,
    config TEXT NOT NULL,
    category TEXT,
    is_default BOOLEAN DEFAULT 0
  );
`);

// Add default templates
console.log('Adding default insight templates...');

const defaultTemplates = [
  {
    name: 'Top Selling Products',
    description: 'Visualizes your top selling products by revenue or quantity',
    type: 'bar',
    config: JSON.stringify({
      title: 'Top Selling Products',
      mappings: {
        x: 'product_name',
        y: 'revenue',
        sort: 'desc',
        limit: 10
      }
    }),
    category: 'sales',
    is_default: 1
  },
  {
    name: 'Monthly Sales Trend',
    description: 'Shows sales trends over monthly periods',
    type: 'line',
    config: JSON.stringify({
      title: 'Monthly Sales Trend',
      mappings: {
        x: 'month',
        y: 'revenue',
        groupBy: 'month'
      }
    }),
    category: 'sales',
    is_default: 1
  },
  {
    name: 'Customer Distribution',
    description: 'Breaks down customers by region or category',
    type: 'pie',
    config: JSON.stringify({
      title: 'Customer Distribution',
      mappings: {
        labels: 'region',
        values: 'customer_count'
      }
    }),
    category: 'customers',
    is_default: 1
  }
];

// Insert default templates
const insertTemplate = db.prepare(`
  INSERT INTO insight_templates (name, description, type, config, category, is_default)
  VALUES (?, ?, ?, ?, ?, ?)
`);

// Use a transaction to insert multiple templates
const insertTemplates = db.transaction((templates) => {
  for (const template of templates) {
    insertTemplate.run(
      template.name,
      template.description,
      template.type,
      template.config,
      template.category,
      template.is_default
    );
  }
});

// Check if templates already exist
const templateCount = db.prepare('SELECT COUNT(*) as count FROM insight_templates').get();

if (templateCount.count === 0) {
  insertTemplates(defaultTemplates);
  console.log(`Added ${defaultTemplates.length} default templates`);
} else {
  console.log(`Templates already exist, skipping...`);
}

console.log('Database setup complete!');

// Close the database connection
db.close();
</file>

<file path="server/models/visualization.js">
/**
 * Visualization Model
 * 
 * Represents a saved visualization in the application
 */

/**
 * Visualization schema:
 * {
 *   id: number,
 *   connection_id: number,
 *   name: string,
 *   type: string,
 *   config: JSON string,
 *   table_name: string,
 *   created_at: timestamp,
 *   updated_at: timestamp
 * }
 */

const appDbService = require('../services/appDbService');

/**
 * Create a new visualization record
 * @param {Object} visualizationData - Visualization details
 * @returns {Object} Created visualization with ID
 */
function create(visualizationData) {
  const db = appDbService.getDb();
  
  try {
    // Prepare SQL statement for insertion
    const stmt = db.prepare(`
      INSERT INTO saved_visualizations (
        connection_id,
        name,
        type,
        config,
        table_name,
        created_at,
        updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?)
    `);
    
    const now = new Date().toISOString();
    
    // Make sure config is a string if it's an object
    let configStr = visualizationData.config;
    if (typeof configStr === 'object') {
      configStr = JSON.stringify(configStr);
    }
    
    // Execute the insertion
    const info = stmt.run(
      visualizationData.connection_id || null,
      visualizationData.name,
      visualizationData.type,
      configStr,
      visualizationData.table_name || null,
      now,
      now
    );
    
    // Return the created visualization with ID
    return {
      id: info.lastInsertRowid,
      ...visualizationData,
      created_at: now,
      updated_at: now
    };
  } catch (error) {
    console.error('Error creating visualization record:', error);
    throw new Error('Failed to create visualization record');
  }
}

/**
 * Find a visualization by ID
 * @param {number} id - Visualization ID
 * @returns {Object|null} Visualization object or null if not found
 */
function findById(id) {
  const db = appDbService.getDb();
  
  try {
    // Prepare and execute the query
    const stmt = db.prepare('SELECT * FROM saved_visualizations WHERE id = ?');
    const visualization = stmt.get(id);
    
    if (!visualization) {
      return null;
    }
    
    // Parse config JSON
    try {
      visualization.config = JSON.parse(visualization.config);
    } catch (e) {
      console.warn(`Failed to parse config JSON for visualization ${id}:`, e);
      // Leave as-is if parsing fails
    }
    
    return visualization;
  } catch (error) {
    console.error(`Error finding visualization with ID ${id}:`, error);
    throw new Error('Failed to find visualization');
  }
}

/**
 * Find all visualizations
 * @param {Object} filters - Optional filters
 * @returns {Array} Array of visualization objects
 */
function findAll(filters = {}) {
  const db = appDbService.getDb();
  
  try {
    let query = 'SELECT * FROM saved_visualizations';
    const params = [];
    
    // Apply filters if provided
    if (filters && Object.keys(filters).length > 0) {
      const filterClauses = [];
      
      if (filters.connection_id) {
        filterClauses.push('connection_id = ?');
        params.push(filters.connection_id);
      }
      
      if (filters.type) {
        filterClauses.push('type = ?');
        params.push(filters.type);
      }
      
      if (filters.table_name) {
        filterClauses.push('table_name = ?');
        params.push(filters.table_name);
      }
      
      if (filterClauses.length > 0) {
        query += ' WHERE ' + filterClauses.join(' AND ');
      }
    }
    
    // Add default ordering
    query += ' ORDER BY updated_at DESC';
    
    // Execute the query
    const stmt = db.prepare(query);
    const visualizations = stmt.all(...params);
    
    // Parse config JSON for each visualization
    return visualizations.map(viz => {
      try {
        viz.config = JSON.parse(viz.config);
      } catch (e) {
        console.warn(`Failed to parse config JSON for visualization ${viz.id}:`, e);
        // Leave as-is if parsing fails
      }
      return viz;
    });
  } catch (error) {
    console.error('Error finding all visualizations:', error);
    throw new Error('Failed to retrieve visualizations');
  }
}

/**
 * Update a visualization
 * @param {number} id - Visualization ID
 * @param {Object} visualizationData - Updated visualization details
 * @returns {Object} Updated visualization
 */
function update(id, visualizationData) {
  const db = appDbService.getDb();
  
  try {
    // Get current visualization
    const currentVisualization = findById(id);
    
    if (!currentVisualization) {
      throw new Error(`Visualization with ID ${id} not found`);
    }
    
    // Build SET clause and parameters dynamically based on provided data
    const updates = [];
    const params = [];
    
    if (visualizationData.connection_id !== undefined) {
      updates.push('connection_id = ?');
      params.push(visualizationData.connection_id);
    }
    
    if (visualizationData.name !== undefined) {
      updates.push('name = ?');
      params.push(visualizationData.name);
    }
    
    if (visualizationData.type !== undefined) {
      updates.push('type = ?');
      params.push(visualizationData.type);
    }
    
    if (visualizationData.config !== undefined) {
      updates.push('config = ?');
      // Make sure config is a string if it's an object
      let configStr = visualizationData.config;
      if (typeof configStr === 'object') {
        configStr = JSON.stringify(configStr);
      }
      params.push(configStr);
    }
    
    if (visualizationData.table_name !== undefined) {
      updates.push('table_name = ?');
      params.push(visualizationData.table_name);
    }
    
    // Always update the updated_at timestamp
    updates.push('updated_at = ?');
    params.push(new Date().toISOString());
    
    // If no updates, return the current visualization
    if (updates.length === 0) {
      return currentVisualization;
    }
    
    // Add ID to params
    params.push(id);
    
    // Prepare and execute the update
    const stmt = db.prepare(`
      UPDATE saved_visualizations 
      SET ${updates.join(', ')}
      WHERE id = ?
    `);
    
    stmt.run(...params);
    
    // Return updated visualization
    return findById(id);
  } catch (error) {
    console.error(`Error updating visualization with ID ${id}:`, error);
    throw new Error('Failed to update visualization');
  }
}

/**
 * Remove a visualization
 * @param {number} id - Visualization ID
 * @returns {boolean} True if deleted successfully
 */
function remove(id) {
  const db = appDbService.getDb();
  
  try {
    // Prepare and execute the deletion
    const stmt = db.prepare('DELETE FROM saved_visualizations WHERE id = ?');
    const result = stmt.run(id);
    
    return result.changes > 0;
  } catch (error) {
    console.error(`Error removing visualization with ID ${id}:`, error);
    throw new Error('Failed to remove visualization');
  }
}

module.exports = {
  create,
  findById,
  findAll,
  update,
  remove
};
</file>

<file path="server/routes/templates.js">
/**
 * Templates Route Handler
 * 
 * Handles all API endpoints related to insight templates
 */

const express = require('express');
const router = express.Router();
const templateService = require('../services/templateService');
const templateModel = require('../models/template');

/**
 * GET /api/templates/categories
 * Get all unique template categories
 */
router.get('/categories', async (req, res, next) => {
  try {
    const categories = await templateService.getTemplateCategories();
    res.json(categories);
  } catch (error) {
    next(error);
  }
});

/**
 * GET /api/templates
 * List all insight templates
 */
router.get('/', async (req, res, next) => {
  try {
    // Get filters from query parameters
    const filters = {};
    
    if (req.query.category) {
      filters.category = req.query.category;
    }
    
    if (req.query.type) {
      filters.type = req.query.type;
    }
    
    if (req.query.isDefault !== undefined) {
      filters.isDefault = req.query.isDefault === 'true';
    }
    
    if (req.query.search) {
      filters.search = req.query.search;
    }
    
    const templates = await templateService.getAllTemplates(filters);
    res.json(templates);
  } catch (error) {
    next(error);
  }
});

/**
 * GET /api/templates/:id
 * Get template details
 */
router.get('/:id', async (req, res, next) => {
  try {
    const template = await templateService.getTemplateById(req.params.id);
    if (!template) {
      return res.status(404).json({ message: 'Template not found' });
    }
    res.json(template);
  } catch (error) {
    next(error);
  }
});

/**
 * POST /api/templates
 * Create a new template
 */
router.post('/', async (req, res, next) => {
  try {
    const templateData = req.body;
    const createdTemplate = await templateModel.create(templateData);
    res.status(201).json(createdTemplate);
  } catch (error) {
    next(error);
  }
});

/**
 * PUT /api/templates/:id
 * Update an existing template
 */
router.put('/:id', async (req, res, next) => {
  try {
    const templateData = req.body;
    const updatedTemplate = await templateModel.update(req.params.id, templateData);
    
    if (!updatedTemplate) {
      return res.status(404).json({ message: 'Template not found' });
    }
    
    res.json(updatedTemplate);
  } catch (error) {
    next(error);
  }
});

/**
 * DELETE /api/templates/:id
 * Delete a template
 */
router.delete('/:id', async (req, res, next) => {
  try {
    const deleted = await templateModel.remove(req.params.id);
    
    if (!deleted) {
      return res.status(404).json({ message: 'Template not found' });
    }
    
    res.status(204).send();
  } catch (error) {
    next(error);
  }
});

/**
 * GET /api/templates/:id/requirements
 * Get template field requirements
 */
router.get('/:id/requirements', async (req, res, next) => {
  try {
    const requirements = await templateService.getTemplateRequirements(req.params.id);
    res.json(requirements);
  } catch (error) {
    next(error);
  }
});

/**
 * POST /api/templates/:id/apply
 * Apply template to selected data
 */
router.post('/:id/apply', async (req, res, next) => {
  try {
    const { connectionId, tableNames, mappings } = req.body;
    
    const result = await templateService.applyTemplate(
      req.params.id,
      connectionId,
      tableNames,
      mappings
    );
    
    res.json(result);
  } catch (error) {
    next(error);
  }
});

module.exports = router;
</file>

<file path="server/routes/visualizations.js">
/**
 * Visualizations Route Handler
 * 
 * Handles all API endpoints related to visualizations
 */

const express = require('express');
const router = express.Router();
const visualizationService = require('../services/visualizationService');
const { validateBody, validateParams, schemas } = require('../middleware/dataValidator');

/**
 * POST /api/visualizations
 * Create a new visualization
 */
router.post('/', 
  validateBody(schemas.visualization.create),
  async (req, res, next) => {
    try {
      const newVisualization = await visualizationService.createVisualization(req.body);
      res.status(201).json({
        success: true,
        message: 'Visualization created successfully',
        data: newVisualization
      });
    } catch (error) {
      next(error);
    }
  }
);

/**
 * GET /api/visualizations
 * List all saved visualizations
 */
router.get('/', async (req, res, next) => {
  try {
    const visualizations = await visualizationService.getAllVisualizations();
    res.json({
      success: true,
      data: visualizations
    });
  } catch (error) {
    next(error);
  }
});

/**
 * GET /api/visualizations/:id
 * Get visualization details
 */
router.get('/:id', 
  validateParams(schemas.visualization.id),
  async (req, res, next) => {
    try {
      const visualization = await visualizationService.getVisualizationById(req.params.id);
      if (!visualization) {
        return res.status(404).json({ 
          success: false,
          message: 'Visualization not found' 
        });
      }
      res.json({
        success: true,
        data: visualization
      });
    } catch (error) {
      next(error);
    }
  }
);

/**
 * PUT /api/visualizations/:id
 * Update a visualization
 */
router.put('/:id', 
  validateParams(schemas.visualization.id),
  validateBody(schemas.visualization.update),
  async (req, res, next) => {
    try {
      const updatedVisualization = await visualizationService.updateVisualization(
        req.params.id,
        req.body
      );
      
      if (!updatedVisualization) {
        return res.status(404).json({
          success: false,
          message: 'Visualization not found'
        });
      }
      
      res.json({
        success: true,
        message: 'Visualization updated successfully',
        data: updatedVisualization
      });
    } catch (error) {
      next(error);
    }
  }
);

/**
 * DELETE /api/visualizations/:id
 * Delete a visualization
 */
router.delete('/:id', 
  validateParams(schemas.visualization.id),
  async (req, res, next) => {
    try {
      const result = await visualizationService.deleteVisualization(req.params.id);
      
      if (!result) {
        return res.status(404).json({
          success: false,
          message: 'Visualization not found'
        });
      }
      
      res.status(200).json({
        success: true,
        message: 'Visualization deleted successfully'
      });
    } catch (error) {
      next(error);
    }
  }
);

/**
 * PATCH /api/visualizations/:id
 * Partially update a visualization
 */
router.patch('/:id', 
  validateParams(schemas.visualization.id),
  validateBody(schemas.visualization.update),
  async (req, res, next) => {
    try {
      const updatedVisualization = await visualizationService.updateVisualization(
        req.params.id,
        req.body
      );
      
      if (!updatedVisualization) {
        return res.status(404).json({
          success: false,
          message: 'Visualization not found'
        });
      }
      
      res.json({
        success: true,
        message: 'Visualization updated successfully',
        data: updatedVisualization
      });
    } catch (error) {
      next(error);
    }
  }
);

module.exports = router;
</file>

<file path=".gitignore">
# Dependency directories
node_modules/
/.pnp
.pnp.js

# Build outputs
/dist
/build
/out

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Debug logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Editor directories and files
.idea/
.vscode/
*.swp
*.swo

# SQLite database files
*.db
*.sqlite
*.sqlite3

# System files
.DS_Store
Thumbs.db
.aider*
</file>

<file path="client/src/components/common/Sidebar.tsx">
import { FC } from 'react';
import { NavLink } from 'react-router-dom';

/**
 * Application sidebar navigation component
 */
const Sidebar: FC = () => {
  return (
    <div className="w-64 bg-white border-r border-slate-200 flex flex-col">
      {/* Logo */}
      <div className="p-4 border-b border-slate-200">
        <h1 className="text-2xl font-semibold text-slate-900">SQLite Visualizer</h1>
      </div>
      
      {/* Navigation Links */}
      <nav className="flex-1 p-4">
        <ul className="space-y-1">
          <li>
            <NavLink
              to="/"
              className={({ isActive }) =>
                `block px-4 py-2 rounded text-sm ${
                  isActive 
                    ? 'bg-primary-light text-primary font-medium' 
                    : 'text-slate-700 hover:bg-slate-100'
                }`
              }
              end
            >
              Connections
            </NavLink>
          </li>
          <li>
            <NavLink
              to="/visualize"
              className={({ isActive }) =>
                `block px-4 py-2 rounded text-sm ${
                  isActive 
                    ? 'bg-primary-light text-primary font-medium' 
                    : 'text-slate-700 hover:bg-slate-100'
                }`
              }
            >
              Visualization Builder
            </NavLink>
          </li>
          <li>
            <NavLink
              to="/gallery"
              className={({ isActive }) =>
                `block px-4 py-2 rounded text-sm ${
                  isActive 
                    ? 'bg-primary-light text-primary font-medium' 
                    : 'text-slate-700 hover:bg-slate-100'
                }`
              }
            >
              Saved Visualizations
            </NavLink>
          </li>
          <li>
            <NavLink
              to="/templates"
              className={({ isActive }) =>
                `block px-4 py-2 rounded text-sm ${
                  isActive 
                    ? 'bg-primary-light text-primary font-medium' 
                    : 'text-slate-700 hover:bg-slate-100'
                }`
              }
            >
              Insight Templates
            </NavLink>
          </li>
        </ul>
      </nav>
      
      {/* Footer */}
      <div className="p-4 border-t border-slate-200">
        <div className="text-xs text-slate-500">SQLite Visualizer v0.1.0</div>
      </div>
    </div>
  );
};

export default Sidebar;
</file>

<file path="client/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="/vite.svg" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <title>SQLite Visualizer</title>
  <style>
    /* Ensure we only display one sidebar */
    #root > div:not(:first-child) {
      display: none;
    }
  </style>
</head>
<body>
  <!-- Single root element for React application -->
  <div id="root"></div>
  <script type="module" src="/src/main.tsx"></script>
</body>
</html>
</file>

<file path="server/middleware/dataValidator.js">
/**
 * Data Validator Middleware
 * 
 * Validates request data against Joi schemas
 */

const Joi = require('joi');

/**
 * Validate request body against a schema
 * @param {Object} schema - Joi validation schema
 * @returns {Function} Express middleware function
 */
function validateBody(schema) {
  return (req, res, next) => {
    if (!schema) {
      return next();
    }

    const { error, value } = schema.validate(req.body, {
      abortEarly: false,
      stripUnknown: true,
      errors: {
        wrap: {
          label: ''
        }
      }
    });
    
    if (error) {
      return res.status(400).json({
        success: false,
        message: 'Validation Error',
        errors: error.details.map(detail => detail.message)
      });
    }
    
    // Replace request body with validated and sanitized data
    req.body = value;
    next();
  };
}

/**
 * Validate request query parameters against a schema
 * @param {Object} schema - Joi validation schema
 * @returns {Function} Express middleware function
 */
function validateQuery(schema) {
  return (req, res, next) => {
    if (!schema) {
      return next();
    }

    const { error, value } = schema.validate(req.query, {
      abortEarly: false,
      stripUnknown: true,
      errors: {
        wrap: {
          label: ''
        }
      }
    });
    
    if (error) {
      return res.status(400).json({
        success: false,
        message: 'Validation Error',
        errors: error.details.map(detail => detail.message)
      });
    }
    
    // Replace request query with validated and sanitized data
    req.query = value;
    next();
  };
}

/**
 * Validate request parameters against a schema
 * @param {Object} schema - Joi validation schema
 * @returns {Function} Express middleware function
 */
function validateParams(schema) {
  return (req, res, next) => {
    if (!schema) {
      return next();
    }

    const { error, value } = schema.validate(req.params, {
      abortEarly: false,
      stripUnknown: false, // Don't strip unknown for route params
      errors: {
        wrap: {
          label: ''
        }
      }
    });
    
    if (error) {
      return res.status(400).json({
        success: false,
        message: 'Validation Error',
        errors: error.details.map(detail => detail.message)
      });
    }
    
    // Replace request params with validated data
    req.params = value;
    next();
  };
}

/**
 * Create validation schemas for common data patterns
 */
const schemas = {
  // Database connection schemas
  connection: {
    create: Joi.object({
      name: Joi.string().trim().min(1).max(100).required()
        .messages({
          'string.empty': 'Connection name is required',
          'string.min': 'Connection name must be at least 1 character long',
          'string.max': 'Connection name cannot exceed 100 characters'
        }),
      path: Joi.string().trim().min(1).required()
        .messages({
          'string.empty': 'Database path is required'
        })
    }),
    
    id: Joi.object({
      id: Joi.number().integer().positive().required()
        .messages({
          'number.base': 'Connection ID must be a number',
          'number.integer': 'Connection ID must be an integer',
          'number.positive': 'Connection ID must be positive'
        })
    })
  },
  
  // Visualization schemas
  visualization: {
    create: Joi.object({
      connection_id: Joi.number().integer().positive().required()
        .messages({
          'number.base': 'Connection ID must be a number',
          'number.integer': 'Connection ID must be an integer',
          'number.positive': 'Connection ID must be positive'
        }),
      name: Joi.string().trim().min(1).max(100).required()
        .messages({
          'string.empty': 'Visualization name is required',
          'string.min': 'Visualization name must be at least 1 character long',
          'string.max': 'Visualization name cannot exceed 100 characters'
        }),
      type: Joi.string().valid('bar', 'pie', 'line', 'scatter', 'area').required()
        .messages({
          'any.only': 'Visualization type must be one of: bar, pie, line, scatter, area'
        }),
      config: Joi.object().required()
        .messages({
          'object.base': 'Chart configuration must be a valid object'
        }),
      table_name: Joi.string().trim().min(1).required()
        .messages({
          'string.empty': 'Table name is required'
        })
    }),
    
    id: Joi.object({
      id: Joi.number().integer().positive().required()
        .messages({
          'number.base': 'Visualization ID must be a number',
          'number.integer': 'Visualization ID must be an integer',
          'number.positive': 'Visualization ID must be positive'
        })
    }),
    
    update: Joi.object({
      name: Joi.string().trim().min(1).max(100)
        .messages({
          'string.empty': 'Visualization name cannot be empty',
          'string.min': 'Visualization name must be at least 1 character long',
          'string.max': 'Visualization name cannot exceed 100 characters'
        }),
      type: Joi.string().valid('bar', 'pie', 'line', 'scatter', 'area')
        .messages({
          'any.only': 'Visualization type must be one of: bar, pie, line, scatter, area'
        }),
      config: Joi.object()
        .messages({
          'object.base': 'Chart configuration must be a valid object'
        })
    }).min(1).messages({
      'object.min': 'At least one field must be provided for update'
    })
  },
  
  // Table data schemas
  table: {
    query: Joi.object({
      page: Joi.number().integer().min(1).default(1)
        .messages({
          'number.base': 'Page must be a number',
          'number.integer': 'Page must be an integer',
          'number.min': 'Page must be at least 1'
        }),
      limit: Joi.number().integer().min(1).max(1000).default(100)
        .messages({
          'number.base': 'Limit must be a number',
          'number.integer': 'Limit must be an integer',
          'number.min': 'Limit must be at least 1',
          'number.max': 'Limit cannot exceed 1000'
        }),
      sort: Joi.string().pattern(/^[\w]+$/, { name: 'column name' })
        .messages({
          'string.pattern.name': 'Sort column must contain only alphanumeric characters and underscores'
        }),
      order: Joi.string().valid('asc', 'desc').default('asc')
        .messages({
          'any.only': 'Order must be either "asc" or "desc"'
        }),
      filter: Joi.string()
    })
  },
  
  // Export schemas
  export: {
    csv: Joi.object({
      format: Joi.string().valid('csv').default('csv')
    }),
    json: Joi.object({
      includeSchema: Joi.boolean().default(true),
      format: Joi.string().valid('json').default('json')
    }),
    query: Joi.object({
      limit: Joi.number().integer().min(1).max(100000).default(1000),
      filter: Joi.string().optional(),
      sort: Joi.string().optional(),
      includeSchema: Joi.boolean().default(true)
    })
  }
};

module.exports = {
  validateBody,
  validateQuery,
  validateParams,
  schemas
};
</file>

<file path="server/middleware/errorHandler.js">
/**
 * Error Handler Middleware
 * 
 * Centralized error handling for the API
 */

/**
 * Error handler middleware
 */
function errorHandler(err, req, res, next) {
  // Log the error for server-side debugging
  console.error('Error handling request:', {
    url: req.url,
    method: req.method,
    error: err.message,
    stack: process.env.NODE_ENV === 'development' ? err.stack : undefined
  });
  
  // Default error status and message
  let statusCode = err.statusCode || 500;
  let message = err.message || 'Internal Server Error';
  let errors = err.errors || null;
  let errorDetails = null;
  
  // Handle specific error types
  if (err.name === 'ValidationError') {
    // Handle validation library errors (like Mongoose)
    statusCode = 400;
    message = 'Validation Error';
  } else if (err.name === 'Error' && err.isJoi === true) {
    // Handle Joi validation errors
    statusCode = 400;
    message = 'Validation Error';
    
    // Format Joi validation errors
    errorDetails = err.details.map(detail => ({
      message: detail.message,
      path: detail.path,
      type: detail.type
    }));
    
    // Extract only the messages for a simplified error response
    errors = err.details.map(detail => detail.message);
  } else if (err.code === 'SQLITE_CONSTRAINT') {
    statusCode = 400;
    message = 'Database Constraint Error';
    
    // Try to extract a more helpful message from the error
    if (err.message.includes('UNIQUE constraint failed')) {
      const matches = err.message.match(/UNIQUE constraint failed: (.+)/);
      if (matches && matches[1]) {
        const field = matches[1].split('.').pop();
        message = `The provided ${field} already exists`;
      }
    }
  } else if (err.code === 'SQLITE_ERROR') {
    statusCode = 400;
    message = 'Database Error';
    
    // Check if it's a syntax error that might expose schema details
    if (err.message.includes('syntax error')) {
      message = 'Invalid SQL query syntax';
      // Don't expose the actual error in production
      if (process.env.NODE_ENV !== 'development') {
        err.message = message;
      }
    }
  } else if (err.code === 'ENOENT' && err.message.includes('no such file or directory')) {
    statusCode = 404; 
    message = 'File not found: ' + (err.path || 'Unknown path');
  } else if (err.message === 'Connection not found') {
    statusCode = 404;
    message = 'Database connection not found';
  } else if (err.message === 'Table not found') {
    statusCode = 404;
    message = 'The requested table does not exist';
  } else if (err.message === 'Visualization not found') {
    statusCode = 404;
    message = 'The requested visualization does not exist';
  }
  
  // In production, limit detailed error information
  if (process.env.NODE_ENV === 'production') {
    // For 500 errors, use a generic message
    if (statusCode === 500) {
      message = 'Internal Server Error';
      err.message = message; // Don't expose detailed internal error messages
    }
    
    // Don't include stack traces in production
    err.stack = undefined;
    
    // Still allow validation errors to be shown to users
    if (statusCode !== 400) {
      errorDetails = null;
    }
  }
  
  // Send error response
  const errorResponse = {
    success: false,
    status: statusCode,
    message,
  };
  
  // Include errors array if it exists
  if (errors) {
    errorResponse.errors = errors;
  }
  
  // Include detailed error information in development
  if (process.env.NODE_ENV === 'development') {
    errorResponse.error = err.message;
    errorResponse.stack = err.stack;
    
    if (errorDetails) {
      errorResponse.errorDetails = errorDetails;
    }
  }
  
  res.status(statusCode).json(errorResponse);
}

module.exports = errorHandler;
</file>

<file path="server/models/template.js">
/**
 * Template Model
 * 
 * Represents an insight template in the application for visualizing data.
 * Templates provide pre-configured visualization settings that users can apply
 * to their database tables with minimal configuration.
 */

/**
 * Template schema:
 * {
 *   id: number,          // Unique identifier for the template
 *   name: string,        // Display name of the template
 *   description: string, // Optional description of what the template visualizes
 *   type: string,        // Chart type (bar, line, pie, doughnut, etc.)
 *   config: JSON string, // Configuration including mappings and display settings
 *   category: string,    // Category for grouping/filtering templates (sales, performance, etc.)
 *   is_default: boolean  // Whether this is a built-in template
 * }
 */

const appDbService = require('../services/appDbService');

/**
 * Create a new template record
 * @param {Object} templateData - Template details
 * @param {string} templateData.name - Display name of the template
 * @param {string} [templateData.description] - Description of what the template visualizes
 * @param {string} templateData.type - Chart type (bar, line, pie, doughnut, etc.)
 * @param {Object|string} templateData.config - Configuration object or JSON string
 * @param {string} [templateData.category] - Category for grouping templates
 * @param {boolean} [templateData.is_default=false] - Whether this is a built-in template
 * @returns {Promise<Object>} Created template with ID
 * @throws {Error} If required fields are missing or database operation fails
 */
async function create(templateData) {
  try {
    // Validate required fields
    const { name, type, config } = templateData;
    if (!name || typeof name !== 'string') {
      throw new Error('Template name is required and must be a string');
    }
    if (!type || typeof type !== 'string') {
      throw new Error('Template type is required and must be a string');
    }
    if (!config) {
      throw new Error('Template config is required');
    }
    
    // Convert config object to JSON string if it's not already a string
    const configStr = typeof config === 'object' ? JSON.stringify(config) : config;
    
    // Ensure is_default is properly converted to SQLite boolean (0/1)
    const isDefault = templateData.is_default ? 1 : 0;
    
    // Execute the insert
    const result = await appDbService.run(`
      INSERT INTO insight_templates (
        name, description, type, config, category, is_default
      ) VALUES (?, ?, ?, ?, ?, ?)
    `, [
      name,
      templateData.description || null,
      type,
      configStr,
      templateData.category || null,
      isDefault
    ]);
    
    // Return the created template with ID
    return {
      id: result.lastID,
      ...templateData,
      config: typeof config === 'string' ? config : configStr,
      is_default: Boolean(isDefault)
    };
  } catch (error) {
    console.error('Failed to create template:', error);
    throw error;
  }
}

/**
 * Find a template by ID
 * @param {number|string} id - Template ID
 * @returns {Promise<Object|null>} Template object or null if not found
 * @throws {Error} If database operation fails
 */
async function findById(id) {
  try {
    // Validate ID
    if (!id) {
      throw new Error('Template ID is required');
    }
    
    const template = await appDbService.get(`
      SELECT id, name, description, type, config, category, is_default
      FROM insight_templates
      WHERE id = ?
    `, [id]);
    
    if (!template) {
      return null;
    }
    
    // Parse the config JSON string to object
    try {
      template.config = JSON.parse(template.config);
    } catch (e) {
      console.warn(`Failed to parse template config for template ${id}. Using raw string.`);
    }
    
    // Convert SQLite integer boolean to JavaScript boolean
    template.is_default = Boolean(template.is_default);
    
    return template;
  } catch (error) {
    console.error(`Failed to find template with ID ${id}:`, error);
    throw error;
  }
}

/**
 * Find all templates with optional filtering
 * @param {Object} filters - Optional filters
 * @param {string} [filters.category] - Filter by category
 * @param {string} [filters.type] - Filter by chart type
 * @param {boolean} [filters.isDefault] - Filter by default status
 * @param {string} [filters.search] - Search in name and description
 * @returns {Promise<Array>} Array of template objects
 * @throws {Error} If database operation fails
 */
async function findAll(filters = {}) {
  try {
    let query = `
      SELECT id, name, description, type, config, category, is_default
      FROM insight_templates
    `;
    
    const whereConditions = [];
    const params = [];
    
    // Apply filters if provided
    if (filters.category) {
      whereConditions.push('category = ?');
      params.push(filters.category);
    }
    
    if (filters.type) {
      whereConditions.push('type = ?');
      params.push(filters.type);
    }
    
    if (filters.isDefault !== undefined) {
      whereConditions.push('is_default = ?');
      params.push(filters.isDefault ? 1 : 0);
    }
    
    // Add text search if provided
    if (filters.search) {
      whereConditions.push('(name LIKE ? OR description LIKE ?)');
      const searchTerm = `%${filters.search}%`;
      params.push(searchTerm, searchTerm);
    }
    
    if (whereConditions.length > 0) {
      query += ` WHERE ${whereConditions.join(' AND ')}`;
    }
    
    // Add ordering
    query += ' ORDER BY name ASC';
    
    const templates = await appDbService.all(query, params);
    
    // Process results
    return templates.map(template => {
      if (!template) return null;
      
      // Parse config JSON strings to objects
      if (template.config) {
        try {
          template.config = JSON.parse(template.config);
        } catch (e) {
          console.warn(`Failed to parse template config for template ${template.id}. Using raw string.`);
        }
      }
      
      // Convert SQLite integer boolean to JavaScript boolean
      template.is_default = Boolean(template.is_default);
      
      return template;
    }).filter(Boolean); // Filter out any null values
  } catch (error) {
    console.error('Failed to find templates:', error);
    throw error;
  }
}

/**
 * Update a template
 * @param {number|string} id - Template ID
 * @param {Object} templateData - Updated template details
 * @param {string} [templateData.name] - Display name of the template
 * @param {string} [templateData.description] - Description of what the template visualizes
 * @param {string} [templateData.type] - Chart type (bar, line, pie, doughnut, etc.)
 * @param {Object|string} [templateData.config] - Configuration object or JSON string
 * @param {string} [templateData.category] - Category for grouping templates
 * @param {boolean} [templateData.is_default] - Whether this is a built-in template
 * @returns {Promise<Object|null>} Updated template or null if not found
 * @throws {Error} If database operation fails
 */
async function update(id, templateData) {
  try {
    // Validate ID
    if (!id) {
      throw new Error('Template ID is required');
    }
    
    // First check if the template exists
    const existing = await findById(id);
    if (!existing) {
      return null;
    }
    
    // Prepare update fields
    const updates = [];
    const params = [];
    
    if (templateData.name !== undefined) {
      if (typeof templateData.name !== 'string' || !templateData.name.trim()) {
        throw new Error('Template name must be a non-empty string');
      }
      updates.push('name = ?');
      params.push(templateData.name);
    }
    
    if (templateData.description !== undefined) {
      updates.push('description = ?');
      params.push(templateData.description);
    }
    
    if (templateData.type !== undefined) {
      if (typeof templateData.type !== 'string' || !templateData.type.trim()) {
        throw new Error('Template type must be a non-empty string');
      }
      updates.push('type = ?');
      params.push(templateData.type);
    }
    
    if (templateData.config !== undefined) {
      if (!templateData.config) {
        throw new Error('Template config cannot be empty');
      }
      updates.push('config = ?');
      const configStr = typeof templateData.config === 'object' 
        ? JSON.stringify(templateData.config) 
        : templateData.config;
      params.push(configStr);
    }
    
    if (templateData.category !== undefined) {
      updates.push('category = ?');
      params.push(templateData.category);
    }
    
    if (templateData.is_default !== undefined) {
      updates.push('is_default = ?');
      params.push(templateData.is_default ? 1 : 0);
    }
    
    // If nothing to update, return existing template
    if (updates.length === 0) {
      return existing;
    }
    
    // Add ID to params
    params.push(id);
    
    // Execute update
    const result = await appDbService.run(`
      UPDATE insight_templates
      SET ${updates.join(', ')}
      WHERE id = ?
    `, params);
    
    if (result.changes === 0) {
      return null;
    }
    
    // Return updated template
    return await findById(id);
  } catch (error) {
    console.error(`Failed to update template ${id}:`, error);
    throw error;
  }
}

/**
 * Remove a template
 * @param {number|string} id - Template ID
 * @returns {Promise<boolean>} True if template was removed, false if not found
 * @throws {Error} If database operation fails
 */
async function remove(id) {
  try {
    // Validate ID
    if (!id) {
      throw new Error('Template ID is required');
    }
    
    const result = await appDbService.run('DELETE FROM insight_templates WHERE id = ?', [id]);
    
    return result.changes > 0;
  } catch (error) {
    console.error(`Failed to remove template ${id}:`, error);
    throw error;
  }
}

module.exports = {
  create,
  findById,
  findAll,
  update,
  remove
};
</file>

<file path="server/routes/connections.js">
/**
 * Connections Route Handler
 * 
 * Handles all API endpoints related to database connections
 */

const express = require('express');
const router = express.Router();
const connectionService = require('../services/connectionService');
const { validateBody, validateParams, schemas } = require('../middleware/dataValidator');

/**
 * GET /api/connections
 * List all saved connections
 */
router.get('/', async (req, res, next) => {
  try {
    const connections = await connectionService.getAllConnections();
    res.json({
      success: true,
      data: connections
    });
  } catch (error) {
    next(error);
  }
});

/**
 * POST /api/connections
 * Create a new connection
 */
router.post('/', 
  validateBody(schemas.connection.create),
  async (req, res, next) => {
    try {
      const newConnection = await connectionService.createConnection(req.body);
      res.status(201).json({
        success: true,
        message: 'Connection created successfully',
        data: newConnection
      });
    } catch (error) {
      next(error);
    }
  }
);

/**
 * GET /api/connections/:id
 * Get connection details
 */
router.get('/:id', 
  validateParams(schemas.connection.id),
  async (req, res, next) => {
    try {
      const connection = await connectionService.getConnectionById(req.params.id);
      if (!connection) {
        return res.status(404).json({ 
          success: false,
          message: 'Connection not found' 
        });
      }
      res.json({
        success: true,
        data: connection
      });
    } catch (error) {
      next(error);
    }
  }
);

/**
 * DELETE /api/connections/:id
 * Remove a connection
 */
router.delete('/:id', 
  validateParams(schemas.connection.id),
  async (req, res, next) => {
    try {
      const result = await connectionService.deleteConnection(req.params.id);
      if (!result) {
        return res.status(404).json({
          success: false,
          message: 'Connection not found'
        });
      }
      res.status(200).json({
        success: true,
        message: 'Connection deleted successfully'
      });
    } catch (error) {
      next(error);
    }
  }
);

/**
 * GET /api/connections/:id/health
 * Check database health/size
 */
router.get('/:id/health', 
  validateParams(schemas.connection.id),
  async (req, res, next) => {
    try {
      const health = await connectionService.checkDatabaseHealth(req.params.id);
      if (!health) {
        return res.status(404).json({
          success: false,
          message: 'Connection not found'
        });
      }
      res.json({
        success: true,
        data: health
      });
    } catch (error) {
      next(error);
    }
  }
);

module.exports = router;
</file>

<file path="server/services/exportService.js">
/**
 * Export Service
 * 
 * Handles data export functionality for various formats (CSV, JSON, etc.)
 */

const visualizationService = require('./visualizationService');
const databaseService = require('./databaseService');
const path = require('path');
const { parseColumnType } = require('../utils/dbUtils');
const connectionService = require('./connectionService');

/**
 * Export visualization as CSV
 * @param {string} visualizationId - Visualization ID
 * @returns {Promise<Object>} Object containing CSV data and filename
 * @throws {Error} If export fails
 */
async function exportVisualizationAsCsv(visualizationId) {
  try {
    // Get visualization details
    const visualization = await visualizationService.getVisualizationById(visualizationId);
    
    if (!visualization) {
      throw new Error(`Visualization with ID ${visualizationId} not found`);
    }
    
    // Get the raw data for the visualization
    const { connectionId, tableName, config } = visualization;
    
    if (!connectionId || !tableName || !config) {
      throw new Error('Visualization lacks required data (connectionId, tableName, or config)');
    }
    
    // Determine what data to fetch based on the visualization type and config
    let rawData = [];
    let headers = [];
    
    // Generate the visualization data to get raw data
    const vizData = await visualizationService.generateVisualizationData(
      connectionId, 
      tableName, 
      config
    );
    
    if (!vizData || !vizData.data || !Array.isArray(vizData.data)) {
      throw new Error('Failed to get visualization data');
    }
    
    rawData = vizData.data;
    
    // Get headers from the first data row if available
    if (rawData.length > 0) {
      headers = Object.keys(rawData[0]);
    }
    
    // Convert raw data to CSV
    const csvData = convertToCsv(rawData, headers);
    
    // Generate a filename
    const sanitizedName = visualization.name.replace(/[^a-z0-9]/gi, '_').toLowerCase();
    const timestamp = new Date().toISOString().replace(/:/g, '-').slice(0, 19);
    const filename = `${sanitizedName}_${timestamp}.csv`;
    
    return {
      data: csvData,
      filename,
      mimeType: 'text/csv',
      extension: 'csv',
      rowCount: rawData.length
    };
  } catch (error) {
    console.error(`Error exporting visualization ${visualizationId} as CSV:`, error);
    throw new Error(`Failed to export visualization as CSV: ${error.message}`);
  }
}

/**
 * Export visualization as JSON
 * @param {string} visualizationId - Visualization ID
 * @returns {Promise<Object>} Object containing JSON data and filename
 * @throws {Error} If export fails
 */
async function exportVisualizationAsJson(visualizationId) {
  try {
    // Get visualization details
    const visualization = await visualizationService.getVisualizationById(visualizationId);
    
    if (!visualization) {
      throw new Error(`Visualization with ID ${visualizationId} not found`);
    }
    
    // Get the raw data for the visualization
    const { connectionId, tableName, config } = visualization;
    
    if (!connectionId || !tableName || !config) {
      throw new Error('Visualization lacks required data (connectionId, tableName, or config)');
    }
    
    // Generate the visualization data to get raw data
    const vizData = await visualizationService.generateVisualizationData(
      connectionId, 
      tableName, 
      config
    );
    
    if (!vizData || !vizData.data || !Array.isArray(vizData.data)) {
      throw new Error('Failed to get visualization data');
    }
    
    // Create an export object that includes metadata and data
    const exportData = {
      metadata: {
        name: visualization.name,
        type: visualization.type,
        exportedAt: new Date().toISOString(),
        rowCount: vizData.data.length
      },
      config: visualization.config,
      data: vizData.data
    };
    
    // Convert to JSON string
    const jsonData = JSON.stringify(exportData, null, 2);
    
    // Generate a filename
    const sanitizedName = visualization.name.replace(/[^a-z0-9]/gi, '_').toLowerCase();
    const timestamp = new Date().toISOString().replace(/:/g, '-').slice(0, 19);
    const filename = `${sanitizedName}_${timestamp}.json`;
    
    return {
      data: jsonData,
      filename,
      mimeType: 'application/json',
      extension: 'json',
      rowCount: vizData.data.length
    };
  } catch (error) {
    console.error(`Error exporting visualization ${visualizationId} as JSON:`, error);
    throw new Error(`Failed to export visualization as JSON: ${error.message}`);
  }
}

/**
 * Export table as CSV
 * @param {string} connectionId - Connection ID
 * @param {string} tableName - Table name
 * @param {Object} options - Export options
 * @param {number} [options.limit=10000] - Maximum number of rows to export
 * @param {Object} [options.filter] - Filter conditions
 * @param {Object} [options.sort] - Sort configuration
 * @returns {Promise<Object>} Object containing CSV data and filename
 * @throws {Error} If export fails
 */
async function exportTableAsCsv(connectionId, tableName, options = {}) {
  try {
    if (!connectionId) {
      throw new Error('Connection ID is required');
    }
    
    if (!tableName) {
      throw new Error('Table name is required');
    }
    
    // Set defaults and limits for export options
    const exportOptions = {
      page: 1,
      limit: Math.min(options.limit || 10000, 100000), // Cap at 100,000 rows for performance
      filter: options.filter || {},
      sort: options.sort || {}
    };
    
    // Get table schema to determine column types
    let tableSchema;
    try {
      tableSchema = await databaseService.getTableSchema(connectionId, tableName);
    } catch (err) {
      console.warn(`Could not get schema for table ${tableName}:`, err);
      // Continue without schema (types will be inferred from data)
    }
    
    // Fetch table data
    const result = await databaseService.getTableData(connectionId, tableName, exportOptions);
    
    if (!result || !result.data || !Array.isArray(result.data)) {
      throw new Error('Failed to retrieve table data');
    }
    
    // Format data for export (handling dates, etc.)
    const formattedData = formatDataForExport(result.data, tableSchema);
    
    // Generate CSV from the data
    const headers = formattedData.length > 0 ? Object.keys(formattedData[0]) : [];
    const csvData = convertToCsv(formattedData, headers);
    
    // Generate filename
    const sanitizedTableName = tableName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
    const timestamp = new Date().toISOString().replace(/:/g, '-').slice(0, 19);
    const filename = `${sanitizedTableName}_export_${timestamp}.csv`;
    
    return {
      data: csvData,
      filename,
      mimeType: 'text/csv',
      extension: 'csv',
      rowCount: result.data.length,
      totalRows: result.total
    };
  } catch (error) {
    console.error(`Error exporting table ${tableName} as CSV:`, error);
    throw new Error(`Failed to export table as CSV: ${error.message}`);
  }
}

/**
 * Export table as JSON
 * @param {string} connectionId - Connection ID
 * @param {string} tableName - Table name
 * @param {Object} options - Export options
 * @param {number} [options.limit=10000] - Maximum number of rows to export
 * @param {Object} [options.filter] - Filter conditions
 * @param {Object} [options.sort] - Sort configuration
 * @param {boolean} [options.includeSchema=true] - Whether to include table schema in export
 * @returns {Promise<Object>} Object containing JSON data and filename
 * @throws {Error} If export fails
 */
async function exportTableAsJson(connectionId, tableName, options = {}) {
  try {
    if (!connectionId) {
      throw new Error('Connection ID is required');
    }
    
    if (!tableName) {
      throw new Error('Table name is required');
    }
    
    // Set defaults and limits for export options
    const exportOptions = {
      page: 1,
      limit: Math.min(options.limit || 10000, 100000), // Cap at 100,000 rows for performance
      filter: options.filter || {},
      sort: options.sort || {},
      includeSchema: options.includeSchema !== false // Default to true
    };
    
    // Get connection details
    const connection = await connectionService.getConnectionById(connectionId);
    
    if (!connection) {
      throw new Error(`Connection with ID ${connectionId} not found`);
    }
    
    // Get table schema if requested
    let schema = null;
    if (exportOptions.includeSchema) {
      try {
        schema = await databaseService.getTableSchema(connectionId, tableName);
      } catch (err) {
        console.warn(`Could not get schema for table ${tableName}:`, err);
        // Continue without schema
      }
    }
    
    // Fetch table data
    const result = await databaseService.getTableData(connectionId, tableName, exportOptions);
    
    if (!result || !result.data || !Array.isArray(result.data)) {
      throw new Error('Failed to retrieve table data');
    }
    
    // Format data for export (handling dates, etc.)
    const formattedData = formatDataForExport(result.data, schema);
    
    // Create export object
    const exportData = {
      metadata: {
        table: tableName,
        database: path.basename(connection.path),
        exportedAt: new Date().toISOString(),
        rowCount: result.data.length,
        totalRows: result.total,
        exportOptions: {
          filter: exportOptions.filter,
          sort: exportOptions.sort,
          limit: exportOptions.limit
        }
      },
      schema: schema ? schema.columns : null,
      data: formattedData
    };
    
    // Convert to JSON string
    const jsonData = JSON.stringify(exportData, null, 2);
    
    // Generate filename
    const sanitizedTableName = tableName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
    const timestamp = new Date().toISOString().replace(/:/g, '-').slice(0, 19);
    const filename = `${sanitizedTableName}_export_${timestamp}.json`;
    
    return {
      data: jsonData,
      filename,
      mimeType: 'application/json',
      extension: 'json',
      rowCount: result.data.length,
      totalRows: result.total
    };
  } catch (error) {
    console.error(`Error exporting table ${tableName} as JSON:`, error);
    throw new Error(`Failed to export table as JSON: ${error.message}`);
  }
}

/**
 * Format data for export (handle special data types)
 * @param {Array} data - Raw data to format
 * @param {Object} schema - Table schema (optional)
 * @returns {Array} Formatted data
 */
function formatDataForExport(data, schema) {
  if (!data || !Array.isArray(data) || data.length === 0) {
    return [];
  }
  
  // If no schema provided, use data as is
  if (!schema || !schema.columns) {
    return data;
  }
  
  // Create a map of column types
  const columnTypes = {};
  schema.columns.forEach(column => {
    columnTypes[column.name] = column;
  });
  
  // Format each row based on column types
  return data.map(row => {
    const formattedRow = {};
    
    for (const [key, value] of Object.entries(row)) {
      const columnType = columnTypes[key];
      
      // Handle null values
      if (value === null || value === undefined) {
        formattedRow[key] = '';
        continue;
      }
      
      // Handle known types
      if (columnType) {
        if (columnType.isDate) {
          // Format dates consistently
          if (value instanceof Date) {
            formattedRow[key] = value.toISOString();
          } else if (typeof value === 'string' && /^\d{4}-\d{2}-\d{2}/.test(value)) {
            // Already in ISO format
            formattedRow[key] = value;
          } else {
            // Try to parse as date
            try {
              const date = new Date(value);
              if (!isNaN(date.getTime())) {
                formattedRow[key] = date.toISOString();
              } else {
                formattedRow[key] = value;
              }
            } catch (e) {
              formattedRow[key] = value;
            }
          }
        } else if (columnType.isNumeric) {
          // Ensure numbers are formatted correctly
          formattedRow[key] = typeof value === 'number' ? value : parseFloat(value);
        } else {
          // Default handling
          formattedRow[key] = value;
        }
      } else {
        // No type information, use as is
        formattedRow[key] = value;
      }
    }
    
    return formattedRow;
  });
}

/**
 * Convert data to CSV format
 * @param {Array} data - Array of data objects
 * @param {Array} headers - Column headers
 * @returns {string} CSV formatted string
 */
function convertToCsv(data, headers) {
  if (!Array.isArray(data) || data.length === 0) {
    // If data is empty, return just headers if available
    if (Array.isArray(headers) && headers.length > 0) {
      return headers.map(escapeCSVValue).join(',') + '\r\n';
    }
    return '';
  }
  
  // If headers weren't provided, extract them from the first data row
  if (!headers || !Array.isArray(headers) || headers.length === 0) {
    headers = Object.keys(data[0]);
  }
  
  // Build CSV string
  let csv = '';
  
  // Add header row
  csv += headers.map(escapeCSVValue).join(',') + '\r\n';
  
  // Add data rows - use a stream-like approach for large datasets
  let rowCounter = 0;
  const batchSize = 1000; // Process 1000 rows at a time to avoid memory issues
  
  while (rowCounter < data.length) {
    const batch = data.slice(rowCounter, rowCounter + batchSize);
    rowCounter += batchSize;
    
    for (const row of batch) {
      const rowValues = headers.map(header => {
        const value = row[header];
        return escapeCSVValue(value);
      });
      
      csv += rowValues.join(',') + '\r\n';
    }
  }
  
  return csv;
}

/**
 * Escape a value for inclusion in CSV
 * @param {any} value - Value to escape
 * @returns {string} Escaped CSV value
 */
function escapeCSVValue(value) {
  if (value === null || value === undefined) {
    return '';
  }
  
  // Format dates consistently
  if (value instanceof Date) {
    return `"${value.toISOString()}"`;
  }
  
  // Convert to string
  const stringValue = String(value);
  
  // If the value contains commas, double quotes, or newlines, wrap it in double quotes
  if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n') || stringValue.includes('\r')) {
    // Double quote any existing double quotes
    return '"' + stringValue.replace(/"/g, '""') + '"';
  }
  
  return stringValue;
}

/**
 * Get supported export formats
 * @returns {Array} List of supported export formats
 */
function getSupportedExportFormats() {
  return [
    { id: 'csv', name: 'CSV (Comma Separated Values)', mimeType: 'text/csv', extension: 'csv' },
    { id: 'json', name: 'JSON (JavaScript Object Notation)', mimeType: 'application/json', extension: 'json' }
  ];
}

module.exports = {
  exportVisualizationAsCsv,
  exportVisualizationAsJson,
  exportTableAsCsv,
  exportTableAsJson,
  convertToCsv,
  getSupportedExportFormats
};
</file>

<file path="README.md">
# SQLite Visualizer

A clean, user-friendly web application that visualizes SQLite database content in both tabular and chart formats, allowing for simple data exploration and insight generation without requiring SQL knowledge.

## Features

- Connect to SQLite databases via localhost
- View database content in clean, responsive table format
- Generate visualizations (bar charts, pie charts, line graphs)
- Use pre-configured visualization templates for common business insights
- Save and export visualizations

## Technology Stack

### Frontend
- React with TypeScript
- Tailwind CSS for styling
- shadcn UI components
- Chart.js for visualizations

### Backend
- Node.js
- Express.js
- better-sqlite3 for database interaction

## Setup Instructions

### Prerequisites
- Node.js (v16 or higher)
- npm (v7 or higher)

### Installation
1. Clone the repository
```bash
git clone <repository-url>
cd sqlite-visualizer
```

2. Install dependencies
```bash
npm install
cd client && npm install
cd ..
```

3. Initialize the database
```bash
npm run setup-db
```

4. Start the application in development mode
```bash
npm run dev
```
This will start both the backend server and the frontend development server.

### Accessing the Application
- Frontend: http://localhost:3001 (or another port if 3001 is in use)
- Backend API: http://localhost:8765

## Development

### Project Structure
- `/server` - Backend Node.js/Express application
- `/client` - Frontend React application
- `/data` - Database files (app.sqlite and user databases)
- `/scripts` - Utility scripts for setup and maintenance

### Available Scripts
- `npm run dev` - Start both backend and frontend in development mode
- `npm run dev:server` - Start only the backend server
- `npm run dev:client` - Start only the frontend development server
- `npm run build` - Build the frontend for production
- `npm run setup-db` - Initialize the application database

### Adding a Sample Database
1. Place your SQLite database file in the `/data` directory
2. Start the application and use the "Add New Connection" form to connect to your database

## Troubleshooting

### Port Conflicts
If you encounter `EADDRINUSE` errors:
1. Check if the ports 8765 (backend) or 3001 (frontend) are already in use
2. Kill the processes using these ports
```bash
lsof -i :8765
kill -9 <PID>
```

### Database Connection Issues
- Ensure the database path is correct and accessible
- Check if the file is a valid SQLite database
- Make sure the database is not locked by another process

### Frontend/Backend Connection Issues
If the frontend can't connect to the backend:
1. Make sure both services are running
2. Check that the proxy in `client/vite.config.ts` is pointing to the correct backend URL
3. Check for CORS issues in the browser console

## Deployment

### Local Network Deployment
1. Build the frontend for production:
```bash
npm run build
```

2. Start the production server:
```bash
npm start
```

3. Access the application from other computers on the network:
```
http://<your-computer-ip>:8765
```

### Mac-Specific Configuration
For Mac deployment, you may need to:
1. Configure firewall settings to allow incoming connections
2. Set up Bonjour/mDNS for easier local network discovery
3. Consider using `pm2` for process management
</file>

<file path="client/src/components/table/TableSelector.tsx">
import { FC } from 'react';
import { TableInfo } from '../../types';

interface TableSelectorProps {
  tables: TableInfo[];
  selectedTable: string | null;
  onSelectTable: (tableName: string) => void;
  loading?: boolean;
}

/**
 * Table Selector Component
 * 
 * Displays a list of tables in a database and allows selection
 */
const TableSelector: FC<TableSelectorProps> = ({ 
  tables = [], 
  selectedTable, 
  onSelectTable, 
  loading = false
}) => {
  if (loading) {
    return (
      <div className="bg-white p-6 rounded-md border border-slate-200 text-center">
        <p className="text-slate-500">Loading tables...</p>
      </div>
    );
  }
  
  if (tables.length === 0) {
    return (
      <div className="bg-white p-6 rounded-md border border-slate-200 text-center">
        <p className="text-slate-500">No tables found in this database.</p>
      </div>
    );
  }
  
  return (
    <div className="bg-white rounded-md border border-slate-200">
      <div className="p-4 border-b border-slate-200">
        <h2 className="text-lg font-medium text-slate-900">Database Tables</h2>
      </div>
      
      <div className="p-2">
        <input
          type="text"
          placeholder="Search tables..."
          className="w-full px-3 py-2 border border-slate-300 rounded-sm text-sm placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-primary focus:border-primary mb-2"
        />
      </div>
      
      <ul className="max-h-[500px] overflow-y-auto">
        {tables.map((table) => (
          <li key={table.name}>
            <button
              className={`w-full text-left px-4 py-2 text-sm ${
                selectedTable === table.name 
                  ? 'bg-primary-light text-primary font-medium' 
                  : 'text-slate-700 hover:bg-slate-50'
              }`}
              onClick={() => onSelectTable(table.name)}
            >
              {table.name}
              {table.rowCount !== undefined && (
                <span className="text-xs text-slate-400 ml-2">
                  ({table.rowCount.toLocaleString()} rows)
                </span>
              )}
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
};

export default TableSelector;
</file>

<file path="client/src/components/templates/TemplateConfigurator.tsx">
import { FC, useState, useEffect } from 'react';
import { useNavigate, useParams, useSearchParams } from 'react-router-dom';
import { Template, Connection, TableInfo, ColumnInfo, ChartData } from '../../types';
import { templateApi, connectionApi, tableApi } from '../../services/api';
import { TemplateFieldMapper } from './index';
import TemplatePreview from './TemplatePreview';

interface TemplateConfiguratorProps {
  onBack?: () => void;
}

/**
 * TemplateConfigurator Component
 * 
 * Allows users to configure templates for visualization
 */
const TemplateConfigurator: FC<TemplateConfiguratorProps> = ({ onBack }) => {
  const navigate = useNavigate();
  const { templateId } = useParams();
  const [searchParams] = useSearchParams();
  const connectionId = searchParams.get('connection');
  
  // State for template configuration
  const [template, setTemplate] = useState<Template | null>(null);
  const [connection, setConnection] = useState<Connection | null>(null);
  const [tables, setTables] = useState<TableInfo[]>([]);
  const [selectedTable, setSelectedTable] = useState<string>('');
  const [columns, setColumns] = useState<ColumnInfo[]>([]);
  const [mappings, setMappings] = useState<Record<string, string>>({});
  const [previewData, setPreviewData] = useState<ChartData | null>(null);
  
  // UI state
  const [loading, setLoading] = useState<boolean>(true);
  const [previewLoading, setPreviewLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [requiredFields, setRequiredFields] = useState<{name: string, label: string}[]>([]);
  const [optionalFields, setOptionalFields] = useState<{name: string, label: string}[]>([]);
  
  // Load template and connection data
  useEffect(() => {
    const fetchData = async () => {
      if (!templateId || !connectionId) {
        setError('Missing template ID or connection ID');
        setLoading(false);
        return;
      }
      
      try {
        setLoading(true);
        
        // Fetch template details
        const templateData = await templateApi.getById(templateId);
        setTemplate(templateData);
        
        // Determine required fields based on chart type
        const fieldsConfig = getFieldsForChartType(templateData.type);
        setRequiredFields(fieldsConfig.required);
        setOptionalFields(fieldsConfig.optional);
        
        // Initialize mappings from template config defaults
        const initialMappings: Record<string, string> = {};
        fieldsConfig.required.forEach(field => {
          initialMappings[field.name] = templateData.config.mappings?.[field.name] || '';
        });
        fieldsConfig.optional.forEach(field => {
          initialMappings[field.name] = templateData.config.mappings?.[field.name] || '';
        });
        setMappings(initialMappings);
        
        // Fetch connection details
        const connectionData = await connectionApi.getById(connectionId);
        setConnection(connectionData);
        
        // Fetch tables for this connection
        const tablesData = await tableApi.getAll(connectionId);
        setTables(tablesData.map(t => ({ name: t.name })));
        
        // Set default table if there is one in the template
        if (templateData.config.tableName && tablesData.some(t => t.name === templateData.config.tableName)) {
          setSelectedTable(templateData.config.tableName);
        } else if (tablesData.length > 0) {
          setSelectedTable(tablesData[0].name);
        }
        
        setLoading(false);
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Failed to load template data';
        setError(errorMessage);
        setLoading(false);
      }
    };
    
    fetchData();
  }, [templateId, connectionId]);
  
  // When selected table changes, fetch table schema for column mapping
  useEffect(() => {
    const fetchTableSchema = async () => {
      if (!connectionId || !selectedTable) return;
      
      try {
        setError(null);
        
        // Show a loading message while fetching schema
        setColumns([]);
        
        const schema = await tableApi.getSchema(connectionId, selectedTable);
        if (!schema || !schema.columns || schema.columns.length === 0) {
          setError(`No columns found in table "${selectedTable}"`);
          return;
        }
        
        // Process and categorize columns
        const processedColumns = schema.columns.map(col => ({
          name: col.name,
          type: col.type,
          isNumeric: isNumericType(col.type),
          isText: isTextType(col.type),
          isDate: isDateType(col.type)
        }));
        
        setColumns(processedColumns);
        
        // Provide some automatic suggestions for mappings based on column types and template
        if (template) {
          const newMappings = { ...mappings };
          
          // For bar/line charts
          if (template.type.toLowerCase() === 'bar' || template.type.toLowerCase() === 'line') {
            // Find a text/date column for x-axis
            if (!newMappings.x) {
              const textColumn = processedColumns.find(col => col.isText || col.isDate);
              if (textColumn) {
                newMappings.x = textColumn.name;
              }
            }
            
            // Find a numeric column for y-axis
            if (!newMappings.y) {
              const numericColumn = processedColumns.find(col => col.isNumeric);
              if (numericColumn) {
                newMappings.y = numericColumn.name;
              }
            }
          } 
          // For pie/doughnut charts
          else if (template.type.toLowerCase() === 'pie' || template.type.toLowerCase() === 'doughnut') {
            // Find a text column for labels
            if (!newMappings.labels) {
              const textColumn = processedColumns.find(col => col.isText);
              if (textColumn) {
                newMappings.labels = textColumn.name;
              }
            }
            
            // Find a numeric column for values
            if (!newMappings.values) {
              const numericColumn = processedColumns.find(col => col.isNumeric);
              if (numericColumn) {
                newMappings.values = numericColumn.name;
              }
            }
          }
          
          // Update mappings if we made any changes
          if (JSON.stringify(newMappings) !== JSON.stringify(mappings)) {
            setMappings(newMappings);
          }
        }
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Failed to load table schema';
        setError(errorMessage);
      }
    };
    
    fetchTableSchema();
  }, [connectionId, selectedTable, template, mappings]);
  
  // Generate preview data when mappings or selected table changes
  useEffect(() => {
    const generatePreview = async () => {
      if (!template || !connectionId || !selectedTable) return;
      
      // Check if all required fields are mapped
      const requiredMappingsMissing = requiredFields.some(field => !mappings[field.name]);
      if (requiredMappingsMissing) {
        return;
      }
      
      try {
        setPreviewLoading(true);
        
        // Apply template with current mappings
        const result = await templateApi.apply(template.id, {
          connectionId: Number(connectionId),
          tableNames: [selectedTable],
          mappings
        });
        
        setPreviewData(result.data as ChartData);
        setError(null);
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate preview';
        setError(errorMessage);
      } finally {
        setPreviewLoading(false);
      }
    };
    
    // Debounce preview generation
    const timer = setTimeout(() => {
      generatePreview();
    }, 800);
    
    return () => clearTimeout(timer);
  }, [mappings, connectionId, selectedTable, template, requiredFields]);
  
  // Handle field mapping changes
  const handleMappingChange = (fieldName: string, columnName: string) => {
    setMappings(prev => ({
      ...prev,
      [fieldName]: columnName
    }));
  };
  
  // Handle table selection change
  const handleTableChange = (tableName: string) => {
    setSelectedTable(tableName);
    
    // Reset mappings when table changes
    const resetMappings: Record<string, string> = {};
    Object.keys(mappings).forEach(key => {
      resetMappings[key] = '';
    });
    setMappings(resetMappings);
  };
  
  // Apply template and save visualization
  const handleApplyTemplate = async () => {
    if (!template || !connectionId || !selectedTable) {
      setError('Missing required configuration');
      return;
    }
    
    // Validate that all required fields are mapped
    const requiredMappingsMissing = requiredFields.some(field => !mappings[field.name]);
    if (requiredMappingsMissing) {
      setError('Please map all required fields');
      return;
    }
    
    // Show specific validation messages for each required field
    for (const field of requiredFields) {
      if (!mappings[field.name]) {
        setError(`Please select a value for "${field.label}"`);
        return;
      }
    }
    
    try {
      setLoading(true);
      
      // Apply template to get visualization data
      const result = await templateApi.apply(template.id, {
        connectionId: Number(connectionId),
        tableNames: [selectedTable],
        mappings
      });
      
      // Check if the result has valid data
      if (!result.data || 
          !result.data.labels || 
          !result.data.datasets || 
          result.data.labels.length === 0 || 
          result.data.datasets.length === 0) {
        setError('The template did not generate any visualization data. Please try different field mappings or another table.');
        setLoading(false);
        return;
      }
      
      // Redirect to visualization builder with the data
      navigate(`/visualize?template=${template.id}&connection=${connectionId}&table=${selectedTable}`, {
        state: {
          templateResult: result,
          mappings,
          sourceName: template.name
        }
      });
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to apply template';
      setError(errorMessage);
      setLoading(false);
    }
  };
  
  // Helper to check if a column type is numeric
  const isNumericType = (type: string): boolean => {
    return /int|float|double|decimal|number|real/i.test(type);
  };
  
  // Helper to check if a column type is text
  const isTextType = (type: string): boolean => {
    return /text|char|string|var/i.test(type);
  };
  
  // Helper to check if a column type is a date
  const isDateType = (type: string): boolean => {
    return /date|time/i.test(type);
  };
  
  // Get required and optional fields based on chart type
  const getFieldsForChartType = (chartType: string): { 
    required: {name: string, label: string}[], 
    optional: {name: string, label: string}[] 
  } => {
    const type = chartType.toLowerCase();
    switch (type) {
      case 'bar':
      case 'line':
        return {
          required: [
            { name: 'x', label: 'X-Axis (Categories)' },
            { name: 'y', label: 'Y-Axis (Values)' }
          ],
          optional: [
            { name: 'groupBy', label: 'Group By' },
            { name: 'sort', label: 'Sort Direction' },
            { name: 'limit', label: 'Limit Results' }
          ]
        };
      case 'pie':
      case 'doughnut':
        return {
          required: [
            { name: 'labels', label: 'Labels (Categories)' },
            { name: 'values', label: 'Values (Sizes)' }
          ],
          optional: [
            { name: 'limit', label: 'Limit Results' }
          ]
        };
      default:
        return { required: [], optional: [] };
    }
  };
  
  // Render loading state
  if (loading) {
    return (
      <div className="p-6 bg-white rounded-md border border-slate-200">
        <p className="text-center text-slate-500">Loading template configuration...</p>
      </div>
    );
  }
  
  // Render error state
  if (error) {
    return (
      <div className="p-6 bg-white rounded-md border border-slate-200">
        <div className="p-4 bg-red-50 border border-red-200 rounded-md text-red-700">
          {error}
        </div>
        <div className="mt-4 flex justify-center">
          <button 
            className="px-4 py-2 bg-slate-100 text-slate-700 border border-slate-300 rounded font-medium text-sm hover:bg-slate-200"
            onClick={() => navigate('/templates')}
          >
            Back to Templates
          </button>
        </div>
      </div>
    );
  }
  
  // Render if no template found
  if (!template || !connection) {
    return (
      <div className="p-6 bg-white rounded-md border border-slate-200">
        <p className="text-center text-slate-500">Template or connection not found</p>
        <div className="mt-4 flex justify-center">
          <button 
            className="px-4 py-2 bg-slate-100 text-slate-700 border border-slate-300 rounded font-medium text-sm hover:bg-slate-200"
            onClick={() => navigate('/templates')}
          >
            Back to Templates
          </button>
        </div>
      </div>
    );
  }
  
  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-semibold text-slate-900">Configure "{template.name}" Template</h1>
        <button 
          className="px-4 py-2 bg-slate-100 text-slate-700 border border-slate-300 rounded font-medium text-sm hover:bg-slate-200"
          onClick={() => onBack ? onBack() : navigate('/templates')}
        >
          Back
        </button>
      </div>
      
      {/* Template Info */}
      <div className="bg-white p-6 rounded-md border border-slate-200">
        <div className="flex items-center mb-4">
          <span className="inline-block px-2 py-1 bg-blue-50 text-blue-700 rounded mr-2">
            {template.type} Chart
          </span>
          {template.category && (
            <span className="inline-block px-2 py-1 bg-green-50 text-green-700 rounded">
              {template.category}
            </span>
          )}
        </div>
        
        <p className="text-sm text-slate-500 mb-4">{template.description}</p>
        
        <h3 className="text-lg font-medium text-slate-900 mb-2">Database Connection</h3>
        <p className="text-sm text-slate-700">{connection.name}</p>
      </div>
      
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* Configuration Panel */}
        <div className="bg-white p-6 rounded-md border border-slate-200">
          <h2 className="text-lg font-medium text-slate-900 mb-4">Configure Data Source</h2>
          
          {/* Table Selection */}
          <div className="mb-6">
            <label className="block text-sm font-medium text-slate-700 mb-1">Select Table</label>
            <select 
              className="w-full px-3 py-2 border border-slate-300 rounded-sm text-sm"
              value={selectedTable}
              onChange={(e) => handleTableChange(e.target.value)}
              disabled={tables.length === 0}
            >
              {tables.length === 0 && (
                <option value="">No tables available</option>
              )}
              {tables.map((table) => (
                <option key={table.name} value={table.name}>
                  {table.name}
                </option>
              ))}
            </select>
          </div>
          
          {/* Field Mappings */}
          <div className="space-y-4">
            <h3 className="text-md font-medium text-slate-800">Required Field Mappings</h3>
            
            {requiredFields.map((field) => (
              <TemplateFieldMapper
                key={field.name}
                field={{...field, required: true}}
                columns={columns}
                value={mappings[field.name] || ''}
                onChange={handleMappingChange}
                disabled={columns.length === 0}
                className="mb-4"
              />
            ))}
            
            {optionalFields.length > 0 && (
              <>
                <h3 className="text-md font-medium text-slate-800 mt-6">Optional Field Mappings</h3>
                
                {optionalFields.map((field) => {
                  // For special fields like sort and limit, create custom components
                  if (field.name === 'sort') {
                    return (
                      <div key={field.name} className="mb-4">
                        <label className="block text-sm font-medium text-slate-700 mb-1">
                          {field.label}
                        </label>
                        <select 
                          className="w-full px-3 py-2 border border-slate-300 rounded-sm text-sm"
                          value={mappings[field.name] || ''}
                          onChange={(e) => handleMappingChange(field.name, e.target.value)}
                        >
                          <option value="">No sorting</option>
                          <option value="asc">Ascending</option>
                          <option value="desc">Descending</option>
                        </select>
                      </div>
                    );
                  } else if (field.name === 'limit') {
                    return (
                      <div key={field.name} className="mb-4">
                        <label className="block text-sm font-medium text-slate-700 mb-1">
                          {field.label}
                        </label>
                        <select 
                          className="w-full px-3 py-2 border border-slate-300 rounded-sm text-sm"
                          value={mappings[field.name] || ''}
                          onChange={(e) => handleMappingChange(field.name, e.target.value)}
                        >
                          <option value="">Default (10)</option>
                          <option value="5">5 results</option>
                          <option value="10">10 results</option>
                          <option value="20">20 results</option>
                          <option value="50">50 results</option>
                          <option value="100">100 results</option>
                        </select>
                      </div>
                    );
                  } else {
                    return (
                      <TemplateFieldMapper
                        key={field.name}
                        field={field}
                        columns={columns}
                        value={mappings[field.name] || ''}
                        onChange={handleMappingChange}
                        disabled={columns.length === 0}
                        className="mb-4"
                      />
                    );
                  }
                })}
              </>
            )}
          </div>
          
          {/* Apply Button */}
          <div className="mt-6">
            <button 
              className="w-full px-4 py-2 bg-blue-600 text-white rounded font-medium text-sm hover:bg-blue-700 disabled:opacity-50 disabled:pointer-events-none"
              onClick={handleApplyTemplate}
              disabled={
                !selectedTable || 
                requiredFields.some(field => !mappings[field.name]) ||
                loading
              }
            >
              Apply Template
            </button>
          </div>
        </div>
        
        {/* Preview Panel */}
        <div className="bg-white p-6 rounded-md border border-slate-200">
          <h2 className="text-lg font-medium text-slate-900 mb-4">Preview</h2>
          
          {template && (
            <TemplatePreview
              template={template}
              previewData={previewData}
              isLoading={previewLoading}
              error={
                columns.length === 0 ? null :
                requiredFields.some(field => !mappings[field.name]) ? 
                'Map all required fields to see a preview' : 
                error
              }
            />
          )}
        </div>
      </div>
    </div>
  );
};

export default TemplateConfigurator;
</file>

<file path="client/src/components/templates/TemplateList.tsx">
import { FC } from 'react';
import { Template } from '../../types';
import TemplateCard from './TemplateCard';

interface TemplateListProps {
  templates: Template[];
  selectedConnectionId: string | null;
  onApplyTemplate: (templateId: string | number) => void;
  isLoading?: boolean;
}

/**
 * TemplateList Component
 * 
 * Displays a grid of available templates
 */
const TemplateList: FC<TemplateListProps> = ({
  templates,
  selectedConnectionId,
  onApplyTemplate,
  isLoading = false
}) => {
  // Group templates by category
  const groupedTemplates = templates.reduce<Record<string, Template[]>>((groups, template) => {
    const category = template.category || 'Other';
    if (!groups[category]) {
      groups[category] = [];
    }
    groups[category].push(template);
    return groups;
  }, {});
  
  // Sort categories for consistent display
  const sortedCategories = Object.keys(groupedTemplates).sort((a, b) => {
    // Always put "Other" at the end
    if (a === 'Other') return 1;
    if (b === 'Other') return -1;
    return a.localeCompare(b);
  });
  
  if (isLoading) {
    return (
      <div className="py-10 text-center">
        <p className="text-slate-500">Loading templates...</p>
      </div>
    );
  }
  
  if (templates.length === 0) {
    return (
      <div className="py-10 text-center">
        <p className="text-slate-500">No templates available</p>
      </div>
    );
  }
  
  return (
    <div className="space-y-10">
      {sortedCategories.map(category => (
        <div key={category}>
          <h2 className="text-xl font-medium text-slate-900 mb-4 capitalize">{category}</h2>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {groupedTemplates[category].map(template => (
              <TemplateCard 
                key={template.id}
                template={template}
                connectionId={selectedConnectionId}
                onApply={onApplyTemplate}
              />
            ))}
          </div>
        </div>
      ))}
    </div>
  );
};

export default TemplateList;
</file>

<file path="client/src/components/visualization/ChartTypeSelector.tsx">
import { FC } from 'react';

type ChartType = 'bar' | 'line' | 'pie' | 'doughnut' | 'scatter';

interface ChartTypeSelectorProps {
  selected: ChartType;
  onChange: (type: ChartType) => void;
}

/**
 * Chart Type Selector Component
 * 
 * Allows users to select the type of chart for their visualization
 */
const ChartTypeSelector: FC<ChartTypeSelectorProps> = ({ selected, onChange }) => {
  const chartTypes = [
    { id: 'bar' as ChartType, label: 'Bar Chart', description: 'Compare values across categories' },
    { id: 'line' as ChartType, label: 'Line Chart', description: 'Show trends over time or categories' },
    { id: 'pie' as ChartType, label: 'Pie Chart', description: 'Show composition as parts of a whole' },
    { id: 'doughnut' as ChartType, label: 'Doughnut Chart', description: 'Similar to pie chart with center hole' },
    { id: 'scatter' as ChartType, label: 'Scatter Plot', description: 'Show relationship between two variables' }
  ];
  
  return (
    <div className="space-y-2">
      {chartTypes.map((chartType) => (
        <div
          key={chartType.id}
          className={`p-3 border rounded cursor-pointer transition-colors ${
            selected === chartType.id
              ? 'border-primary bg-primary-light'
              : 'border-slate-200 hover:bg-slate-50'
          }`}
          onClick={() => onChange(chartType.id)}
        >
          <div className="flex items-center">
            <div
              className={`w-4 h-4 rounded-full border flex items-center justify-center mr-3 ${
                selected === chartType.id
                  ? 'border-primary'
                  : 'border-slate-400'
              }`}
            >
              {selected === chartType.id && (
                <div className="w-2 h-2 rounded-full bg-primary" />
              )}
            </div>
            <div>
              <h3 className={`text-sm font-medium ${
                selected === chartType.id ? 'text-primary' : 'text-slate-900'
              }`}>
                {chartType.label}
              </h3>
              <p className="text-xs text-slate-500">{chartType.description}</p>
            </div>
          </div>
        </div>
      ))}
    </div>
  );
};

export default ChartTypeSelector;
</file>

<file path="client/src/components/visualization/FieldMapper.tsx">
import { FC, useState, useEffect } from 'react';
import { TableSchema, FieldMapping, ColumnInfo } from '../../types';
import { ChevronDown, ChevronUp, HelpCircle } from 'lucide-react';

interface FieldMapperProps {
  schema: TableSchema | null;
  chartType: string;
  mappings: FieldMapping;
  onChange: (mappings: FieldMapping) => void;
}

// Type for aggregation functions
type AggregationFunction = 'none' | 'sum' | 'avg' | 'min' | 'max' | 'count';

// Type for field mapping configurations
interface MappingConfig {
  id: string;
  label: string;
  description: string;
  required: boolean;
  preferredTypes: string[]; // Types that are ideal for this mapping (e.g., 'number', 'text', 'date')
  supportsAggregation: boolean;
}

/**
 * Field Mapper Component
 * 
 * An enhanced component for mapping table fields to chart elements with intelligent
 * recommendations, data type validation, and aggregation options.
 */
const FieldMapper: FC<FieldMapperProps> = ({ schema, chartType, mappings, onChange }) => {
  const [advancedMode, setAdvancedMode] = useState<boolean>(false);
  const [aggregations, setAggregations] = useState<Record<string, AggregationFunction>>({});
  const [tooltips, setTooltips] = useState<Record<string, boolean>>({});
  
  // Reset aggregations when chart type changes
  useEffect(() => {
    setAggregations({});
  }, [chartType]);
  
  if (!schema) {
    return <p className="text-slate-500">No schema available</p>;
  }
  
  // Define mapping configurations by chart type
  const mappingConfigsByType: Record<string, MappingConfig[]> = {
    bar: [
      {
        id: 'x',
        label: 'X-Axis (Categories)',
        description: 'Categories to display on the horizontal axis. Usually text or dates.',
        required: true,
        preferredTypes: ['text', 'date', 'timestamp'],
        supportsAggregation: false
      },
      {
        id: 'y',
        label: 'Y-Axis (Values)',
        description: 'Numeric values to display on the vertical axis.',
        required: true,
        preferredTypes: ['number', 'integer', 'float', 'double', 'decimal'],
        supportsAggregation: true
      },
      {
        id: 'color',
        label: 'Color (Optional)',
        description: 'Field to use for color differentiation between bars.',
        required: false,
        preferredTypes: ['text', 'category'],
        supportsAggregation: false
      }
    ],
    line: [
      {
        id: 'x',
        label: 'X-Axis (Timeline)',
        description: 'Time or sequence field for the horizontal axis. Dates work best.',
        required: true,
        preferredTypes: ['date', 'timestamp', 'time', 'text', 'number'],
        supportsAggregation: false
      },
      {
        id: 'y',
        label: 'Y-Axis (Values)',
        description: 'Numeric values to track over time on the vertical axis.',
        required: true,
        preferredTypes: ['number', 'integer', 'float', 'double', 'decimal'],
        supportsAggregation: true
      },
      {
        id: 'color',
        label: 'Series (Optional)',
        description: 'Field to split data into multiple lines.',
        required: false,
        preferredTypes: ['text', 'category'],
        supportsAggregation: false
      }
    ],
    pie: [
      {
        id: 'labels',
        label: 'Segments',
        description: 'Categories to display as pie segments.',
        required: true,
        preferredTypes: ['text', 'category'],
        supportsAggregation: false
      },
      {
        id: 'values',
        label: 'Values',
        description: 'Numeric values determining segment size.',
        required: true,
        preferredTypes: ['number', 'integer', 'float', 'double', 'decimal'],
        supportsAggregation: true
      }
    ],
    doughnut: [
      {
        id: 'labels',
        label: 'Segments',
        description: 'Categories to display as doughnut segments.',
        required: true,
        preferredTypes: ['text', 'category'],
        supportsAggregation: false
      },
      {
        id: 'values',
        label: 'Values',
        description: 'Numeric values determining segment size.',
        required: true,
        preferredTypes: ['number', 'integer', 'float', 'double', 'decimal'],
        supportsAggregation: true
      }
    ],
    scatter: [
      {
        id: 'x',
        label: 'X-Axis (Horizontal)',
        description: 'Values for the horizontal axis, typically numeric.',
        required: true,
        preferredTypes: ['number', 'integer', 'float', 'double', 'decimal'],
        supportsAggregation: false
      },
      {
        id: 'y',
        label: 'Y-Axis (Vertical)',
        description: 'Values for the vertical axis, typically numeric.',
        required: true,
        preferredTypes: ['number', 'integer', 'float', 'double', 'decimal'],
        supportsAggregation: false
      },
      {
        id: 'size',
        label: 'Point Size (Optional)',
        description: 'Numeric field to determine the size of points.',
        required: false,
        preferredTypes: ['number', 'integer', 'float', 'double', 'decimal'],
        supportsAggregation: true
      },
      {
        id: 'color',
        label: 'Color (Optional)',
        description: 'Field to use for color grouping of points.',
        required: false,
        preferredTypes: ['text', 'category', 'number'],
        supportsAggregation: false
      }
    ]
  };
  
  // Fallback to bar chart configs if chart type not found
  const activeConfigs = mappingConfigsByType[chartType] || mappingConfigsByType.bar;
  
  // Helper to check if a column is numeric
  const isNumeric = (column: ColumnInfo): boolean => {
    if (column.isNumeric) return true;
    const numericTypes = ['int', 'float', 'double', 'decimal', 'number', 'real', 'numeric'];
    return numericTypes.some(type => column.type.toLowerCase().includes(type));
  };
  
  // Helper to check if a column is date/time
  const isDateTime = (column: ColumnInfo): boolean => {
    if (column.isDate) return true;
    const dateTypes = ['date', 'time', 'timestamp', 'datetime'];
    return dateTypes.some(type => column.type.toLowerCase().includes(type));
  };
  
  // Helper to check if a column is text/category
  const isText = (column: ColumnInfo): boolean => {
    if (column.isText) return true;
    const textTypes = ['text', 'char', 'varchar', 'string', 'nvarchar'];
    return textTypes.some(type => column.type.toLowerCase().includes(type));
  };
  
  // Get recommended columns for a specific mapping
  const getRecommendedColumns = (mappingConfig: MappingConfig): ColumnInfo[] => {
    return schema.columns.filter(column => {
      // Check if column type matches any preferred type
      return mappingConfig.preferredTypes.some(type => {
        if (type === 'number' && isNumeric(column)) return true;
        if ((type === 'date' || type === 'timestamp' || type === 'time') && isDateTime(column)) return true;
        if ((type === 'text' || type === 'category') && isText(column)) return true;
        return column.type.toLowerCase().includes(type.toLowerCase());
      });
    });
  };
  
  // Handle field mapping change
  const handleMappingChange = (mappingType: string, field: string) => {
    // If field is cleared, also clear the aggregation
    if (!field && aggregations[mappingType]) {
      const newAggregations = { ...aggregations };
      delete newAggregations[mappingType];
      setAggregations(newAggregations);
    }
    
    const newMappings = {
      ...mappings,
      [mappingType]: field
    };
    
    onChange(newMappings);
  };
  
  // Handle aggregation change
  const handleAggregationChange = (mappingType: string, aggregation: AggregationFunction) => {
    const newAggregations = {
      ...aggregations,
      [mappingType]: aggregation
    };
    
    // If 'none' is selected, remove the aggregation
    if (aggregation === 'none') {
      delete newAggregations[mappingType];
    }
    
    setAggregations(newAggregations);
    
    // Update the mappings to include aggregation information
    // Format: fieldName|aggregation (e.g., "sales|sum")
    const currentField = mappings[mappingType] || '';
    const fieldName = currentField.includes('|') ? currentField.split('|')[0] : currentField;
    
    if (!fieldName) return; // Skip if no field selected
    
    const newFieldValue = aggregation === 'none' ? fieldName : `${fieldName}|${aggregation}`;
    handleMappingChange(mappingType, newFieldValue);
  };
  
  // Toggle tooltip visibility
  const toggleTooltip = (mappingType: string) => {
    setTooltips(prev => ({
      ...prev,
      [mappingType]: !prev[mappingType]
    }));
  };
  
  return (
    <div className="space-y-4">
      {/* Toggle for advanced mode */}
      <div className="flex justify-end">
        <button
          type="button"
          className="text-sm text-primary flex items-center"
          onClick={() => setAdvancedMode(!advancedMode)}
        >
          {advancedMode ? (
            <>
              <ChevronUp className="w-4 h-4 mr-1" />
              Simple Mode
            </>
          ) : (
            <>
              <ChevronDown className="w-4 h-4 mr-1" />
              Advanced Mode
            </>
          )}
        </button>
      </div>
      
      {/* Field Mapping UI */}
      {activeConfigs.map((config) => {
        // Skip optional mappings in simple mode
        if (!advancedMode && !config.required) return null;
        
        // Get recommended columns
        const recommendedColumns = getRecommendedColumns(config);
        const otherColumns = schema.columns.filter(col => 
          !recommendedColumns.some(rec => rec.name === col.name)
        );
        
        // Parse current mapping value to check for aggregation
        const currentValue = mappings[config.id] || '';
        const [fieldName, fieldAggregation] = currentValue.includes('|') 
          ? currentValue.split('|') 
          : [currentValue, 'none'];
        
        // Get current column if selected
        const selectedColumn = schema.columns.find(col => col.name === fieldName);
        
        return (
          <div key={config.id} className="space-y-1 p-3 border border-slate-200 rounded-md">
            <div className="flex items-center justify-between">
              <div className="flex items-center">
                <label className="block text-sm font-medium text-slate-700">
                  {config.label}
                  {config.required && <span className="text-red-500 ml-1">*</span>}
                </label>
                <button
                  type="button"
                  className="ml-2 text-slate-400 hover:text-slate-600"
                  onClick={() => toggleTooltip(config.id)}
                >
                  <HelpCircle className="w-4 h-4" />
                </button>
              </div>
            </div>
            
            {/* Tooltip */}
            {tooltips[config.id] && (
              <div className="bg-slate-100 p-2 rounded-md text-xs text-slate-600 mb-2">
                {config.description}
                {config.preferredTypes.length > 0 && (
                  <div className="mt-1">
                    <span className="font-medium">Recommended data types: </span>
                    {config.preferredTypes.join(', ')}
                  </div>
                )}
              </div>
            )}
            
            {/* Field Selector */}
            <div className="grid grid-cols-1 md:grid-cols-3 gap-2">
              <div className="md:col-span-2">
                <select
                  className="w-full px-3 py-2 border border-slate-300 rounded-sm text-sm"
                  value={fieldName}
                  onChange={(e) => handleMappingChange(config.id, e.target.value)}
                >
                  <option value="">Select a field</option>
                  
                  {/* Show recommended columns first */}
                  {recommendedColumns.length > 0 && (
                    <optgroup label="Recommended Fields">
                      {recommendedColumns.map((column) => (
                        <option key={`rec-${column.name}`} value={column.name}>
                          {column.name} ({column.type})
                        </option>
                      ))}
                    </optgroup>
                  )}
                  
                  {/* Show other columns */}
                  {otherColumns.length > 0 && (
                    <optgroup label="Other Fields">
                      {otherColumns.map((column) => (
                        <option key={`other-${column.name}`} value={column.name}>
                          {column.name} ({column.type})
                        </option>
                      ))}
                    </optgroup>
                  )}
                </select>
              </div>
              
              {/* Aggregation selector (only for numeric fields that support aggregation) */}
              {config.supportsAggregation && selectedColumn && isNumeric(selectedColumn) && (
                <div>
                  <select
                    className="w-full px-3 py-2 border border-slate-300 rounded-sm text-sm"
                    value={fieldAggregation}
                    onChange={(e) => handleAggregationChange(config.id, e.target.value as AggregationFunction)}
                  >
                    <option value="none">No Aggregation</option>
                    <option value="sum">Sum</option>
                    <option value="avg">Average</option>
                    <option value="min">Minimum</option>
                    <option value="max">Maximum</option>
                    <option value="count">Count</option>
                  </select>
                </div>
              )}
            </div>
            
            {/* Field preview indicator - show if a field is selected */}
            {fieldName && (
              <div className="text-xs text-slate-500 mt-1">
                {selectedColumn && isNumeric(selectedColumn) && (
                  <span className="inline-block px-2 py-1 bg-blue-100 text-blue-800 rounded">
                    Numeric
                  </span>
                )}
                
                {selectedColumn && isDateTime(selectedColumn) && (
                  <span className="inline-block px-2 py-1 bg-purple-100 text-purple-800 rounded ml-1">
                    Date/Time
                  </span>
                )}
                
                {selectedColumn && isText(selectedColumn) && (
                  <span className="inline-block px-2 py-1 bg-green-100 text-green-800 rounded ml-1">
                    Text
                  </span>
                )}
                
                {fieldAggregation && fieldAggregation !== 'none' && (
                  <span className="inline-block px-2 py-1 bg-amber-100 text-amber-800 rounded ml-1">
                    {fieldAggregation.toUpperCase()}
                  </span>
                )}
              </div>
            )}
          </div>
        );
      })}
      
      {/* Helper text for required fields */}
      <div className="text-xs text-slate-500 flex items-center">
        <span className="text-red-500 mr-1">*</span> Required fields
      </div>
    </div>
  );
};

export default FieldMapper;
</file>

<file path="client/src/pages/TableViewer.tsx">
import { FC, useState, useEffect, useCallback } from 'react';
import { useParams, useNavigate, useLocation, useSearchParams } from 'react-router-dom';
import TableSelector from '../components/table/TableSelector';
import DataTable from '../components/table/DataTable';
import { TableInfo, TableSchema, Connection } from '../types';
import { tableApi, connectionApi, exportApi } from '../services/api';
import { ArrowLeft, Database, FileSpreadsheet, Download, Search, Loader2 } from 'lucide-react';

/**
 * Table Viewer Page
 * 
 * Displays database tables and their data with filtering, sorting and pagination
 * Supports URL-based state for sharing specific views
 */
const TableViewer: FC = () => {
  const { id: connectionId } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const [searchParams, setSearchParams] = useSearchParams();
  
  // Connection information
  const [connection, setConnection] = useState<Connection | null>(null);
  const [connectionError, setConnectionError] = useState<string | null>(null);

  // Table data
  const [tables, setTables] = useState<TableInfo[]>([]);
  const [loadingTables, setLoadingTables] = useState<boolean>(true);
  const [tableSchema, setTableSchema] = useState<TableSchema | null>(null);
  
  // Table data pagination and filtering
  const [tableData, setTableData] = useState<{ data: any[], total: number }>({ data: [], total: 0 });
  const [loadingData, setLoadingData] = useState<boolean>(false);
  const [tableError, setTableError] = useState<string | null>(null);
  
  // Search functionality
  const [searchQuery, setSearchQuery] = useState<string>('');
  const [filteredTables, setFilteredTables] = useState<TableInfo[]>([]);
  
  // Get parameters from URL search params to enable shareable links
  const selectedTable = searchParams.get('table') || null;
  const page = parseInt(searchParams.get('page') || '1', 10);
  const limit = parseInt(searchParams.get('limit') || '100', 10);
  const sortColumn = searchParams.get('sort') || '';
  const sortDirection = searchParams.get('direction') as 'asc' | 'desc' || 'asc';
  
  // Parse filters from URL
  const getFiltersFromParams = (): Record<string, string> => {
    const filtersParam = searchParams.get('filters');
    if (!filtersParam) return {};
    
    try {
      return JSON.parse(decodeURIComponent(filtersParam));
    } catch (e) {
      console.error('Failed to parse filters from URL', e);
      return {};
    }
  };
  
  const filters = getFiltersFromParams();
  
  // Update URL search params when state changes
  const updateSearchParams = useCallback((updates: Record<string, string | null>) => {
    const newParams = new URLSearchParams(searchParams);
    
    // Apply updates
    Object.entries(updates).forEach(([key, value]) => {
      if (value === null) {
        newParams.delete(key);
      } else {
        newParams.set(key, value);
      }
    });
    
    // Update URL without causing navigation
    setSearchParams(newParams, { replace: true });
  }, [searchParams, setSearchParams]);

  // Fetch connection info
  useEffect(() => {
    const fetchConnection = async () => {
      if (!connectionId) return;
      
      try {
        const connectionData = await connectionApi.getById(connectionId);
        setConnection(connectionData);
        setConnectionError(null);
        
        // Update document title with connection name
        document.title = `${connectionData.name} - SQLite Visualizer`;
      } catch (err) {
        console.error('Failed to fetch connection:', err);
        setConnectionError(err instanceof Error ? err.message : 'Failed to load connection');
        setConnection(null);
      }
    };
    
    fetchConnection();
    
    // Cleanup
    return () => {
      document.title = 'SQLite Visualizer';
    };
  }, [connectionId]);

  // Fetch tables from the selected connection
  useEffect(() => {
    const fetchTables = async () => {
      if (!connectionId) return;
      
      try {
        setLoadingTables(true);
        const data = await tableApi.getAll(connectionId);
        setTables(data);
        setFilteredTables(data);
      } catch (err) {
        console.error('Failed to fetch tables:', err);
        setTableError(err instanceof Error ? err.message : 'Failed to load tables');
      } finally {
        setLoadingTables(false);
      }
    };
    
    fetchTables();
  }, [connectionId]);
  
  // Filter tables based on search query
  useEffect(() => {
    if (!searchQuery.trim()) {
      setFilteredTables(tables);
      return;
    }
    
    const filtered = tables.filter(table => 
      table.name.toLowerCase().includes(searchQuery.toLowerCase())
    );
    setFilteredTables(filtered);
  }, [tables, searchQuery]);
  
  // Fetch table schema when table changes
  useEffect(() => {
    const fetchTableSchema = async () => {
      if (!connectionId || !selectedTable) {
        setTableSchema(null);
        return;
      }
      
      try {
        const schema = await tableApi.getSchema(connectionId, selectedTable);
        setTableSchema(schema);
      } catch (err) {
        console.error('Failed to fetch table schema:', err);
      }
    };
    
    fetchTableSchema();
  }, [connectionId, selectedTable]);

  // Fetch table data with pagination, sorting, and filtering
  useEffect(() => {
    const fetchTableData = async () => {
      if (!connectionId || !selectedTable) return;
      
      try {
        setLoadingData(true);
        setTableError(null);
        
        const params: Record<string, any> = {
          page,
          limit,
        };
        
        if (sortColumn) {
          params.sort = sortColumn;
          params.direction = sortDirection;
        }
        
        if (Object.keys(filters).length > 0) {
          params.filter = JSON.stringify(filters);
        }
        
        const data = await tableApi.getData(connectionId, selectedTable, params);
        setTableData(data);
      } catch (err) {
        console.error('Failed to fetch table data:', err);
        setTableError(err instanceof Error ? err.message : 'Failed to load table data');
        setTableData({ data: [], total: 0 });
      } finally {
        setLoadingData(false);
      }
    };
    
    fetchTableData();
  }, [connectionId, selectedTable, page, limit, sortColumn, sortDirection, filters]);
  
  // Handle table selection
  const handleTableSelect = (tableName: string) => {
    // Reset filters and sort when changing tables
    updateSearchParams({
      table: tableName,
      page: '1',
      sort: null,
      direction: null,
      filters: null
    });
  };
  
  // Handle page change
  const handlePageChange = (newPage: number) => {
    updateSearchParams({ page: newPage.toString() });
  };
  
  // Handle limit change
  const handleLimitChange = (newLimit: number) => {
    updateSearchParams({ 
      limit: newLimit.toString(),
      page: '1' // Reset to first page
    });
  };
  
  // Handle sort change
  const handleSortChange = (column: string, direction: 'asc' | 'desc') => {
    updateSearchParams({ 
      sort: column,
      direction: direction
    });
  };
  
  // Handle filter change
  const handleFilterChange = (newFilters: Record<string, string>) => {
    // Only keep non-empty filters
    const cleanedFilters = Object.fromEntries(
      Object.entries(newFilters).filter(([_, value]) => value.trim() !== '')
    );
    
    // Convert filters to JSON and encode for URL
    const filtersString = Object.keys(cleanedFilters).length > 0
      ? encodeURIComponent(JSON.stringify(cleanedFilters))
      : null;
    
    updateSearchParams({ 
      filters: filtersString,
      page: '1' // Reset to first page when filters change
    });
  };
  
  // Handle export to CSV
  const handleExportCsv = () => {
    if (!connectionId || !selectedTable) return;
    
    const exportUrl = exportApi.exportTable(connectionId, selectedTable);
    window.open(exportUrl, '_blank');
  };
  
  // Handle table search
  const handleTableSearch = (e: React.ChangeEvent<HTMLInputElement>) => {
    setSearchQuery(e.target.value);
  };
  
  // Error display
  if (connectionError) {
    return (
      <div className="p-6 bg-red-50 border border-red-200 rounded-md text-center">
        <h2 className="text-xl font-semibold text-red-700 mb-2">Connection Error</h2>
        <p className="text-red-600 mb-4">{connectionError}</p>
        <button
          className="px-4 py-2 bg-slate-100 text-slate-700 rounded hover:bg-slate-200"
          onClick={() => navigate('/')}
        >
          <ArrowLeft className="inline-block mr-1 h-4 w-4" />
          Back to Connections
        </button>
      </div>
    );
  }
  
  return (
    <div className="space-y-6">
      {/* Header with connection info and navigation */}
      <div className="flex flex-col sm:flex-row sm:justify-between sm:items-center gap-4 pb-4 border-b border-slate-200">
        <div className="flex items-center">
          <button
            className="mr-4 p-2 rounded-full bg-slate-100 text-slate-700 hover:bg-slate-200"
            onClick={() => navigate('/')}
            aria-label="Back to connections"
          >
            <ArrowLeft className="h-5 w-5" />
          </button>
          
          <div>
            <h1 className="text-2xl font-semibold text-slate-900 flex items-center">
              <Database className="h-5 w-5 mr-2 text-primary" />
              {connection?.name || 'Database'}
            </h1>
            {connection && (
              <div className="text-sm text-slate-500 mt-1">
                <span className="font-medium">{tables.length}</span> tables | 
                {connection.size_bytes ? (
                  <span className="ml-1">{Math.round(connection.size_bytes / 1024)} KB</span>
                ) : (
                  <span className="ml-1">Unknown size</span>
                )}
              </div>
            )}
          </div>
        </div>
        
        {selectedTable && (
          <div className="flex items-center space-x-2">
            <button
              className="px-4 py-2 bg-white border border-slate-300 rounded-sm text-sm text-slate-700 hover:bg-slate-50 flex items-center"
              onClick={handleExportCsv}
              disabled={loadingData}
            >
              <Download className="h-4 w-4 mr-1" />
              Export CSV
            </button>
          </div>
        )}
      </div>
      
      {/* Main content */}
      <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
        {/* Table Selector with search */}
        <div className="lg:col-span-1">
          <div className="bg-white rounded-md border border-slate-200 overflow-hidden">
            <div className="p-4 border-b border-slate-200">
              <h2 className="text-lg font-medium text-slate-900 flex items-center">
                <FileSpreadsheet className="h-5 w-5 mr-2 text-primary" />
                Database Tables
              </h2>
              
              <div className="mt-3 relative">
                <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                  <Search className="h-4 w-4 text-slate-400" />
                </div>
                <input
                  type="text"
                  placeholder="Search tables..."
                  className="w-full pl-10 pr-3 py-2 border border-slate-300 rounded-sm text-sm placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-primary focus:border-primary"
                  value={searchQuery}
                  onChange={handleTableSearch}
                />
              </div>
            </div>
            
            {loadingTables ? (
              <div className="p-6 text-center">
                <Loader2 className="h-5 w-5 text-primary animate-spin mx-auto mb-2" />
                <p className="text-slate-500">Loading tables...</p>
              </div>
            ) : (
              <TableSelector 
                tables={filteredTables}
                selectedTable={selectedTable}
                onSelectTable={handleTableSelect}
                loading={false}
              />
            )}
          </div>
        </div>
        
        {/* Data Table */}
        <div className="lg:col-span-3">
          {tableError && (
            <div className="p-4 bg-red-50 border border-red-200 rounded-md mb-4">
              <p className="text-red-600">{tableError}</p>
            </div>
          )}
          
          {selectedTable ? (
            <>
              {tableSchema && (
                <div className="mb-4 p-4 bg-slate-50 border border-slate-200 rounded-md">
                  <h3 className="text-sm font-medium text-slate-700 mb-2">Table Schema: <span className="font-semibold text-primary">{selectedTable}</span></h3>
                  <div className="overflow-x-auto">
                    <table className="min-w-full text-xs">
                      <thead>
                        <tr className="border-b border-slate-200">
                          <th className="px-2 py-1 text-left text-slate-600">Column</th>
                          <th className="px-2 py-1 text-left text-slate-600">Type</th>
                          <th className="px-2 py-1 text-left text-slate-600">Nullable</th>
                        </tr>
                      </thead>
                      <tbody>
                        {tableSchema.columns.map((column, idx) => (
                          <tr key={idx} className="border-b border-slate-100">
                            <td className="px-2 py-1 font-medium text-slate-700">{column.name}</td>
                            <td className="px-2 py-1 text-slate-600">{column.type}</td>
                            <td className="px-2 py-1">
                              {column.nullable ? 
                                <span className="text-green-600">Yes</span> : 
                                <span className="text-red-600">No</span>
                              }
                            </td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                </div>
              )}
              
              <DataTable 
                data={tableData.data}
                total={tableData.total}
                page={page}
                limit={limit}
                onPageChange={handlePageChange}
                onSortChange={handleSortChange}
                onFilterChange={handleFilterChange}
                loading={loadingData}
                filters={filters}
                highlightPattern={searchQuery}
              />
            </>
          ) : (
            <div className="bg-white p-8 rounded-md border border-slate-200 text-center">
              <FileSpreadsheet className="h-12 w-12 text-slate-300 mx-auto mb-4" />
              <p className="text-slate-700 font-medium mb-2">Select a table to view its data</p>
              <p className="text-slate-500 text-sm">Choose a table from the list on the left to explore its contents</p>
              
              {filteredTables.length === 0 && tables.length > 0 && (
                <div className="mt-4 p-3 bg-amber-50 border border-amber-200 rounded-md inline-block">
                  <p className="text-amber-700 text-sm">No tables match your search criteria</p>
                </div>
              )}
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default TableViewer;
</file>

<file path="client/src/App.tsx">
import { FC } from 'react';
import { Routes, Route } from 'react-router-dom';
import MainLayout from './layouts/MainLayout';
import Connections from './pages/Connections';
import TableViewer from './pages/TableViewer';
import VisualizationBuilder from './pages/VisualizationBuilder';
import SavedVisualizations from './pages/SavedVisualizations';
import Templates from './pages/Templates';
import TemplateApplication from './pages/TemplateApplication';
import NotFound from './pages/NotFound';

const App: FC = () => {
  return (
    <Routes>
      <Route path="/" element={<MainLayout />}>
        <Route index element={<Connections />} />
        <Route path="connections/:id/tables" element={<TableViewer />} />
        <Route path="visualize" element={<VisualizationBuilder />} />
        <Route path="gallery" element={<SavedVisualizations />} />
        <Route path="templates" element={<Templates />} />
        <Route path="templates/:templateId/apply" element={<TemplateApplication />} />
        <Route path="*" element={<NotFound />} />
      </Route>
    </Routes>
  );
};

export default App;
</file>

<file path="client/package.json">
{
  "name": "sqlite-visualizer-client",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "lint": "eslint src --ext ts,tsx",
    "lint:fix": "eslint src --ext ts,tsx --fix"
  },
  "dependencies": {
    "@heroicons/react": "^2.2.0",
    "chart.js": "^4.3.0",
    "date-fns": "^4.1.0",
    "lucide-react": "^0.487.0",
    "react": "^18.2.0",
    "react-chartjs-2": "^5.2.0",
    "react-dom": "^18.2.0",
    "react-hot-toast": "^2.5.2",
    "react-router-dom": "^6.14.1"
  },
  "devDependencies": {
    "@types/node": "^20.4.1",
    "@types/react": "^18.2.14",
    "@types/react-dom": "^18.2.6",
    "@vitejs/plugin-react": "^4.0.2",
    "autoprefixer": "^10.4.14",
    "eslint": "^8.44.0",
    "eslint-plugin-react": "^7.32.2",
    "eslint-plugin-react-hooks": "^4.6.0",
    "postcss": "^8.4.25",
    "tailwindcss": "^3.3.2",
    "terser": "^5.39.0",
    "typescript": "^5.1.6",
    "vite": "^4.4.2"
  }
}
</file>

<file path="server/models/connection.js">
/**
 * Connection Model
 * 
 * Represents a database connection in the application.
 * This model handles CRUD operations for SQLite database connections
 * that users create and access through the visualizer.
 */

/**
 * Connection schema:
 * {
 *   id: number,             // Unique identifier
 *   name: string,           // User-friendly connection name
 *   path: string,           // Absolute path to the SQLite database file
 *   last_accessed: timestamp, // When the connection was last used
 *   size_bytes: number,     // Size of the database file in bytes
 *   table_count: number,    // Number of tables in the database
 *   is_valid: boolean       // Whether the connection is still valid
 * }
 */

const appDbService = require('../services/appDbService');

/**
 * Create a new connection record
 * @param {Object} connectionData - Connection details
 * @returns {Promise<Object>} Created connection with ID
 * @throws {Error} If required fields are missing or validation fails
 */
async function create(connectionData) {
  // Validate required fields
  if (!connectionData.name) {
    throw new Error('Connection name is required');
  }
  
  if (!connectionData.path) {
    throw new Error('Database path is required');
  }
  
  const db = appDbService.getDb();
  
  try {
    // Check if a connection with the same path already exists
    const existingByPath = await appDbService.get('SELECT id FROM connections WHERE path = ?', [connectionData.path]);
    if (existingByPath) {
      throw new Error(`A connection to '${connectionData.path}' already exists`);
    }
    
    // Prepare timestamp and defaults
    const timestamp = connectionData.last_accessed || new Date().toISOString();
    const size = connectionData.size_bytes || 0;
    const tableCount = connectionData.table_count || 0;
    const isValid = connectionData.is_valid !== undefined ? connectionData.is_valid : true;
    
    // Execute the insertion
    // Convert boolean to integer (0 or 1) for SQLite compatibility
    const info = await appDbService.run(`
      INSERT INTO connections (
        name, 
        path, 
        last_accessed, 
        size_bytes, 
        table_count, 
        is_valid
      ) VALUES (?, ?, ?, ?, ?, ?)
    `, [
      connectionData.name,
      connectionData.path,
      timestamp,
      size,
      tableCount,
      isValid ? 1 : 0
    ]);
    
    // Return the created connection with ID
    return {
      id: info.lastID,
      name: connectionData.name,
      path: connectionData.path,
      last_accessed: timestamp,
      size_bytes: size,
      table_count: tableCount,
      is_valid: isValid
    };
  } catch (error) {
    console.error('Error creating connection record:', error);
    
    // More specific error message for SQLite constraint errors
    if (error.code === 'SQLITE_CONSTRAINT') {
      throw new Error('Connection could not be created due to a constraint violation');
    }
    
    throw new Error('Failed to create connection record: ' + error.message);
  }
}

/**
 * Find a connection by ID
 * @param {number} id - Connection ID
 * @returns {Promise<Object|null>} Connection object or null if not found
 */
async function findById(id) {
  if (!id) {
    return null;
  }
  
  try {
    // Execute the query
    const connection = await appDbService.get('SELECT * FROM connections WHERE id = ?', [id]);
    return connection || null;
  } catch (error) {
    console.error(`Error finding connection with ID ${id}:`, error);
    throw new Error(`Failed to find connection: ${error.message}`);
  }
}

/**
 * Find a connection by path
 * @param {string} path - Path to the database file
 * @returns {Promise<Object|null>} Connection object or null if not found
 */
async function findByPath(path) {
  if (!path) {
    return null;
  }
  
  try {
    // Execute the query
    const connection = await appDbService.get('SELECT * FROM connections WHERE path = ?', [path]);
    return connection || null;
  } catch (error) {
    console.error(`Error finding connection with path ${path}:`, error);
    throw new Error(`Failed to find connection by path: ${error.message}`);
  }
}

/**
 * Update the last accessed timestamp for a connection
 * @param {number} id - Connection ID
 * @returns {Promise<boolean>} True if updated successfully
 */
async function updateLastAccessed(id) {
  if (!id) {
    return false;
  }
  
  try {
    const result = await appDbService.run(
      'UPDATE connections SET last_accessed = ? WHERE id = ?', 
      [new Date().toISOString(), id]
    );
    
    return result.changes > 0;
  } catch (error) {
    console.error(`Error updating last accessed timestamp for connection ${id}:`, error);
    // We don't throw here as this is a non-critical update
    return false;
  }
}

/**
 * Find all connections
 * @param {Object} options - Optional query parameters
 * @param {string} options.sortBy - Field to sort by (default: 'last_accessed')
 * @param {string} options.sortDir - Sort direction: 'asc' or 'desc' (default: 'desc')
 * @param {boolean} options.validOnly - If true, only return valid connections
 * @returns {Promise<Array>} Array of connection objects
 */
async function findAll(options = {}) {
  try {
    // Default options
    const sortBy = options.sortBy || 'last_accessed';
    const sortDir = options.sortDir || 'desc';
    const validOnly = options.validOnly || false;
    
    // Validate sort field to prevent SQL injection
    const allowedSortFields = ['id', 'name', 'path', 'last_accessed', 'size_bytes', 'table_count'];
    const safeSort = allowedSortFields.includes(sortBy) ? sortBy : 'last_accessed';
    
    // Build the query
    let query = 'SELECT * FROM connections';
    const params = [];
    
    if (validOnly) {
      query += ' WHERE is_valid = ?';
      // Convert boolean to integer (0 or 1) for SQLite compatibility
      params.push(1);
    }
    
    query += ` ORDER BY ${safeSort} ${sortDir === 'asc' ? 'ASC' : 'DESC'}`;
    
    // Execute the query
    const connections = await appDbService.all(query, params);
    return connections || [];
  } catch (error) {
    console.error('Error finding connections:', error);
    throw new Error('Failed to retrieve connections');
  }
}

/**
 * Update a connection
 * @param {number} id - Connection ID
 * @param {Object} connectionData - Updated connection details
 * @returns {Promise<Object>} Updated connection
 * @throws {Error} If connection not found or validation fails
 */
async function update(id, connectionData) {
  try {
    // Get current connection
    const currentConnection = await findById(id);
    
    if (!currentConnection) {
      throw new Error(`Connection with ID ${id} not found`);
    }
    
    // Build SET clause and parameters dynamically based on provided data
    const updates = [];
    const params = [];
    
    if (connectionData.name !== undefined) {
      updates.push('name = ?');
      params.push(connectionData.name);
    }
    
    if (connectionData.path !== undefined) {
      updates.push('path = ?');
      params.push(connectionData.path);
    }
    
    if (connectionData.last_accessed !== undefined) {
      updates.push('last_accessed = ?');
      params.push(connectionData.last_accessed);
    }
    
    if (connectionData.size_bytes !== undefined) {
      updates.push('size_bytes = ?');
      params.push(connectionData.size_bytes);
    }
    
    if (connectionData.table_count !== undefined) {
      updates.push('table_count = ?');
      params.push(connectionData.table_count);
    }
    
    if (connectionData.is_valid !== undefined) {
      updates.push('is_valid = ?');
      // Convert boolean to integer (0 or 1) for SQLite compatibility
      params.push(connectionData.is_valid ? 1 : 0);
    }
    
    // If no updates, return the current connection
    if (updates.length === 0) {
      return currentConnection;
    }
    
    // Add ID to params
    params.push(id);
    
    // Execute the update
    await appDbService.run(`
      UPDATE connections 
      SET ${updates.join(', ')}
      WHERE id = ?
    `, params);
    
    // Return updated connection
    return findById(id);
  } catch (error) {
    console.error(`Error updating connection with ID ${id}:`, error);
    throw new Error('Failed to update connection');
  }
}

/**
 * Remove a connection
 * @param {number} id - Connection ID
 * @returns {Promise<boolean>} True if deleted successfully, false if connection not found
 * @throws {Error} If an error occurs during deletion
 */
async function remove(id) {
  if (!id) {
    throw new Error('Connection ID is required for deletion');
  }
  
  try {
    // First check if the connection exists
    const connection = await findById(id);
    if (!connection) {
      return false;
    }
    
    // Perform the deletion
    const result = await appDbService.run('DELETE FROM connections WHERE id = ?', [id]);
    return result.changes > 0;
  } catch (error) {
    console.error(`Error removing connection with ID ${id}:`, error);
    throw new Error(`Failed to remove connection: ${error.message}`);
  }
}

module.exports = {
  create,
  findById,
  findByPath,
  findAll,
  update,
  remove,
  updateLastAccessed
};
</file>

<file path="server/routes/export.js">
/**
 * Export Route Handler
 * 
 * Handles all API endpoints related to exporting data in various formats (CSV, JSON)
 */

const express = require('express');
const router = express.Router();
const exportService = require('../services/exportService');
const { validateParams, validateQuery, schemas } = require('../middleware/dataValidator');
const Joi = require('joi');

// Export validation schemas
const vizExportParamsSchema = Joi.object({
  vizId: Joi.number().integer().positive().required()
    .messages({
      'number.base': 'Visualization ID must be a number',
      'number.integer': 'Visualization ID must be an integer',
      'number.positive': 'Visualization ID must be positive'
    })
});

const tableExportParamsSchema = Joi.object({
  connectionId: Joi.number().integer().positive().required()
    .messages({
      'number.base': 'Connection ID must be a number',
      'number.integer': 'Connection ID must be an integer',
      'number.positive': 'Connection ID must be positive'
    }),
  tableName: Joi.string().pattern(/^[a-zA-Z0-9_]+$/).required()
    .messages({
      'string.pattern.base': 'Table name contains invalid characters'
    })
});

const tableExportQuerySchema = Joi.object({
  limit: Joi.number().integer().min(1).max(100000).default(1000)
    .messages({
      'number.base': 'Limit must be a number',
      'number.integer': 'Limit must be an integer',
      'number.min': 'Limit must be at least 1',
      'number.max': 'Limit cannot exceed 100,000'
    }),
  filter: Joi.string().custom((value, helpers) => {
    try {
      JSON.parse(value);
      return value;
    } catch (error) {
      return helpers.message('Filter must be a valid JSON string');
    }
  }).optional(),
  sort: Joi.string().custom((value, helpers) => {
    try {
      JSON.parse(value);
      return value;
    } catch (error) {
      return helpers.message('Sort must be a valid JSON string');
    }
  }).optional(),
  includeSchema: Joi.boolean().default(true)
    .messages({
      'boolean.base': 'includeSchema must be a boolean'
    })
});

/**
 * GET /api/export/formats
 * Get supported export formats
 */
router.get('/formats', async (req, res, next) => {
  try {
    const formats = exportService.getSupportedExportFormats();
    
    return res.json({
      success: true,
      formats
    });
  } catch (error) {
    next(error);
  }
});

/**
 * GET /api/export/csv/:vizId
 * Export visualization as CSV
 */
router.get('/csv/:vizId', 
  validateParams(vizExportParamsSchema),
  validateQuery(schemas.export.csv),
  async (req, res, next) => {
    try {
      const { vizId } = req.params;
      
      const result = await exportService.exportVisualizationAsCsv(vizId);
      
      if (!result || !result.data) {
        return res.status(404).json({
          success: false,
          error: 'Visualization not found',
          message: `No visualization found with ID: ${vizId}`
        });
      }
      
      const { data, filename, mimeType } = result;
      
      res.setHeader('Content-Type', mimeType || 'text/csv');
      res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
      res.send(data);
    } catch (error) {
      next(error);
    }
  }
);

/**
 * GET /api/export/json/:vizId
 * Export visualization as JSON
 */
router.get('/json/:vizId', 
  validateParams(vizExportParamsSchema),
  async (req, res, next) => {
    try {
      const { vizId } = req.params;
      
      const result = await exportService.exportVisualizationAsJson(vizId);
      
      if (!result || !result.data) {
        return res.status(404).json({
          success: false,
          error: 'Visualization not found',
          message: `No visualization found with ID: ${vizId}`
        });
      }
      
      const { data, filename, mimeType } = result;
      
      res.setHeader('Content-Type', mimeType || 'application/json');
      res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
      res.send(data);
    } catch (error) {
      next(error);
    }
  }
);

/**
 * GET /api/export/csv/table/:connectionId/:tableName
 * Export table as CSV
 */
router.get('/csv/table/:connectionId/:tableName', 
  validateParams(tableExportParamsSchema),
  validateQuery(tableExportQuerySchema),
  async (req, res, next) => {
    try {
      const { connectionId, tableName } = req.params;
      const { limit, filter, sort } = req.query;
      
      // Parse export options
      const options = {
        limit: limit ? parseInt(limit) : 1000
      };
      
      // Safely parse JSON parameters if they exist
      if (filter) {
        try {
          options.filter = JSON.parse(filter);
        } catch (error) {
          return res.status(400).json({
            success: false,
            error: 'Invalid filter parameter',
            message: 'Filter must be a valid JSON object'
          });
        }
      }
      
      if (sort) {
        try {
          options.sort = JSON.parse(sort);
        } catch (error) {
          return res.status(400).json({
            success: false,
            error: 'Invalid sort parameter',
            message: 'Sort must be a valid JSON object'
          });
        }
      }
      
      const result = await exportService.exportTableAsCsv(connectionId, tableName, options);
      
      if (!result || !result.data) {
        return res.status(404).json({
          success: false,
          error: 'Export failed',
          message: 'The requested table or connection could not be found'
        });
      }
      
      const { data, filename, mimeType } = result;
      
      res.setHeader('Content-Type', mimeType || 'text/csv');
      res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
      res.send(data);
    } catch (error) {
      next(error);
    }
  }
);

/**
 * GET /api/export/json/table/:connectionId/:tableName
 * Export table as JSON
 */
router.get('/json/table/:connectionId/:tableName', 
  validateParams(tableExportParamsSchema),
  validateQuery(tableExportQuerySchema),
  async (req, res, next) => {
    try {
      const { connectionId, tableName } = req.params;
      const { limit, filter, sort, includeSchema } = req.query;
      
      // Parse export options
      const options = {
        limit: limit ? parseInt(limit) : 1000,
        includeSchema: includeSchema !== 'false' // Convert to boolean
      };
      
      // Safely parse JSON parameters if they exist
      if (filter) {
        try {
          options.filter = JSON.parse(filter);
        } catch (error) {
          return res.status(400).json({
            success: false,
            error: 'Invalid filter parameter',
            message: 'Filter must be a valid JSON object'
          });
        }
      }
      
      if (sort) {
        try {
          options.sort = JSON.parse(sort);
        } catch (error) {
          return res.status(400).json({
            success: false,
            error: 'Invalid sort parameter',
            message: 'Sort must be a valid JSON object'
          });
        }
      }
      
      const result = await exportService.exportTableAsJson(connectionId, tableName, options);
      
      if (!result || !result.data) {
        return res.status(404).json({
          success: false,
          error: 'Export failed',
          message: 'The requested table or connection could not be found'
        });
      }
      
      const { data, filename, mimeType } = result;
      
      res.setHeader('Content-Type', mimeType || 'application/json');
      res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
      res.send(data);
    } catch (error) {
      next(error);
    }
  }
);

module.exports = router;
</file>

<file path="server/services/templateService.js">
/**
 * Template Service
 * 
 * Handles insight template management and application
 */

const appDbService = require('./appDbService');
const databaseService = require('./databaseService');
const templateModel = require('../models/template');

/**
 * Get all insight templates
 * @param {Object} filters - Optional filters to apply
 * @returns {Promise<Array>} - Array of templates
 */
async function getAllTemplates(filters = {}) {
  try {
    return await templateModel.findAll(filters);
  } catch (error) {
    console.error('Failed to get all templates:', error);
    throw error;
  }
}

/**
 * Get a template by ID
 * @param {string} id - Template ID
 * @returns {Promise<Object|null>} - Template object or null if not found
 */
async function getTemplateById(id) {
  try {
    const template = await templateModel.findById(id);
    return template;
  } catch (error) {
    console.error(`Failed to get template ${id}:`, error);
    throw error;
  }
}

/**
 * Create a new template
 * @param {Object} templateData - Template details
 * @returns {Promise<Object>} - Created template
 */
async function createTemplate(templateData) {
  try {
    return await templateModel.create(templateData);
  } catch (error) {
    console.error('Failed to create template:', error);
    throw error;
  }
}

/**
 * Update an existing template
 * @param {string} id - Template ID
 * @param {Object} templateData - Updated template details
 * @returns {Promise<Object|null>} - Updated template or null if not found
 */
async function updateTemplate(id, templateData) {
  try {
    return await templateModel.update(id, templateData);
  } catch (error) {
    console.error(`Failed to update template ${id}:`, error);
    throw error;
  }
}

/**
 * Delete a template
 * @param {string} id - Template ID
 * @returns {Promise<boolean>} - True if deleted, false if not found
 */
async function deleteTemplate(id) {
  try {
    return await templateModel.remove(id);
  } catch (error) {
    console.error(`Failed to delete template ${id}:`, error);
    throw error;
  }
}

/**
 * Apply a template to data
 * @param {string} templateId - Template ID
 * @param {string} connectionId - Connection ID
 * @param {Array|string} tableNames - Table names to use (can be single string or array)
 * @param {Object} mappings - Field mappings for template
 * @returns {Promise<Object>} - Visualization data and config
 */
async function applyTemplate(templateId, connectionId, tableNames, mappings) {
  try {
    // Get the template
    const template = await getTemplateById(templateId);
    
    if (!template) {
      throw new Error(`Template with ID ${templateId} not found`);
    }
    
    // Normalize tableNames to array
    const tables = Array.isArray(tableNames) ? tableNames : [tableNames];
    
    if (tables.length === 0) {
      throw new Error('At least one table name must be provided');
    }
    
    // Get template config
    const templateConfig = JSON.parse(template.config);
    
    // Merge user mappings with template config
    const mergedConfig = {
      ...templateConfig,
      mappings: {
        ...templateConfig.mappings,
        ...mappings
      }
    };
    
    // Generate data based on template type and config
    let data;
    
    try {
      // Different query logic based on chart type
      switch (template.type.toLowerCase()) {
        case 'bar':
        case 'line':
          // For bar and line charts, we need to fetch data for the x and y axes
          data = await generateChartData(connectionId, tables[0], mergedConfig);
          break;
          
        case 'pie':
        case 'doughnut':
          // For pie/doughnut charts, we need labels and values
          data = await generatePieChartData(connectionId, tables[0], mergedConfig);
          break;
          
        default:
          throw new Error(`Unsupported chart type: ${template.type}`);
      }
    } catch (error) {
      console.error(`Error generating chart data for template ${templateId}:`, error);
      throw new Error(`Failed to generate visualization data: ${error.message}`);
    }
    
    return {
      data,
      config: mergedConfig,
      type: template.type
    };
  } catch (error) {
    console.error(`Failed to apply template ${templateId}:`, error);
    throw error;
  }
}

/**
 * Generate data for bar or line charts
 * @param {string} connectionId - Connection ID
 * @param {string} tableName - Table name
 * @param {Object} config - Chart configuration
 * @returns {Promise<Object>} - Chart data
 */
async function generateChartData(connectionId, tableName, config) {
  try {
    // Get mappings
    const { x, y, sort, limit = 10, groupBy } = config.mappings;
    
    if (!x || !y) {
      throw new Error('X and Y axis mappings are required');
    }
    
    // Validate that the table exists
    const tables = await databaseService.getAllTables(connectionId);
    if (!tables.some(t => t.name === tableName)) {
      throw new Error(`Table "${tableName}" not found in the database`);
    }
    
    // Validate that the columns exist in the table
    const schema = await databaseService.getTableSchema(connectionId, tableName);
    const columnNames = schema.columns.map(c => c.name);
    
    if (!columnNames.includes(x)) {
      throw new Error(`Column "${x}" not found in table "${tableName}"`);
    }
    
    if (!columnNames.includes(y)) {
      throw new Error(`Column "${y}" not found in table "${tableName}"`);
    }
    
    if (groupBy && !columnNames.includes(groupBy)) {
      throw new Error(`Group by column "${groupBy}" not found in table "${tableName}"`);
    }
    
    // Build query options
    const options = {
      columns: [x, y],
      limit: parseInt(limit) || 10
    };
    
    // Add sorting if specified
    if (sort) {
      options.sort = {
        column: y,
        direction: sort.toLowerCase() === 'asc' ? 'ASC' : 'DESC'
      };
    } else {
      // Default sorting for better visualization
      options.sort = {
        column: y,
        direction: 'DESC'
      };
    }
    
    // Add grouping if specified
    if (groupBy) {
      options.groupBy = groupBy;
    } else {
      // If no groupBy is specified but we're visualizing data,
      // we need to group by the x-axis to avoid duplicate entries
      options.groupBy = x;
    }
    
    // Execute query to get data
    const result = await databaseService.getAggregatedData(
      connectionId,
      tableName,
      options
    );
    
    if (!result.data || result.data.length === 0) {
      return {
        labels: [],
        datasets: [{
          label: config.title || y,
          data: [],
          backgroundColor: [],
          borderColor: '#2563EB',
          borderWidth: 1
        }]
      };
    }
    
    // Format data for Chart.js
    const labels = result.data.map(row => row[x]?.toString() || 'Unknown');
    const values = result.data.map(row => parseFloat(row[y]) || 0);
    
    return {
      labels,
      datasets: [{
        label: config.title || y,
        data: values,
        backgroundColor: generateChartColors(values.length),
        borderColor: '#2563EB',
        borderWidth: 1
      }]
    };
  } catch (error) {
    console.error('Failed to generate chart data:', error);
    throw error;
  }
}

/**
 * Generate data for pie or doughnut charts
 * @param {string} connectionId - Connection ID
 * @param {string} tableName - Table name
 * @param {Object} config - Chart configuration
 * @returns {Promise<Object>} - Chart data
 */
async function generatePieChartData(connectionId, tableName, config) {
  try {
    // Get mappings
    const { labels: labelField, values: valueField, limit = 10 } = config.mappings;
    
    if (!labelField || !valueField) {
      throw new Error('Labels and values mappings are required');
    }
    
    // Validate that the table exists
    const tables = await databaseService.getAllTables(connectionId);
    if (!tables.some(t => t.name === tableName)) {
      throw new Error(`Table "${tableName}" not found in the database`);
    }
    
    // Validate that the columns exist in the table
    const schema = await databaseService.getTableSchema(connectionId, tableName);
    const columnNames = schema.columns.map(c => c.name);
    
    if (!columnNames.includes(labelField)) {
      throw new Error(`Label column "${labelField}" not found in table "${tableName}"`);
    }
    
    if (!columnNames.includes(valueField)) {
      throw new Error(`Value column "${valueField}" not found in table "${tableName}"`);
    }
    
    // Build query options
    const options = {
      columns: [labelField, valueField],
      limit: parseInt(limit) || 10,
      sort: {
        column: valueField,
        direction: 'DESC'
      },
      // Group by the label field to avoid duplicate entries
      groupBy: labelField
    };
    
    // Execute query to get data
    const result = await databaseService.getAggregatedData(
      connectionId,
      tableName,
      options
    );
    
    if (!result.data || result.data.length === 0) {
      return {
        labels: [],
        datasets: [{
          data: [],
          backgroundColor: []
        }]
      };
    }
    
    // Format data for Chart.js
    const labels = result.data.map(row => row[labelField]?.toString() || 'Unknown');
    const values = result.data.map(row => parseFloat(row[valueField]) || 0);
    
    // Generate colors for the pie segments
    const colors = generateChartColors(values.length);
    
    return {
      labels,
      datasets: [{
        data: values,
        backgroundColor: colors,
        borderColor: colors.map(() => '#FFFFFF'),
        borderWidth: 1
      }]
    };
  } catch (error) {
    console.error('Failed to generate pie chart data:', error);
    throw error;
  }
}

/**
 * Get template field requirements
 * @param {string} templateId - Template ID
 * @returns {Promise<Object>} - Template field requirements
 */
async function getTemplateRequirements(templateId) {
  try {
    const template = await getTemplateById(templateId);
    
    if (!template) {
      throw new Error(`Template with ID ${templateId} not found`);
    }
    
    // Different requirements based on chart type
    const requiredFields = [];
    const optionalFields = [];
    
    switch (template.type.toLowerCase()) {
      case 'bar':
      case 'line':
        requiredFields.push({ name: 'x', label: 'X-Axis (Categories)' });
        requiredFields.push({ name: 'y', label: 'Y-Axis (Values)' });
        optionalFields.push({ name: 'groupBy', label: 'Group By' });
        optionalFields.push({ name: 'sort', label: 'Sort Direction' });
        optionalFields.push({ name: 'limit', label: 'Result Limit' });
        break;
        
      case 'pie':
      case 'doughnut':
        requiredFields.push({ name: 'labels', label: 'Labels (Categories)' });
        requiredFields.push({ name: 'values', label: 'Values (Sizes)' });
        optionalFields.push({ name: 'limit', label: 'Result Limit' });
        break;
        
      default:
        throw new Error(`Unsupported chart type: ${template.type}`);
    }
    
    return {
      requiredFields,
      optionalFields,
      templateInfo: {
        name: template.name,
        description: template.description,
        type: template.type,
        category: template.category
      }
    };
  } catch (error) {
    console.error(`Failed to get template requirements for ${templateId}:`, error);
    throw error;
  }
}

/**
 * Get all available template categories
 * @returns {Promise<Array>} - Array of unique category names
 */
async function getTemplateCategories() {
  try {
    const templates = await getAllTemplates();
    
    // Extract unique categories
    const categories = [...new Set(templates
      .map(template => template.category)
      .filter(Boolean)
    )];
    
    return categories;
  } catch (error) {
    console.error('Failed to get template categories:', error);
    throw error;
  }
}

/**
 * Generate an array of chart colors
 * @param {number} count - Number of colors needed
 * @returns {Array<string>} - Array of color hex codes
 */
function generateChartColors(count) {
  // Define a set of base colors that match the style guide
  const baseColors = [
    '#2563EB', // blue-600
    '#D946EF', // fuchsia-500
    '#F59E0B', // amber-500
    '#10B981', // emerald-500
    '#6366F1', // indigo-500
    '#EF4444', // red-500
    '#8B5CF6', // violet-500
    '#EC4899', // pink-500
    '#06B6D4', // cyan-500
    '#84CC16'  // lime-500
  ];
  
  // If we need more colors than we have, cycle through them
  const colors = [];
  for (let i = 0; i < count; i++) {
    const baseColor = baseColors[i % baseColors.length];
    colors.push(baseColor);
  }
  
  return colors;
}

module.exports = {
  getAllTemplates,
  getTemplateById,
  createTemplate,
  updateTemplate,
  deleteTemplate,
  applyTemplate,
  getTemplateRequirements,
  getTemplateCategories
};
</file>

<file path="server/utils/dbUtils.js">
/**
 * Database Utilities
 * 
 * Helper functions for database operations
 */

const fs = require('fs');
const path = require('path');
const Database = require('better-sqlite3');

/**
 * Get the size of a SQLite database file
 * @param {string} dbPath - Path to the database file
 * @returns {number} Size in bytes
 */
function getDatabaseSize(dbPath) {
  try {
    const stats = fs.statSync(dbPath);
    return stats.size;
  } catch (error) {
    console.error(`Error getting database size: ${error.message}`);
    return 0;
  }
}

/**
 * Validate a SQLite database file
 * @param {string} dbPath - Path to the database file
 * @returns {boolean} True if valid
 */
function validateDatabase(dbPath) {
  return new Promise((resolve) => {
    try {
      // Check if file exists
      if (!fs.existsSync(dbPath)) {
        console.error(`Database file not found: ${dbPath}`);
        resolve(false);
        return;
      }
      
      // Try to open the database
      try {
        const db = new Database(dbPath, { readonly: true });
        
        // Try a simple query
        const row = db.prepare('SELECT sqlite_version()').get();
        
        // Close the database
        db.close();
        
        resolve(!!row);
      } catch (error) {
        console.error(`Error validating database: ${error.message}`);
        resolve(false);
      }
    } catch (error) {
      console.error(`Error validating database: ${error.message}`);
      resolve(false);
    }
  });
}

/**
 * Get the number of tables in a database
 * @param {Object} db - Database connection
 * @returns {number} Table count
 */
function getTableCount(db) {
  try {
    const row = db.prepare(`
      SELECT COUNT(*) as count 
      FROM sqlite_master 
      WHERE type = 'table' AND name NOT LIKE 'sqlite_%'
    `).get();
    
    return row ? row.count : 0;
  } catch (error) {
    console.error(`Error counting tables: ${error.message}`);
    return 0;
  }
}

/**
 * Create a safe read-only connection to a database
 * Note: We've moved this functionality to connectionService.getConnection
 * This method is kept for backwards compatibility
 * @param {string} dbPath - Path to the database file
 * @returns {null} Always returns null to prevent duplicate connections
 */
function createReadOnlyConnection(dbPath) {
  console.warn('createReadOnlyConnection is deprecated. Use connectionService.getConnection instead.');
  return null;
}

/**
 * Parse SQLite column types to more useful information
 * @param {string} typeName - SQLite type name
 * @returns {Object} Type information
 */
function parseColumnType(typeName) {
  if (!typeName) {
    return {
      type: 'unknown',
      jsType: 'string',
      isNumeric: false,
      isDate: false,
      isText: true
    };
  }
  
  // Normalize type name
  const type = typeName.toUpperCase();
  
  // Check for numeric types
  if (
    type.includes('INT') || 
    type.includes('REAL') || 
    type.includes('FLOA') || 
    type.includes('DOUB') || 
    type.includes('NUM') ||
    type.includes('DECI')
  ) {
    return {
      type: typeName,
      jsType: 'number',
      isNumeric: true,
      isDate: false,
      isText: false
    };
  }
  
  // Check for date/time types
  if (
    type.includes('DATE') || 
    type.includes('TIME') || 
    type.includes('TIMESTAMP')
  ) {
    return {
      type: typeName,
      jsType: 'date',
      isNumeric: false,
      isDate: true,
      isText: false
    };
  }
  
  // Check for boolean types
  if (type.includes('BOOL')) {
    return {
      type: typeName,
      jsType: 'boolean',
      isNumeric: false,
      isDate: false,
      isText: false
    };
  }
  
  // Default to text type
  return {
    type: typeName,
    jsType: 'string',
    isNumeric: false,
    isDate: false,
    isText: true
  };
}

/**
 * Get sample data with appropriate types for a column
 * @param {Object} db - Database connection
 * @param {string} tableName - Table name
 * @param {string} columnName - Column name
 * @param {number} limit - Number of sample rows
 * @returns {Array} Column sample data
 */
function getColumnSample(db, tableName, columnName, limit = 5) {
  try {
    const escapedTable = `"${tableName.replace(/"/g, '""')}"`;
    const escapedColumn = `"${columnName.replace(/"/g, '""')}"`;
    
    const query = `
      SELECT ${escapedColumn}
      FROM ${escapedTable}
      WHERE ${escapedColumn} IS NOT NULL
      LIMIT ?
    `;
    
    return db.prepare(query).all(limit);
  } catch (error) {
    console.error(`Error getting column sample: ${error.message}`);
    return [];
  }
}

/**
 * Get column statistics (min, max, avg, etc.)
 * @param {Object} db - Database connection
 * @param {string} tableName - Table name
 * @param {string} columnName - Column name
 * @returns {Object} Column statistics
 */
function getColumnStats(db, tableName, columnName) {
  try {
    const escapedTable = `"${tableName.replace(/"/g, '""')}"`;
    const escapedColumn = `"${columnName.replace(/"/g, '""')}"`;
    
    // Get column type from pragma
    const columns = db.prepare(`PRAGMA table_info(${escapedTable})`).all();
    
    const columnInfo = columns.find(col => col.name === columnName);
    
    if (!columnInfo) {
      console.error(`Column '${columnName}' not found in table '${tableName}'`);
      return {
        count: 0,
        distinct_count: 0,
        null_count: 0,
        type: 'unknown',
        isNumeric: false,
        isDate: false,
        isText: false
      };
    }
    
    const typeInfo = parseColumnType(columnInfo.type);
    
    // Create the return object
    const result = {
      type: columnInfo.type,
      ...typeInfo
    };
    
    // Get null count
    const nullCount = db.prepare(`
      SELECT COUNT(*) as null_count
      FROM ${escapedTable}
      WHERE ${escapedColumn} IS NULL
    `).get();
    
    result.null_count = nullCount ? nullCount.null_count : 0;
    
    // For numeric columns, get statistics
    if (typeInfo.isNumeric) {
      const stats = db.prepare(`
        SELECT
          COUNT(${escapedColumn}) as count,
          MIN(${escapedColumn}) as min,
          MAX(${escapedColumn}) as max,
          AVG(${escapedColumn}) as avg,
          SUM(${escapedColumn}) as sum
        FROM ${escapedTable}
        WHERE ${escapedColumn} IS NOT NULL
      `).get();
      
      if (stats) {
        Object.assign(result, stats);
      } else {
        result.count = 0;
        result.min = null;
        result.max = null;
        result.avg = null;
        result.sum = null;
      }
      
      // Get count of distinct values
      const distinctResult = db.prepare(`
        SELECT COUNT(DISTINCT ${escapedColumn}) as distinct_count
        FROM ${escapedTable}
        WHERE ${escapedColumn} IS NOT NULL
      `).get();
      
      result.distinct_count = distinctResult ? distinctResult.distinct_count : 0;
    } else {
      // For non-numeric columns, just get counts
      const counts = db.prepare(`
        SELECT
          COUNT(${escapedColumn}) as count,
          COUNT(DISTINCT ${escapedColumn}) as distinct_count
        FROM ${escapedTable}
        WHERE ${escapedColumn} IS NOT NULL
      `).get();
      
      if (counts) {
        result.count = counts.count;
        result.distinct_count = counts.distinct_count;
      } else {
        result.count = 0;
        result.distinct_count = 0;
      }
    }
    
    return result;
  } catch (error) {
    console.error(`Error getting column statistics: ${error.message}`);
    return {
      count: 0,
      distinct_count: 0,
      null_count: 0,
      type: 'unknown',
      isNumeric: false,
      isDate: false,
      isText: false
    };
  }
}

/**
 * Check if a field contains date values
 * @param {Object} db - Database connection
 * @param {string} tableName - Table name
 * @param {string} columnName - Column name
 * @returns {boolean} True if field contains dates
 */
function isDateField(db, tableName, columnName) {
  try {
    const escapedTable = `"${tableName.replace(/"/g, '""')}"`;
    const escapedColumn = `"${columnName.replace(/"/g, '""')}"`;
    
    // Get column type
    const columns = db.prepare(`PRAGMA table_info(${escapedTable})`).all();
    
    const columnInfo = columns.find(col => col.name === columnName);
    
    if (!columnInfo) {
      return false;
    }
    
    // Check type name for date keywords
    const typeName = columnInfo.type.toUpperCase();
    if (
      typeName.includes('DATE') || 
      typeName.includes('TIME') || 
      typeName.includes('TIMESTAMP')
    ) {
      return true;
    }
    
    // If it's a text column, sample some values and check if they're dates
    if (typeName.includes('TEXT') || typeName.includes('VARCHAR') || typeName.includes('CHAR')) {
      // Get some sample values
      const rows = db.prepare(`
        SELECT DISTINCT ${escapedColumn}
        FROM ${escapedTable}
        WHERE ${escapedColumn} IS NOT NULL
        LIMIT 5
      `).all();
      
      const samples = rows.map(row => row[columnName]);
      
      // Check if all samples match date patterns
      const datePatterns = [
        /^\d{4}-\d{2}-\d{2}$/, // ISO date
        /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/, // ISO datetime
        /^\d{2}\/\d{2}\/\d{4}$/, // US date
        /^\d{2}\.\d{2}\.\d{4}$/, // European date
        /^\d{2}-\d{2}-\d{4}$/ // Another common format
      ];
      
      return samples.length > 0 && samples.every(sample => {
        if (typeof sample !== 'string') return false;
        return datePatterns.some(pattern => pattern.test(sample));
      });
    }
    
    return false;
  } catch (error) {
    console.error(`Error checking if field contains dates: ${error.message}`);
    return false;
  }
}

module.exports = {
  getDatabaseSize,
  validateDatabase,
  getTableCount,
  createReadOnlyConnection,
  parseColumnType,
  getColumnSample,
  getColumnStats,
  isDateField
};
</file>

<file path="client/src/components/table/DataTable.tsx">
import { FC, useState, useEffect, useCallback, useRef } from 'react';
import { ChevronUp, ChevronDown, Search, X, Filter, ArrowLeft, ArrowRight } from 'lucide-react';
import ExportButton from '../common/ExportButton';

interface DataTableProps {
  data: any[];
  total: number;
  page: number;
  limit: number;
  onPageChange: (page: number) => void;
  onSortChange: (column: string, direction: 'asc' | 'desc') => void;
  onFilterChange: (filters: Record<string, string>) => void;
  loading?: boolean;
  filters?: Record<string, string>;
  highlightPattern?: string;
  connectionId?: number;
  tableName?: string;
  showExport?: boolean;
}

/**
 * DataTable Component
 * 
 * A responsive, accessible data table with:
 * - Sorting (click on column headers)
 * - Filtering (input fields in header)
 * - Pagination
 * - Keyboard navigation
 * - Responsive design
 */
const DataTable: FC<DataTableProps> = ({
  data = [],
  total = 0,
  page = 1,
  limit = 100,
  onPageChange,
  onSortChange,
  onFilterChange,
  loading = false,
  filters = {},
  highlightPattern = '',
  connectionId,
  tableName,
  showExport = false
}) => {
  // Keep track of current sort state
  const [currentSort, setCurrentSort] = useState<{ column: string; direction: 'asc' | 'desc' } | null>(null);
  // Ref for managing keyboard focus in the table
  const tableRef = useRef<HTMLDivElement>(null);
  // Debounce timer ref for filter inputs
  const debounceTimerRef = useRef<NodeJS.Timeout | null>(null);
  // Filter input refs for clearing all filters
  const filterInputRefs = useRef<Record<string, HTMLInputElement | null>>({});
  
  // Calculate pagination info
  const totalPages = Math.ceil(total / limit);
  const startItem = total === 0 ? 0 : (page - 1) * limit + 1;
  const endItem = Math.min(page * limit, total);
  
  // Get column headers from first row
  const columns = data.length > 0 ? Object.keys(data[0]) : [];

  // Handle sort toggle with direction control
  const handleSort = useCallback((column: string) => {
    let direction: 'asc' | 'desc' = 'asc';
    
    // Toggle sort direction if already sorting by this column
    if (currentSort && currentSort.column === column) {
      direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
    }
    
    setCurrentSort({ column, direction });
    onSortChange(column, direction);
  }, [currentSort, onSortChange]);

  // Debounced filter handler to prevent too many requests
  const handleFilterChange = useCallback((column: string, value: string) => {
    if (debounceTimerRef.current) {
      clearTimeout(debounceTimerRef.current);
    }
    
    debounceTimerRef.current = setTimeout(() => {
      onFilterChange({
        ...filters,
        [column]: value
      });
    }, 400); // 400ms debounce
  }, [filters, onFilterChange]);

  // Clear all filters
  const clearAllFilters = useCallback(() => {
    // Clear all input fields
    Object.values(filterInputRefs.current).forEach(input => {
      if (input) input.value = '';
    });
    
    // Clear filters in state
    onFilterChange({});
  }, [onFilterChange]);

  // Clear a single filter
  const clearFilter = useCallback((column: string) => {
    const input = filterInputRefs.current[column];
    if (input) input.value = '';
    
    const newFilters = { ...filters };
    delete newFilters[column];
    onFilterChange(newFilters);
  }, [filters, onFilterChange]);

  // Format cell value for display
  const formatCellValue = useCallback((value: any): string => {
    if (value === null || value === undefined) return '—';
    
    // Handle different data types
    if (typeof value === 'boolean') return value ? 'Yes' : 'No';
    if (value instanceof Date) return value.toLocaleString();
    if (typeof value === 'object') {
      try {
        return JSON.stringify(value);
      } catch (e) {
        return String(value);
      }
    }
    
    return String(value);
  }, []);

  // Highlight matching text if a pattern is provided
  const highlightText = useCallback((text: string) => {
    if (!highlightPattern || !text) return text;
    
    try {
      const regex = new RegExp(`(${highlightPattern})`, 'gi');
      const parts = text.split(regex);
      
      if (parts.length <= 1) return text;
      
      return parts.map((part, i) => 
        regex.test(part) ? <mark key={i} className="bg-amber-200">{part}</mark> : part
      );
    } catch (e) {
      // If regex fails, return original text
      return text;
    }
  }, [highlightPattern]);

  // Handle keyboard navigation
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Only handle if focus is within the table
      if (!tableRef.current?.contains(document.activeElement)) return;
      
      switch (e.key) {
        case 'ArrowLeft':
          if (e.altKey && page > 1) {
            e.preventDefault();
            onPageChange(page - 1);
          }
          break;
        case 'ArrowRight':
          if (e.altKey && page < totalPages) {
            e.preventDefault();
            onPageChange(page + 1);
          }
          break;
        case 'Home':
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            onPageChange(1);
          }
          break;
        case 'End':
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            onPageChange(totalPages);
          }
          break;
      }
    };
    
    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [page, totalPages, onPageChange]);

  // Loading state
  if (loading) {
    return (
      <div 
        className="bg-white p-6 rounded-md border border-slate-200 flex justify-center items-center h-[300px]"
        role="status"
        aria-live="polite"
      >
        <div className="flex flex-col items-center gap-2">
          <div className="animate-spin h-8 w-8 border-4 border-slate-300 border-t-primary rounded-full" />
          <p className="text-slate-500">Loading data...</p>
        </div>
      </div>
    );
  }
  
  // Empty state
  if (data.length === 0) {
    return (
      <div className="bg-white p-6 rounded-md border border-slate-200 text-center">
        <div className="py-12 flex flex-col items-center">
          {Object.keys(filters).length > 0 ? (
            <>
              <Filter className="h-12 w-12 text-slate-300 mb-4" />
              <p className="text-slate-700 font-medium mb-2">No results match your filters</p>
              <p className="text-slate-500 mb-4">Try adjusting your search or filter to find what you're looking for.</p>
              <button
                onClick={clearAllFilters}
                className="px-4 py-2 bg-primary text-white text-sm font-medium rounded hover:bg-primary-dark focus:outline-none focus:ring-2 focus:ring-primary focus:ring-opacity-50"
              >
                Clear All Filters
              </button>
            </>
          ) : (
            <>
              <Search className="h-12 w-12 text-slate-300 mb-4" />
              <p className="text-slate-700 font-medium">No data available</p>
              <p className="text-slate-500">This table appears to be empty.</p>
            </>
          )}
        </div>
      </div>
    );
  }
  
  // Calculate visible page numbers
  const visiblePageNumbers = () => {
    const delta = 2; // Number of pages to show before and after current page
    const range: number[] = [];
    
    // Always show page 1
    range.push(1);
    
    // Calculate start and end of range
    const rangeStart = Math.max(2, page - delta);
    const rangeEnd = Math.min(totalPages - 1, page + delta);
    
    // Add ellipsis after page 1 if needed
    if (rangeStart > 2) {
      range.push(-1); // -1 represents ellipsis
    }
    
    // Add pages in the middle
    for (let i = rangeStart; i <= rangeEnd; i++) {
      range.push(i);
    }
    
    // Add ellipsis before last page if needed
    if (rangeEnd < totalPages - 1) {
      range.push(-2); // -2 represents ellipsis (different key from the first one)
    }
    
    // Always show last page if there is more than one page
    if (totalPages > 1) {
      range.push(totalPages);
    }
    
    return range;
  };
  
  return (
    <div className="bg-white rounded-md border border-slate-200 shadow-sm" ref={tableRef}>
      {/* Active filters */}
      {Object.keys(filters).length > 0 && (
        <div className="px-4 py-2 border-b border-slate-200 bg-slate-50 flex flex-wrap items-center gap-2">
          <span className="text-xs font-medium text-slate-500 mr-1">Filters:</span>
          {Object.entries(filters).map(([column, value]) => 
            value && (
              <span 
                key={`filter-tag-${column}`} 
                className="inline-flex items-center py-1 pl-2 pr-1 bg-slate-100 text-slate-700 text-xs rounded border border-slate-200"
              >
                <span className="font-medium mr-1">{column}:</span> {value}
                <button 
                  onClick={() => clearFilter(column)} 
                  className="ml-1 p-0.5 rounded-full hover:bg-slate-200"
                  aria-label={`Remove ${column} filter`}
                >
                  <X className="h-3 w-3 text-slate-500" />
                </button>
              </span>
            )
          )}
          <button 
            onClick={clearAllFilters} 
            className="ml-auto text-xs text-primary hover:text-primary-dark"
          >
            Clear all
          </button>
        </div>
      )}
      
      <div className="overflow-x-auto">
        <table className="min-w-full divide-y divide-slate-200">
          <thead className="bg-slate-50">
            {/* Column headers with sort indicators */}
            <tr>
              {columns.map((column) => (
                <th
                  key={column}
                  className="group px-4 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider cursor-pointer hover:bg-slate-100"
                  onClick={() => handleSort(column)}
                  aria-sort={
                    currentSort && currentSort.column === column 
                      ? currentSort.direction === 'asc' ? 'ascending' : 'descending' 
                      : 'none'
                  }
                  scope="col"
                >
                  <div className="flex items-center">
                    <span className="mr-1">{column}</span>
                    <div className="flex flex-col">
                      {currentSort && currentSort.column === column ? (
                        currentSort.direction === 'asc' ? (
                          <ChevronUp className="h-3 w-3 text-primary" />
                        ) : (
                          <ChevronDown className="h-3 w-3 text-primary" />
                        )
                      ) : (
                        <div className="opacity-0 group-hover:opacity-30">
                          <ChevronUp className="h-3 w-3" />
                        </div>
                      )}
                    </div>
                  </div>
                </th>
              ))}
            </tr>
            
            {/* Filter inputs */}
            <tr>
              {columns.map((column) => (
                <th key={`filter-${column}`} className="px-4 py-2">
                  <div className="relative">
                    <input
                      type="text"
                      className="w-full px-2 py-1 pr-6 text-xs border border-slate-300 rounded-sm placeholder-slate-400 focus:ring-1 focus:ring-primary focus:border-primary"
                      placeholder={`Filter ${column}`}
                      defaultValue={filters[column] || ''}
                      onChange={(e) => handleFilterChange(column, e.target.value)}
                      aria-label={`Filter by ${column}`}
                      ref={(el) => filterInputRefs.current[column] = el}
                    />
                    {filters[column] && (
                      <button
                        onClick={() => clearFilter(column)}
                        className="absolute right-1 top-1/2 transform -translate-y-1/2 p-0.5 rounded-full hover:bg-slate-100"
                        aria-label={`Clear ${column} filter`}
                      >
                        <X className="h-3 w-3 text-slate-400" />
                      </button>
                    )}
                  </div>
                </th>
              ))}
            </tr>
          </thead>
          
          <tbody className="bg-white divide-y divide-slate-200">
            {data.map((row, rowIndex) => (
              <tr 
                key={rowIndex} 
                className="hover:bg-slate-50"
                tabIndex={0}
              >
                {columns.map((column) => {
                  const value = row[column];
                  const formattedValue = formatCellValue(value);
                  
                  return (
                    <td 
                      key={`${rowIndex}-${column}`} 
                      className="px-4 py-3 text-sm text-slate-900"
                      data-label={column}
                    >
                      {highlightPattern ? highlightText(formattedValue) : formattedValue}
                    </td>
                  );
                })}
              </tr>
            ))}
          </tbody>
        </table>
      </div>
      
      {/* Pagination */}
      <div className="px-4 py-3 flex flex-col sm:flex-row sm:items-center sm:justify-between border-t border-slate-200 gap-3">
        <div className="flex items-center">
          <div className="text-sm text-slate-500 mr-4">
            {total > 0 ? (
              <>
                Showing <span className="font-medium">{startItem}</span> to{' '}
                <span className="font-medium">{endItem}</span> of{' '}
                <span className="font-medium">{total}</span> results
              </>
            ) : (
              <span>No results</span>
            )}
          </div>
          
          {/* Export Button */}
          {showExport && connectionId && tableName && total > 0 && (
            <ExportButton
              type="table"
              connectionId={connectionId}
              tableName={tableName}
              filters={filters}
              sort={currentSort}
              limit={Math.min(10000, total)} // Cap at 10,000 rows or total rows (whichever is smaller)
            />
          )}
        </div>
        
        <div className="flex items-center justify-between sm:justify-end flex-wrap gap-2">
          {/* Rows per page selector */}
          <div className="flex items-center mr-4">
            <label htmlFor="limit-select" className="text-xs text-slate-500 mr-2">
              Rows per page:
            </label>
            <select
              id="limit-select"
              className="text-xs border-slate-300 rounded-sm focus:ring-primary focus:border-primary"
              value={limit}
              onChange={(e) => {
                const newLimit = Number(e.target.value);
                const newPage = Math.max(1, Math.min(Math.ceil(total / newLimit), page));
                setCurrentSort(null);
                onPageChange(newPage);
              }}
            >
              <option value="50">50</option>
              <option value="100">100</option>
              <option value="250">250</option>
              <option value="500">500</option>
            </select>
          </div>
          
          {/* Page navigation */}
          <nav className="flex" aria-label="Pagination">
            <ul className="flex items-center space-x-1">
              {/* Previous page button */}
              <li>
                <button
                  className="p-1.5 rounded-sm text-slate-500 hover:bg-slate-100 disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:bg-transparent"
                  onClick={() => onPageChange(page - 1)}
                  disabled={page === 1}
                  aria-label="Previous page"
                >
                  <ArrowLeft className="h-4 w-4" />
                </button>
              </li>
              
              {/* Page numbers */}
              {visiblePageNumbers().map((pageNum, index) => 
                pageNum < 0 ? (
                  // Ellipsis
                  <li key={`ellipsis-${pageNum}`}>
                    <span className="px-1 text-slate-400">...</span>
                  </li>
                ) : (
                  // Page button
                  <li key={`page-${pageNum}`}>
                    <button
                      className={`px-3 py-1.5 text-sm rounded-sm ${
                        pageNum === page
                          ? 'bg-primary text-white font-medium'
                          : 'text-slate-500 hover:bg-slate-100'
                      }`}
                      onClick={() => onPageChange(pageNum)}
                      aria-current={pageNum === page ? 'page' : undefined}
                      aria-label={`Page ${pageNum}`}
                    >
                      {pageNum}
                    </button>
                  </li>
                )
              )}
              
              {/* Next page button */}
              <li>
                <button
                  className="p-1.5 rounded-sm text-slate-500 hover:bg-slate-100 disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:bg-transparent"
                  onClick={() => onPageChange(page + 1)}
                  disabled={page >= totalPages}
                  aria-label="Next page"
                >
                  <ArrowRight className="h-4 w-4" />
                </button>
              </li>
            </ul>
          </nav>
        </div>
      </div>
      
      {/* Accessibility features */}
      <div className="sr-only" aria-live="polite">
        {loading ? 'Loading data...' : `Showing page ${page} of ${totalPages}`}
      </div>
    </div>
  );
};

export default DataTable;
</file>

<file path="client/src/pages/Connections.tsx">
import { FC, useState, useEffect } from 'react';
import ConnectionForm from '../components/connection/ConnectionForm';
import ConnectionList from '../components/connection/ConnectionList';
import { Connection } from '../types';
import { connectionApi } from '../services/api';

/**
 * Connections Page
 * 
 * Manages database connections and displays connection history
 */
const Connections: FC = () => {
  const [connections, setConnections] = useState<Connection[] | null>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  
  useEffect(() => {
    // Fetch connections from API
    const fetchConnections = async () => {
      try {
        setLoading(true);
        const data = await connectionApi.getAll();
        console.log('Connections data received:', data);
        console.log('Type of data:', typeof data);
        console.log('Is Array?', Array.isArray(data));
        
        // Make sure we're setting an array
        if (Array.isArray(data)) {
          setConnections(data);
        } else {
          console.error('Expected array but got:', data);
          setConnections([]);
          setError('Data format error: Expected array of connections');
        }
        
      } catch (err) {
        console.error('Error fetching connections:', err);
        setError(err instanceof Error ? err.message : 'Failed to load connections');
        setConnections([]);
      } finally {
        setLoading(false);
      }
    };
    
    fetchConnections();
  }, []);
  
  const handleAddConnection = async (connectionData: Omit<Connection, 'id'>) => {
    try {
      const newConnection = await connectionApi.create(connectionData);
      setConnections([...connections, newConnection]);
      return Promise.resolve();
    } catch (err) {
      return Promise.reject(err);
    }
  };
  
  const handleDeleteConnection = async (connectionId: string | number) => {
    try {
      await connectionApi.delete(connectionId.toString());
      setConnections(connections.filter(conn => conn.id !== connectionId));
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to delete connection');
    }
  };
  
  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h1 className="text-3xl font-semibold text-slate-900">Database Connections</h1>
      </div>
      
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        {/* Connection Form */}
        <div className="md:col-span-1">
          <ConnectionForm onAddConnection={handleAddConnection} />
        </div>
        
        {/* Connection List */}
        <div className="md:col-span-2">
          <ConnectionList 
            connections={connections} 
            loading={loading} 
            error={error}
            onDeleteConnection={handleDeleteConnection}
          />
        </div>
      </div>
    </div>
  );
};

export default Connections;
</file>

<file path="client/src/pages/Templates.tsx">
import { FC, useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { Connection, Template } from '../types';
import { connectionApi, templateApi } from '../services/api';
import TemplateList from '../components/templates/TemplateList';

/**
 * Templates Page
 * 
 * Displays and applies pre-configured insight templates
 */
const Templates: FC = () => {
  const navigate = useNavigate();
  const [templates, setTemplates] = useState<Template[]>([]);
  const [connections, setConnections] = useState<Connection[]>([]);
  const [selectedConnection, setSelectedConnection] = useState<string | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [categories, setCategories] = useState<string[]>([]);
  const [selectedCategory, setSelectedCategory] = useState<string>('');
  const [searchTerm, setSearchTerm] = useState<string>('');
  const [filteredTemplates, setFilteredTemplates] = useState<Template[]>([]);
  
  // Load the last selected connection from localStorage if available
  useEffect(() => {
    const savedConnection = localStorage.getItem('selectedConnection');
    if (savedConnection) {
      setSelectedConnection(savedConnection);
    }
  }, []);
  
  // Save selected connection to localStorage when it changes
  useEffect(() => {
    if (selectedConnection) {
      localStorage.setItem('selectedConnection', selectedConnection);
    }
  }, [selectedConnection]);
  
  useEffect(() => {
    // Fetch templates and connections from API
    const fetchData = async () => {
      try {
        setLoading(true);
        
        const [templatesData, connectionsData, categoriesData] = await Promise.all([
          templateApi.getAll(),
          connectionApi.getAll(),
          templateApi.getCategories()
        ]);
        
        setTemplates(templatesData);
        setFilteredTemplates(templatesData);
        setConnections(connectionsData);
        setCategories(categoriesData);
        setError(null);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to load data');
      } finally {
        setLoading(false);
      }
    };
    
    fetchData();
  }, []);
  
  // Apply filters when templates, category, or search term changes
  useEffect(() => {
    let filtered = [...templates];
    
    // Apply category filter
    if (selectedCategory) {
      filtered = filtered.filter(template => template.category === selectedCategory);
    }
    
    // Apply search filter
    if (searchTerm.trim()) {
      const term = searchTerm.toLowerCase();
      filtered = filtered.filter(template => 
        template.name.toLowerCase().includes(term) || 
        (template.description && template.description.toLowerCase().includes(term))
      );
    }
    
    setFilteredTemplates(filtered);
  }, [templates, selectedCategory, searchTerm]);
  
  const handleApplyTemplate = (templateId: string | number) => {
    if (!selectedConnection) {
      setError('Please select a connection first');
      return;
    }
    
    // Navigate to a template configuration page
    navigate(`/templates/${templateId}/apply?connection=${selectedConnection}`);
  };
  
  const handleClearFilters = () => {
    setSelectedCategory('');
    setSearchTerm('');
  };
  
  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h1 className="text-3xl font-semibold text-slate-900">Insight Templates</h1>
      </div>
      
      {error && (
        <div className="p-4 bg-red-50 border border-red-200 rounded-md text-red-700">
          {error}
        </div>
      )}
      
      {/* Connection Selector */}
      <div className="bg-white p-6 rounded-md border border-slate-200">
        <h2 className="text-lg font-medium text-slate-900 mb-4">Select Database Connection</h2>
        <select 
          className="w-full px-3 py-2 border border-slate-300 rounded-sm text-sm"
          value={selectedConnection || ''}
          onChange={(e) => setSelectedConnection(e.target.value)}
          disabled={loading || connections.length === 0}
        >
          <option value="">Select a connection</option>
          {connections.map((connection) => (
            <option key={connection.id} value={connection.id.toString()}>
              {connection.name}
            </option>
          ))}
        </select>
        {!selectedConnection && (
          <p className="mt-2 text-sm text-slate-500">
            Please select a database connection to apply templates
          </p>
        )}
      </div>
      
      {/* Filter Controls */}
      <div className="bg-white p-6 rounded-md border border-slate-200">
        <h2 className="text-lg font-medium text-slate-900 mb-4">Filter Templates</h2>
        
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          {/* Category Filter */}
          <div>
            <label className="block text-sm font-medium text-slate-700 mb-1">
              Category
            </label>
            <select 
              className="w-full px-3 py-2 border border-slate-300 rounded-sm text-sm"
              value={selectedCategory}
              onChange={(e) => setSelectedCategory(e.target.value)}
              disabled={loading || categories.length === 0}
            >
              <option value="">All Categories</option>
              {categories.map((category) => (
                <option key={category} value={category}>
                  {category}
                </option>
              ))}
            </select>
          </div>
          
          {/* Search Box */}
          <div>
            <label className="block text-sm font-medium text-slate-700 mb-1">
              Search
            </label>
            <input 
              type="text"
              className="w-full px-3 py-2 border border-slate-300 rounded-sm text-sm"
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              placeholder="Search templates..."
              disabled={loading}
            />
          </div>
        </div>
        
        {/* Filter Status */}
        <div className="mt-4 flex justify-between items-center">
          <p className="text-sm text-slate-500">
            Showing {filteredTemplates.length} of {templates.length} templates
          </p>
          
          {(selectedCategory || searchTerm) && (
            <button 
              className="text-sm text-blue-600 hover:text-blue-800"
              onClick={handleClearFilters}
            >
              Clear Filters
            </button>
          )}
        </div>
      </div>
      
      {/* Templates List */}
      <TemplateList 
        templates={filteredTemplates}
        selectedConnectionId={selectedConnection}
        onApplyTemplate={handleApplyTemplate}
        isLoading={loading}
      />
    </div>
  );
};

export default Templates;
</file>

<file path="server/services/visualizationService.js">
/**
 * Visualization Service
 * 
 * Handles visualization creation, storage, and retrieval
 */

const appDbService = require('./appDbService');
const databaseService = require('./databaseService');

/**
 * Create a new visualization
 * @param {Object} visualizationData - Visualization details
 * @param {string} visualizationData.name - Visualization name
 * @param {string} visualizationData.type - Visualization type (bar, line, pie, etc.)
 * @param {Object} visualizationData.config - Visualization configuration
 * @param {string} visualizationData.connectionId - Connection ID
 * @param {string} visualizationData.tableName - Table name
 * @returns {Promise<Object>} Created visualization
 * @throws {Error} If visualization creation fails
 */
async function createVisualization(visualizationData) {
  try {
    // Validate required fields
    if (!visualizationData.name) {
      throw new Error('Visualization name is required');
    }
    
    if (!visualizationData.type) {
      throw new Error('Visualization type is required');
    }
    
    if (!visualizationData.config) {
      throw new Error('Visualization configuration is required');
    }
    
    // Insert visualization using the appDbService run helper
    const result = await appDbService.run(`
      INSERT INTO saved_visualizations (
        connection_id,
        name,
        type,
        config,
        table_name
      ) VALUES (?, ?, ?, ?, ?)
    `, [
      visualizationData.connectionId || null,
      visualizationData.name,
      visualizationData.type,
      JSON.stringify(visualizationData.config),
      visualizationData.tableName || null
    ]);
    
    // Get the created visualization
    const visualization = await getVisualizationById(result.lastID);
    
    return visualization;
  } catch (error) {
    console.error('Error creating visualization:', error);
    throw new Error(`Failed to create visualization: ${error.message}`);
  }
}

/**
 * Get all saved visualizations
 * @returns {Promise<Array>} List of all saved visualizations
 * @throws {Error} If retrieval fails
 */
async function getAllVisualizations() {
  try {
    // Query all visualizations using the appDbService all helper
    const visualizations = await appDbService.all(`
      SELECT 
        id,
        connection_id,
        name,
        type,
        config,
        table_name,
        created_at,
        updated_at
      FROM saved_visualizations
      ORDER BY updated_at DESC
    `);
    
    // Convert to camelCase and parse the JSON config for each visualization
    return visualizations.map(visualization => {
      // Parse config safely
      let parsedConfig = {};
      try {
        if (visualization && visualization.config) {
          parsedConfig = JSON.parse(visualization.config);
        }
      } catch (err) {
        // Make sure visualization is not null before accessing its id
        const vizId = visualization ? visualization.id : 'unknown';
        console.error(`Failed to parse config for visualization ${vizId}:`, err);
        // Use empty object if parsing fails
      }
      
      return {
        id: visualization.id,
        connectionId: visualization.connection_id,
        name: visualization.name,
        type: visualization.type,
        config: parsedConfig,
        tableName: visualization.table_name,
        createdAt: visualization.created_at,
        updatedAt: visualization.updated_at
      };
    });
  } catch (error) {
    console.error('Error retrieving visualizations:', error);
    throw new Error(`Failed to retrieve visualizations: ${error.message}`);
  }
}

/**
 * Get a visualization by ID
 * @param {string|number} id - Visualization ID
 * @returns {Promise<Object>} Visualization details
 * @throws {Error} If visualization not found or retrieval fails
 */
async function getVisualizationById(id) {
  try {
    // Query visualization by ID using the appDbService get helper
    const visualization = await appDbService.get(`
      SELECT 
        id,
        connection_id AS connectionId,
        name,
        type,
        config,
        table_name AS tableName,
        created_at AS createdAt,
        updated_at AS updatedAt
      FROM saved_visualizations
      WHERE id = ?
    `, [id]);
    
    // If visualization not found
    if (!visualization) {
      throw new Error(`Visualization with ID ${id} not found`);
    }
    
    // Parse the JSON config safely
    let parsedConfig = {};
    try {
      if (visualization.config) {
        parsedConfig = JSON.parse(visualization.config);
      }
    } catch (err) {
      console.error(`Failed to parse config for visualization ${id}:`, err);
      // Use empty object if parsing fails
    }
    
    return {
      ...visualization,
      config: parsedConfig
    };
  } catch (error) {
    console.error(`Error retrieving visualization with ID ${id}:`, error);
    throw new Error(`Failed to retrieve visualization: ${error.message}`);
  }
}

/**
 * Update a visualization
 * @param {string|number} id - Visualization ID
 * @param {Object} visualizationData - Updated visualization details
 * @returns {Promise<Object>} Updated visualization
 * @throws {Error} If visualization not found or update fails
 */
async function updateVisualization(id, visualizationData) {
  try {
    // Check if visualization exists
    const existingViz = await getVisualizationById(id);
    
    // Handle config update safely
    let configString = existingViz.config ? JSON.stringify(existingViz.config) : '{}';
    if (visualizationData.config) {
      try {
        configString = JSON.stringify(visualizationData.config);
      } catch (err) {
        console.error(`Failed to stringify config for visualization ${id}:`, err);
        throw new Error(`Invalid configuration: ${err.message}`);
      }
    }
    
    // Prepare update data
    const updates = {
      name: visualizationData.name || existingViz.name,
      type: visualizationData.type || existingViz.type,
      config: configString,
      table_name: visualizationData.tableName || existingViz.tableName,
      connection_id: visualizationData.connectionId || existingViz.connectionId,
      updated_at: new Date().toISOString()
    };
    
    // Update visualization using the appDbService run helper
    await appDbService.run(`
      UPDATE saved_visualizations
      SET name = ?,
          type = ?,
          config = ?,
          table_name = ?,
          connection_id = ?,
          updated_at = ?
      WHERE id = ?
    `, [
      updates.name,
      updates.type,
      updates.config,
      updates.table_name,
      updates.connection_id,
      updates.updated_at,
      id
    ]);
    
    // Get the updated visualization
    return await getVisualizationById(id);
  } catch (error) {
    console.error(`Error updating visualization with ID ${id}:`, error);
    throw new Error(`Failed to update visualization: ${error.message}`);
  }
}

/**
 * Delete a visualization
 * @param {string|number} id - Visualization ID
 * @returns {Promise<boolean>} True if visualization was deleted
 * @throws {Error} If visualization not found or deletion fails
 */
async function deleteVisualization(id) {
  try {
    // Check if visualization exists before attempting to delete
    const vizExists = await appDbService.get(`
      SELECT 1 FROM saved_visualizations WHERE id = ?
    `, [id]);
    
    if (!vizExists) {
      throw new Error(`Visualization with ID ${id} not found`);
    }
    
    // Delete visualization using the appDbService run helper
    const result = await appDbService.run(`
      DELETE FROM saved_visualizations
      WHERE id = ?
    `, [id]);
    
    // Return true if a row was deleted
    return result.changes > 0;
  } catch (error) {
    console.error(`Error deleting visualization with ID ${id}:`, error);
    throw new Error(`Failed to delete visualization: ${error.message}`);
  }
}

/**
 * Generate data for visualization
 * @param {string|number} connectionId - Connection ID
 * @param {string} tableName - Table name
 * @param {Object} config - Visualization configuration
 * @returns {Promise<Object>} Visualization data
 * @throws {Error} If data generation fails
 */
async function generateVisualizationData(connectionId, tableName, config) {
  try {
    // Validate inputs
    if (!connectionId) {
      throw new Error('Connection ID is required');
    }
    
    if (!tableName) {
      throw new Error('Table name is required');
    }
    
    if (!config) {
      throw new Error('Visualization configuration is required');
    }
    
    // Get chart type and field mappings
    const chartType = config.type || 'bar';
    const mappings = config.mappings || {};
    
    // Query the database based on chart type and mappings
    let result;
    
    switch (chartType) {
      case 'bar':
      case 'line':
        result = await generateBarOrLineChartData(connectionId, tableName, mappings);
        break;
      case 'pie':
      case 'doughnut':
        result = await generatePieChartData(connectionId, tableName, mappings);
        break;
      case 'scatter':
        result = await generateScatterChartData(connectionId, tableName, mappings);
        break;
      default:
        throw new Error(`Unsupported chart type: ${chartType}`);
    }
    
    return {
      ...result,
      type: chartType
    };
  } catch (error) {
    console.error('Error generating visualization data:', error);
    throw new Error(`Failed to generate visualization data: ${error.message}`);
  }
}

/**
 * Generate data for bar or line charts
 * @private
 */
async function generateBarOrLineChartData(connectionId, tableName, mappings) {
  // Get X and Y field mappings
  const xField = mappings.x;
  const yField = mappings.y;
  
  if (!xField || !yField) {
    throw new Error('X-axis and Y-axis field mappings are required');
  }
  
  // Build and execute query
  let query = `SELECT ${xField}, ${yField} FROM ${tableName}`;
  
  // Add sorting if specified
  if (mappings.sort) {
    const direction = mappings.sort === 'desc' ? 'DESC' : 'ASC';
    query += ` ORDER BY ${yField} ${direction}`;
  } else {
    query += ` ORDER BY ${xField} ASC`;
  }
  
  // Add limit if specified
  if (mappings.limit && !isNaN(mappings.limit)) {
    query += ` LIMIT ${mappings.limit}`;
  }
  
  // Execute query
  const result = await databaseService.executeQuery(connectionId, query);
  
  // Format data for Chart.js
  const labels = result.data.map(row => row[xField]);
  const dataset = {
    label: yField,
    data: result.data.map(row => row[yField]),
    backgroundColor: 'rgba(37, 99, 235, 0.6)',
    borderColor: 'rgba(37, 99, 235, 1)',
    borderWidth: 1
  };
  
  return {
    labels,
    datasets: [dataset],
    data: result.data
  };
}

/**
 * Generate data for pie or doughnut charts
 * @private
 */
async function generatePieChartData(connectionId, tableName, mappings) {
  // Get labels and values field mappings
  const labelsField = mappings.labels;
  const valuesField = mappings.values;
  
  if (!labelsField || !valuesField) {
    throw new Error('Labels and values field mappings are required');
  }
  
  // Build and execute query
  let query = `SELECT ${labelsField}, ${valuesField} FROM ${tableName}`;
  
  // Add sorting if specified
  if (mappings.sort) {
    const direction = mappings.sort === 'desc' ? 'DESC' : 'ASC';
    query += ` ORDER BY ${valuesField} ${direction}`;
  }
  
  // Add limit if specified
  if (mappings.limit && !isNaN(mappings.limit)) {
    query += ` LIMIT ${mappings.limit}`;
  }
  
  // Execute query
  const result = await databaseService.executeQuery(connectionId, query);
  
  // Chart.js colors for pie/doughnut charts (from style guide)
  const backgroundColors = [
    '#2563EB', // blue-600
    '#D946EF', // fuchsia-500
    '#F59E0B', // amber-500
    '#10B981', // emerald-500
    '#6366F1', // indigo-500
    '#EF4444', // red-500
    '#8B5CF6', // violet-500
    '#EC4899', // pink-500
    '#06B6D4', // cyan-500
    '#84CC16'  // lime-500
  ];
  
  // Format data for Chart.js
  const labels = result.data.map(row => row[labelsField]);
  const dataset = {
    data: result.data.map(row => row[valuesField]),
    backgroundColor: labels.map((_, i) => backgroundColors[i % backgroundColors.length]),
    borderColor: '#FFFFFF',
    borderWidth: 1
  };
  
  return {
    labels,
    datasets: [dataset],
    data: result.data
  };
}

/**
 * Generate data for scatter charts
 * @private
 */
async function generateScatterChartData(connectionId, tableName, mappings) {
  // Get X and Y field mappings
  const xField = mappings.x;
  const yField = mappings.y;
  
  if (!xField || !yField) {
    throw new Error('X-axis and Y-axis field mappings are required');
  }
  
  // Get optional size field mapping
  const sizeField = mappings.size;
  
  // Build and execute query
  let query = `SELECT ${xField}, ${yField}`;
  
  if (sizeField) {
    query += `, ${sizeField}`;
  }
  
  query += ` FROM ${tableName}`;
  
  // Add limit if specified
  if (mappings.limit && !isNaN(mappings.limit)) {
    query += ` LIMIT ${mappings.limit}`;
  }
  
  // Execute query
  const result = await databaseService.executeQuery(connectionId, query);
  
  // Format data for Chart.js
  const dataset = {
    label: `${xField} vs ${yField}`,
    data: result.data.map(row => ({
      x: row[xField],
      y: row[yField],
      r: sizeField ? (row[sizeField] / 5) : 5 // Scale size if available
    })),
    backgroundColor: 'rgba(37, 99, 235, 0.6)',
    borderColor: 'rgba(37, 99, 235, 1)',
    borderWidth: 1
  };
  
  return {
    datasets: [dataset],
    data: result.data
  };
}

module.exports = {
  createVisualization,
  getAllVisualizations,
  getVisualizationById,
  updateVisualization,
  deleteVisualization,
  generateVisualizationData
};
</file>

<file path="server/utils/queryBuilder.js">
/**
 * Query Builder
 * 
 * Utilities for building safe SQL queries with advanced filtering and pagination
 */

/**
 * Build a paginated SELECT query
 * @param {string} tableName - Table name
 * @param {Array} columns - Columns to select
 * @param {Object} options - Query options (pagination, sort, filter)
 * @returns {Object} SQL query and parameters
 */
function buildPaginatedSelectQuery(tableName, columns = ['*'], options = {}) {
  // Escape table name
  const escapedTableName = escapeIdentifier(tableName);
  
  // Default options
  const page = options.page || 1;
  const limit = options.limit || 100;
  
  // Build base query
  let sql = `SELECT ${columns.map(escapeIdentifier).join(', ')} FROM ${escapedTableName}`;
  const params = [];
  
  // Add WHERE clause if filter is provided
  if (options.filter) {
    const whereClause = parseFilters(options.filter);
    if (whereClause.where !== '1=1') {
      sql += ` WHERE ${whereClause.where}`;
      params.push(...whereClause.params);
    }
  }
  
  // Add ORDER BY clause if sort is provided
  if (options.sort) {
    sql += ` ${buildOrderByClause(options.sort)}`;
  }
  
  // Add pagination
  const pagination = buildPaginationClause(page, limit);
  sql += ` ${pagination.sql}`;
  params.push(...pagination.params);
  
  return {
    sql,
    params
  };
}

/**
 * Build a COUNT query
 * @param {string} tableName - Table name
 * @param {Object} filters - Query filters
 * @returns {Object} SQL query and parameters
 */
function buildCountQuery(tableName, filters = {}) {
  // Escape table name
  const escapedTableName = escapeIdentifier(tableName);
  
  // Build base query
  let sql = `SELECT COUNT(*) as count FROM ${escapedTableName}`;
  const params = [];
  
  // Add WHERE clause if filter is provided
  if (filters && Object.keys(filters).length > 0) {
    const whereClause = parseFilters(filters);
    if (whereClause.where !== '1=1') {
      sql += ` WHERE ${whereClause.where}`;
      params.push(...whereClause.params);
    }
  }
  
  return {
    sql,
    params
  };
}

/**
 * Build an aggregation query (for charts/visualizations)
 * @param {string} tableName - Table name
 * @param {Object} options - Aggregation options
 * @returns {Object} SQL query and parameters
 */
function buildAggregationQuery(tableName, options) {
  // Escape table name
  const escapedTableName = escapeIdentifier(tableName);
  
  // Prepare columns for SELECT
  let selectColumns = [];
  
  if (options.aggregations && Array.isArray(options.aggregations)) {
    // Process aggregation functions (COUNT, SUM, AVG, etc.)
    options.aggregations.forEach(agg => {
      if (agg.function && agg.column) {
        const func = agg.function.toUpperCase();
        const col = escapeIdentifier(agg.column);
        const alias = agg.alias ? ` AS ${escapeIdentifier(agg.alias)}` : '';
        
        // Only allow certain aggregation functions for security
        if (['COUNT', 'SUM', 'AVG', 'MIN', 'MAX'].includes(func)) {
          // Handle COUNT(DISTINCT x) case
          if (func === 'COUNT' && agg.distinct) {
            selectColumns.push(`COUNT(DISTINCT ${col})${alias}`);
          } else {
            selectColumns.push(`${func}(${col})${alias}`);
          }
        }
      }
    });
  }
  
  // Handle regular columns (typically for GROUP BY)
  if (options.columns && Array.isArray(options.columns)) {
    options.columns.forEach(col => {
      if (typeof col === 'string') {
        selectColumns.push(escapeIdentifier(col));
      } else if (col.column) {
        const colName = escapeIdentifier(col.column);
        const alias = col.alias ? ` AS ${escapeIdentifier(col.alias)}` : '';
        selectColumns.push(`${colName}${alias}`);
      }
    });
  }
  
  // If no columns specified, use wildcard
  if (selectColumns.length === 0) {
    selectColumns = ['*'];
  }
  
  // Build base query
  let sql = `SELECT ${selectColumns.join(', ')} FROM ${escapedTableName}`;
  const params = [];
  
  // Add WHERE clause if filter is provided
  if (options.filter) {
    const whereClause = parseFilters(options.filter);
    if (whereClause.where !== '1=1') {
      sql += ` WHERE ${whereClause.where}`;
      params.push(...whereClause.params);
    }
  }
  
  // Add GROUP BY clause if groupBy is provided
  if (options.groupBy) {
    if (Array.isArray(options.groupBy)) {
      sql += ` GROUP BY ${options.groupBy.map(escapeIdentifier).join(', ')}`;
    } else {
      sql += ` GROUP BY ${escapeIdentifier(options.groupBy)}`;
    }
  }
  
  // Add HAVING clause if having is provided
  if (options.having) {
    const havingClause = parseFilters(options.having);
    if (havingClause.where !== '1=1') {
      sql += ` HAVING ${havingClause.where}`;
      params.push(...havingClause.params);
    }
  }
  
  // Add ORDER BY clause if sort is provided
  if (options.sort) {
    sql += ` ${buildOrderByClause(options.sort)}`;
  }
  
  // Add LIMIT clause if limit is provided
  if (options.limit) {
    sql += ` LIMIT ?`;
    params.push(options.limit);
  }
  
  return {
    sql,
    params
  };
}

/**
 * Parse filter conditions with support for complex queries
 * @param {Object} filters - Filter conditions
 * @returns {Object} WHERE clause and parameters
 */
function parseFilters(filters) {
  let where = '';
  const params = [];
  
  // Handle null, undefined, or empty filters
  if (!filters || Object.keys(filters).length === 0) {
    return { where: '1=1', params: [] };
  }
  
  // Parse JSON string if string is provided
  let parsedFilters = filters;
  if (typeof filters === 'string') {
    try {
      parsedFilters = JSON.parse(filters);
    } catch (error) {
      console.error('Failed to parse filter string:', error);
      return { where: '1=1', params: [] };
    }
  }
  
  // Special handling for complex operators
  if (parsedFilters.$and || parsedFilters.$or) {
    if (parsedFilters.$and && Array.isArray(parsedFilters.$and)) {
      const conditions = parsedFilters.$and.map(filter => {
        const parsed = parseFilters(filter);
        params.push(...parsed.params);
        return `(${parsed.where})`;
      });
      where = conditions.join(' AND ');
    } else if (parsedFilters.$or && Array.isArray(parsedFilters.$or)) {
      const conditions = parsedFilters.$or.map(filter => {
        const parsed = parseFilters(filter);
        params.push(...parsed.params);
        return `(${parsed.where})`;
      });
      where = conditions.join(' OR ');
    }
  } else {
    // Handle regular field filters
    const conditions = [];
    
    for (const [field, value] of Object.entries(parsedFilters)) {
      // Skip special operators (already handled above)
      if (field.startsWith('$')) continue;
      
      // Validate field name for security
      if (!isValidIdentifier(field)) {
        console.warn(`Skipping invalid field name in filter: ${field}`);
        continue;
      }
      
      // Escape field name
      const escapedField = escapeIdentifier(field);
      
      // Complex comparison operators
      if (value !== null && typeof value === 'object') {
        for (const [op, opValue] of Object.entries(value)) {
          switch (op) {
            case '$eq':
              conditions.push(`${escapedField} = ?`);
              params.push(opValue);
              break;
            case '$ne':
              conditions.push(`${escapedField} != ?`);
              params.push(opValue);
              break;
            case '$gt':
              conditions.push(`${escapedField} > ?`);
              params.push(opValue);
              break;
            case '$gte':
              conditions.push(`${escapedField} >= ?`);
              params.push(opValue);
              break;
            case '$lt':
              conditions.push(`${escapedField} < ?`);
              params.push(opValue);
              break;
            case '$lte':
              conditions.push(`${escapedField} <= ?`);
              params.push(opValue);
              break;
            case '$like':
              conditions.push(`${escapedField} LIKE ?`);
              params.push(`%${opValue}%`);
              break;
            case '$starts':
              conditions.push(`${escapedField} LIKE ?`);
              params.push(`${opValue}%`);
              break;
            case '$ends':
              conditions.push(`${escapedField} LIKE ?`);
              params.push(`%${opValue}`);
              break;
            case '$regex':
              // SQLite doesn't have native regex, use LIKE with % for basic pattern matching
              // For actual regex, consider using REGEXP function if available
              console.warn('$regex is not fully supported in SQLite, converting to LIKE pattern');
              conditions.push(`${escapedField} LIKE ?`);
              params.push(`%${opValue}%`);
              break;
            case '$in':
              if (Array.isArray(opValue) && opValue.length > 0) {
                conditions.push(`${escapedField} IN (${opValue.map(() => '?').join(', ')})`);
                params.push(...opValue);
              } else {
                conditions.push('0=1'); // Empty IN clause should return false
              }
              break;
            case '$nin':
              if (Array.isArray(opValue) && opValue.length > 0) {
                conditions.push(`${escapedField} NOT IN (${opValue.map(() => '?').join(', ')})`);
                params.push(...opValue);
              } else {
                conditions.push('1=1'); // Empty NOT IN clause should return true
              }
              break;
            case '$exists':
              conditions.push(opValue ? `${escapedField} IS NOT NULL` : `${escapedField} IS NULL`);
              break;
            case '$between':
              if (Array.isArray(opValue) && opValue.length === 2) {
                conditions.push(`${escapedField} BETWEEN ? AND ?`);
                params.push(opValue[0], opValue[1]);
              }
              break;
            case '$contains':
              // For JSON containment or text search
              conditions.push(`${escapedField} LIKE ?`);
              params.push(`%${opValue}%`);
              break;
            case '$search':
              // For full-text search - simplified as SQLite may not have FTS
              conditions.push(`${escapedField} LIKE ?`);
              params.push(`%${opValue}%`);
              break;
            default:
              // Unknown operator, ignore it
              console.warn(`Unknown operator in filter: ${op}`);
              break;
          }
        }
      } else {
        // Simple equality comparison
        if (value === null) {
          conditions.push(`${escapedField} IS NULL`);
        } else {
          conditions.push(`${escapedField} = ?`);
          params.push(value);
        }
      }
    }
    
    // Join all conditions with AND
    where = conditions.length > 0 ? conditions.join(' AND ') : '1=1';
  }
  
  return { where, params };
}

/**
 * Build ORDER BY clause
 * @param {Object|Array} sort - Sort conditions
 * @returns {string} ORDER BY clause
 */
function buildOrderByClause(sort) {
  if (!sort) return '';
  
  // Parse JSON string if string is provided
  let parsedSort = sort;
  if (typeof sort === 'string') {
    try {
      parsedSort = JSON.parse(sort);
    } catch (error) {
      console.error('Failed to parse sort string:', error);
      return '';
    }
  }
  
  // Handle array of sort configs
  if (Array.isArray(parsedSort)) {
    const sortClauses = parsedSort.map(s => {
      if (!s || (!s.column && !s.field)) return null;
      
      const field = s.column || s.field;
      
      // Validate field name for security
      if (!isValidIdentifier(field)) {
        console.warn(`Skipping invalid field name in sort: ${field}`);
        return null;
      }
      
      const escapedField = escapeIdentifier(field);
      const direction = (s.direction || 'asc').toUpperCase();
      if (direction !== 'ASC' && direction !== 'DESC') {
        return `${escapedField} ASC`;
      }
      return `${escapedField} ${direction}`;
    }).filter(Boolean);
    
    if (sortClauses.length === 0) {
      return '';
    }
    
    return `ORDER BY ${sortClauses.join(', ')}`;
  }
  
  // Handle single sort config
  const field = parsedSort.column || parsedSort.field;
  if (!field || !isValidIdentifier(field)) {
    console.warn(`Invalid or missing field name in sort: ${field}`);
    return '';
  }
  
  const escapedField = escapeIdentifier(field);
  const direction = (parsedSort.direction || 'asc').toUpperCase();
  if (direction !== 'ASC' && direction !== 'DESC') {
    return `ORDER BY ${escapedField} ASC`;
  }
  
  return `ORDER BY ${escapedField} ${direction}`;
}

/**
 * Build LIMIT/OFFSET clause
 * @param {number} page - Page number
 * @param {number} limit - Items per page
 * @returns {Object} SQL clause and parameters
 */
function buildPaginationClause(page, limit) {
  // Ensure page and limit are positive integers
  const safePage = Math.max(parseInt(page) || 1, 1);
  const safeLimit = Math.max(parseInt(limit) || 100, 1);
  
  const offset = (safePage - 1) * safeLimit;
  return {
    sql: 'LIMIT ? OFFSET ?',
    params: [safeLimit, offset]
  };
}

/**
 * Escape SQL identifier (table name, column name, etc.)
 * @param {string} identifier - SQL identifier
 * @returns {string} Escaped identifier
 */
function escapeIdentifier(identifier) {
  // Skip * wildcard
  if (identifier === '*') return '*';
  
  // Handle function calls and expressions
  if (typeof identifier === 'string' && 
      (identifier.includes('(') && identifier.includes(')'))) {
    return identifier;
  }
  
  // Validate identifier
  if (!isValidIdentifier(identifier)) {
    throw new Error(`Invalid SQL identifier: ${identifier}`);
  }
  
  // Simple identifier
  return `"${identifier.replace(/"/g, '""')}"`;
}

/**
 * Validate SQL identifier for security
 * @param {string} identifier - SQL identifier to validate
 * @returns {boolean} True if valid
 */
function isValidIdentifier(identifier) {
  if (typeof identifier !== 'string') return false;
  
  // Allowed characters: letters, numbers, underscore
  // Must start with letter or underscore
  return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(identifier);
}

/**
 * Build a query to find specific text across multiple columns
 * @param {string} tableName - Table name 
 * @param {Array} columns - Columns to search in
 * @param {string} searchText - Text to search for
 * @param {Object} options - Additional options (pagination, sort)
 * @returns {Object} SQL query and parameters
 */
function buildTextSearchQuery(tableName, columns, searchText, options = {}) {
  // Escape table name
  const escapedTableName = escapeIdentifier(tableName);
  
  // Validate columns
  const validColumns = columns.filter(col => isValidIdentifier(col))
                              .map(escapeIdentifier);
  
  if (validColumns.length === 0) {
    throw new Error('No valid columns provided for text search');
  }
  
  // Default options
  const page = options.page || 1;
  const limit = options.limit || 100;
  
  // Build search conditions for each column
  const searchConditions = validColumns.map(col => `${col} LIKE ?`);
  
  // Parameters for LIKE conditions
  const searchParams = Array(validColumns.length).fill(`%${searchText}%`);
  
  // Build base query
  let sql = `SELECT * FROM ${escapedTableName} WHERE (${searchConditions.join(' OR ')})`;
  const params = [...searchParams];
  
  // Add additional filters if provided
  if (options.filter) {
    const whereClause = parseFilters(options.filter);
    if (whereClause.where !== '1=1') {
      sql += ` AND (${whereClause.where})`;
      params.push(...whereClause.params);
    }
  }
  
  // Add ORDER BY clause if sort is provided
  if (options.sort) {
    sql += ` ${buildOrderByClause(options.sort)}`;
  }
  
  // Add pagination
  const pagination = buildPaginationClause(page, limit);
  sql += ` ${pagination.sql}`;
  params.push(...pagination.params);
  
  return {
    sql,
    params
  };
}

/**
 * Build a date range query
 * @param {string} tableName - Table name
 * @param {string} dateColumn - Date column name
 * @param {string|Date} startDate - Start date
 * @param {string|Date} endDate - End date
 * @param {Object} options - Additional options
 * @returns {Object} SQL query and parameters
 */
function buildDateRangeQuery(tableName, dateColumn, startDate, endDate, options = {}) {
  // Escape table name
  const escapedTableName = escapeIdentifier(tableName);
  
  // Validate date column
  if (!isValidIdentifier(dateColumn)) {
    throw new Error(`Invalid date column name: ${dateColumn}`);
  }
  
  const escapedDateColumn = escapeIdentifier(dateColumn);
  
  // Default options
  const page = options.page || 1;
  const limit = options.limit || 100;
  
  // Convert dates to strings if they are Date objects
  const start = startDate instanceof Date ? startDate.toISOString() : startDate;
  const end = endDate instanceof Date ? endDate.toISOString() : endDate;
  
  // Build base query
  let sql = `SELECT * FROM ${escapedTableName} WHERE `;
  const params = [];
  
  // Add date range conditions
  if (start && end) {
    sql += `${escapedDateColumn} BETWEEN ? AND ?`;
    params.push(start, end);
  } else if (start) {
    sql += `${escapedDateColumn} >= ?`;
    params.push(start);
  } else if (end) {
    sql += `${escapedDateColumn} <= ?`;
    params.push(end);
  } else {
    // No date range specified, return all records
    sql += '1=1';
  }
  
  // Add additional filters if provided
  if (options.filter) {
    const whereClause = parseFilters(options.filter);
    if (whereClause.where !== '1=1') {
      sql += ` AND (${whereClause.where})`;
      params.push(...whereClause.params);
    }
  }
  
  // Add ORDER BY clause
  // Default to sort by date column if no sort is provided
  if (options.sort) {
    sql += ` ${buildOrderByClause(options.sort)}`;
  } else {
    sql += ` ORDER BY ${escapedDateColumn} ASC`;
  }
  
  // Add pagination
  const pagination = buildPaginationClause(page, limit);
  sql += ` ${pagination.sql}`;
  params.push(...pagination.params);
  
  return {
    sql,
    params
  };
}

/**
 * Build a sample query to get a representative sample of data
 * @param {string} tableName - Table name
 * @param {number} sampleSize - Number of rows to sample
 * @param {Object} options - Additional options
 * @returns {Object} SQL query and parameters
 */
function buildSampleQuery(tableName, sampleSize = 10, options = {}) {
  // Escape table name
  const escapedTableName = escapeIdentifier(tableName);
  
  // Ensure sample size is reasonable
  const safeSampleSize = Math.min(Math.max(parseInt(sampleSize) || 10, 1), 1000);
  
  // Default columns to select
  const columns = options.columns ? options.columns.filter(col => isValidIdentifier(col))
                                                   .map(escapeIdentifier)
                                  : ['*'];
  
  // Build base query - Use SQLite random() function for sampling
  let sql = `SELECT ${columns.join(', ')} FROM ${escapedTableName}`;
  const params = [];
  
  // Add filter conditions if provided
  if (options.filter) {
    const whereClause = parseFilters(options.filter);
    if (whereClause.where !== '1=1') {
      sql += ` WHERE ${whereClause.where}`;
      params.push(...whereClause.params);
    }
  }
  
  // Add random sampling
  sql += ` ORDER BY RANDOM() LIMIT ?`;
  params.push(safeSampleSize);
  
  return {
    sql,
    params
  };
}

/**
 * Parse a raw filter input from API to correct filter object
 * @param {string|Object} filter - Raw filter input
 * @returns {Object} Parsed filter object
 */
function parseRawFilter(filter) {
  if (!filter) return {};
  
  // If it's already an object, return it
  if (typeof filter === 'object' && !Array.isArray(filter)) {
    return filter;
  }
  
  // If it's a string, try to parse it as JSON
  if (typeof filter === 'string') {
    try {
      return JSON.parse(filter);
    } catch (error) {
      console.error('Failed to parse filter string:', error);
      return {};
    }
  }
  
  // Otherwise, return empty filter
  return {};
}

/**
 * Parse a raw sort input from API to correct sort object
 * @param {string|Object|Array} sort - Raw sort input
 * @returns {Object|Array} Parsed sort object
 */
function parseRawSort(sort) {
  if (!sort) return null;
  
  // If it's already an object or array, return it
  if (typeof sort === 'object') {
    return sort;
  }
  
  // If it's a string, try to parse it as JSON
  if (typeof sort === 'string') {
    try {
      return JSON.parse(sort);
    } catch (error) {
      // If it's not JSON, it might be a simple column name
      if (isValidIdentifier(sort)) {
        return { column: sort, direction: 'asc' };
      }
      
      // If it includes a space, it might be "column direction"
      const parts = sort.split(/\s+/);
      if (parts.length === 2 && isValidIdentifier(parts[0])) {
        const direction = parts[1].toLowerCase();
        if (direction === 'asc' || direction === 'desc') {
          return { column: parts[0], direction };
        }
      }
      
      console.error('Failed to parse sort string:', error);
      return null;
    }
  }
  
  // Otherwise, return null
  return null;
}

/**
 * Build a JOIN query to get data from multiple related tables
 * @param {string} mainTable - Main table name
 * @param {Array} joins - Join configurations
 * @param {Object} options - Additional options
 * @returns {Object} SQL query and parameters
 */
function buildJoinQuery(mainTable, joins, options = {}) {
  // Escape main table name
  const escapedMainTable = escapeIdentifier(mainTable);
  
  // Default options
  const page = options.page || 1;
  const limit = options.limit || 100;
  
  // Default columns to select from main table
  const mainTablePrefix = options.tableAliases && options.tableAliases[mainTable] 
    ? options.tableAliases[mainTable] 
    : mainTable;
    
  let selectCols = options.columns && Array.isArray(options.columns) 
    ? options.columns.map(col => {
        // If column is already fully qualified
        if (col.includes('.')) return escapeIdentifier(col);
        // Otherwise qualify with main table
        return `${escapeIdentifier(mainTablePrefix)}.${escapeIdentifier(col)}`;
      })
    : [`${escapeIdentifier(mainTablePrefix)}.*`];
  
  // Build base query
  let sql = `SELECT ${selectCols.join(', ')} FROM ${escapedMainTable}`;
  
  // Add table alias if provided
  if (options.tableAliases && options.tableAliases[mainTable]) {
    sql += ` AS ${escapeIdentifier(options.tableAliases[mainTable])}`;
  }
  
  const params = [];
  
  // Add joins
  if (joins && Array.isArray(joins)) {
    joins.forEach(join => {
      if (!join.table || !join.on) return;
      
      const joinType = (join.type || 'INNER').toUpperCase();
      if (!['INNER', 'LEFT', 'RIGHT', 'FULL'].includes(joinType)) {
        console.warn(`Invalid join type: ${join.type}, defaulting to INNER`);
        join.type = 'INNER';
      }
      
      const escapedJoinTable = escapeIdentifier(join.table);
      const joinTableAlias = options.tableAliases && options.tableAliases[join.table]
        ? ` AS ${escapeIdentifier(options.tableAliases[join.table])}`
        : '';
      
      sql += ` ${joinType} JOIN ${escapedJoinTable}${joinTableAlias} ON ${join.on}`;
    });
  }
  
  // Add WHERE clause if filter is provided
  if (options.filter) {
    const whereClause = parseFilters(options.filter);
    if (whereClause.where !== '1=1') {
      sql += ` WHERE ${whereClause.where}`;
      params.push(...whereClause.params);
    }
  }
  
  // Add GROUP BY clause if groupBy is provided
  if (options.groupBy) {
    if (Array.isArray(options.groupBy)) {
      sql += ` GROUP BY ${options.groupBy.map(escapeIdentifier).join(', ')}`;
    } else {
      sql += ` GROUP BY ${escapeIdentifier(options.groupBy)}`;
    }
  }
  
  // Add HAVING clause if having is provided
  if (options.having) {
    const havingClause = parseFilters(options.having);
    if (havingClause.where !== '1=1') {
      sql += ` HAVING ${havingClause.where}`;
      params.push(...havingClause.params);
    }
  }
  
  // Add ORDER BY clause if sort is provided
  if (options.sort) {
    sql += ` ${buildOrderByClause(options.sort)}`;
  }
  
  // Add pagination
  const pagination = buildPaginationClause(page, limit);
  sql += ` ${pagination.sql}`;
  params.push(...pagination.params);
  
  return {
    sql,
    params
  };
}

/**
 * Get list of operators supported by the query builder
 * For documentation and UI hints
 * @returns {Object} Supported operators and their descriptions
 */
function getSupportedOperators() {
  return {
    // Comparison operators
    '$eq': 'Equal to',
    '$ne': 'Not equal to',
    '$gt': 'Greater than',
    '$gte': 'Greater than or equal to',
    '$lt': 'Less than',
    '$lte': 'Less than or equal to',
    
    // String operators
    '$like': 'Contains substring (case sensitive)',
    '$starts': 'Starts with',
    '$ends': 'Ends with',
    '$contains': 'Contains substring (alias for $like)',
    
    // Array operators
    '$in': 'Value is in array',
    '$nin': 'Value is not in array',
    
    // Range operator
    '$between': 'Value is between two values',
    
    // Existence operator
    '$exists': 'Field exists (true) or does not exist (false)',
    
    // Search operator
    '$search': 'Full text search (similar to $like)',
    
    // Logic operators
    '$and': 'Logical AND of multiple conditions',
    '$or': 'Logical OR of multiple conditions'
  };
}

module.exports = {
  buildPaginatedSelectQuery,
  buildCountQuery,
  buildAggregationQuery,
  parseFilters,
  buildOrderByClause,
  buildPaginationClause,
  escapeIdentifier,
  isValidIdentifier,
  buildTextSearchQuery,
  buildDateRangeQuery,
  buildSampleQuery,
  parseRawFilter,
  parseRawSort,
  buildJoinQuery,
  getSupportedOperators
};
</file>

<file path="package.json">
{
  "name": "sqlite-visualizer",
  "version": "0.1.0",
  "description": "A web application that visualizes SQLite database content for easy data exploration",
  "main": "server/app.js",
  "scripts": {
    "start": "node server/app.js",
    "dev": "concurrently \"npm run dev:server\" \"npm run dev:client\"",
    "dev:server": "nodemon server/app.js",
    "dev:client": "cd client && npm run dev",
    "build": "cd client && npm run build",
    "setup-db": "node scripts/setup-db.js",
    "test": "echo \"Error: no test specified\" && exit 1",
    "stop": "node scripts/stop-processes.js"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@tailwindcss/forms": "^0.5.10",
    "better-sqlite3": "^8.7.0",
    "cors": "^2.8.5",
    "date-fns": "^4.1.0",
    "express": "^4.18.2",
    "helmet": "^7.0.0",
    "joi": "^17.13.3",
    "morgan": "^1.10.0",
    "react-hot-toast": "^2.5.2"
  },
  "devDependencies": {
    "concurrently": "^8.2.0",
    "find-process": "^1.4.10",
    "nodemon": "^3.0.1",
    "ps-node": "^0.1.6"
  }
}
</file>

<file path="client/src/components/visualization/ChartRenderer.tsx">
import { FC, useRef, useEffect, useState } from 'react';
import Chart from 'chart.js/auto';
import { ChartData } from '../../types';
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  BarElement,
  ArcElement,
  Title,
  Tooltip,
  Legend,
  Filler,
  ChartOptions
} from 'chart.js';

// Register required Chart.js components
ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  BarElement,
  ArcElement,
  Title,
  Tooltip,
  Legend,
  Filler
);

// Valid chart types
export type ChartType = 'bar' | 'line' | 'pie' | 'doughnut' | 'scatter' | 'radar' | 'polarArea';

interface ChartRendererProps {
  type: ChartType;
  data: ChartData;
  title?: string;
  height?: string | number;
  width?: string | number;
  customOptions?: any;
}

/**
 * Chart Renderer Component
 * 
 * Renders various types of charts using Chart.js with optimized configuration
 * for each chart type based on the application's style guide.
 */
const ChartRenderer: FC<ChartRendererProps> = ({
  type,
  data,
  title,
  height = '100%',
  width = '100%',
  customOptions = {}
}) => {
  const chartRef = useRef<HTMLCanvasElement>(null);
  const chartInstance = useRef<Chart | null>(null);
  const [error, setError] = useState<string | null>(null);
  
  // Style guide colors
  const baseColors = [
    '#2563EB', // blue-600
    '#D946EF', // fuchsia-500
    '#F59E0B', // amber-500
    '#10B981', // emerald-500
    '#6366F1', // indigo-500
    '#EF4444', // red-500
    '#8B5CF6', // violet-500
    '#EC4899', // pink-500
    '#06B6D4', // cyan-500
    '#84CC16'  // lime-500
  ];
  
  // Validate and parse chart type
  const getChartType = (chartType: string): Chart.ChartType => {
    const validTypes: Record<string, Chart.ChartType> = {
      bar: 'bar',
      line: 'line',
      pie: 'pie',
      doughnut: 'doughnut',
      scatter: 'scatter',
      radar: 'radar',
      polarArea: 'polarArea'
    };
    
    const normalizedType = chartType.toLowerCase();
    if (normalizedType in validTypes) {
      return validTypes[normalizedType];
    }
    
    console.warn(`Unsupported chart type: ${chartType}, defaulting to bar`);
    setError(`Unsupported chart type: ${chartType}`);
    return 'bar';
  };
  
  // Apply style based on chart type
  const getStyleForChartType = (chartType: ChartType, chartData: ChartData) => {
    const defaultColors = baseColors.slice(0, Math.max(chartData.datasets.length, chartData.labels.length));
    
    // Common styling for all chart types
    let styledData: ChartData = {
      ...chartData,
      datasets: chartData.datasets.map((dataset, index) => {
        // For simplicity, ensure backgroundColor and borderColor are always arrays
        const color = Array.isArray(defaultColors) ? defaultColors[index % defaultColors.length] : defaultColors;
        
        return {
          ...dataset
        };
      })
    };
    
    // Apply chart-type specific styling
    switch (chartType) {
      case 'bar':
        styledData.datasets = styledData.datasets.map((dataset, index) => ({
          ...dataset,
          backgroundColor: dataset.backgroundColor || defaultColors,
          borderColor: dataset.borderColor || defaultColors,
          borderWidth: dataset.borderWidth !== undefined ? dataset.borderWidth : 0,
          borderRadius: 4,
          maxBarThickness: 40
        }));
        break;
        
      case 'line':
        styledData.datasets = styledData.datasets.map((dataset, index) => {
          // For line charts, we typically want a single color per dataset
          const color = defaultColors[index % defaultColors.length];
          
          return {
            ...dataset,
            backgroundColor: dataset.backgroundColor || `${color}33`, // Add 20% opacity to color
            borderColor: dataset.borderColor || color,
            borderWidth: dataset.borderWidth !== undefined ? dataset.borderWidth : 2,
            tension: 0.2, // Slight curve for lines
            fill: true
          };
        });
        break;
        
      case 'pie':
      case 'doughnut':
        styledData.datasets = styledData.datasets.map((dataset) => ({
          ...dataset,
          backgroundColor: dataset.backgroundColor || defaultColors.slice(0, chartData.labels.length),
          borderColor: dataset.borderColor || '#FFFFFF',
          borderWidth: dataset.borderWidth !== undefined ? dataset.borderWidth : 2
        }));
        break;
        
      case 'scatter':
        styledData.datasets = styledData.datasets.map((dataset, index) => {
          const color = defaultColors[index % defaultColors.length];
          
          return {
            ...dataset,
            backgroundColor: dataset.backgroundColor || color,
            borderColor: dataset.borderColor || color,
            borderWidth: dataset.borderWidth !== undefined ? dataset.borderWidth : 1,
            radius: 5,
            pointHoverRadius: 7
          };
        });
        break;
        
      case 'radar':
        styledData.datasets = styledData.datasets.map((dataset, index) => {
          const color = defaultColors[index % defaultColors.length];
          
          return {
            ...dataset,
            backgroundColor: dataset.backgroundColor || `${color}33`, // Add 20% opacity
            borderColor: dataset.borderColor || color,
            borderWidth: dataset.borderWidth !== undefined ? dataset.borderWidth : 2,
            pointBackgroundColor: color
          };
        });
        break;
        
      case 'polarArea':
        styledData.datasets = styledData.datasets.map((dataset) => ({
          ...dataset,
          backgroundColor: dataset.backgroundColor || defaultColors.slice(0, chartData.labels.length).map(color => `${color}CC`), // Add 80% opacity
          borderColor: dataset.borderColor || '#FFFFFF',
          borderWidth: dataset.borderWidth !== undefined ? dataset.borderWidth : 1
        }));
        break;
    }
    
    return styledData;
  };
  
  // Get chart options based on type
  const getOptionsForChartType = (chartType: ChartType): ChartOptions<any> => {
    // Common options for all chart types
    const commonOptions: ChartOptions<any> = {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          position: 'bottom',
          labels: {
            boxWidth: 12,
            padding: 15,
            font: {
              family: "'Inter', sans-serif",
              size: 12
            },
            color: '#64748B' // slate-500
          }
        },
        tooltip: {
          backgroundColor: '#0F172A', // slate-900
          titleColor: '#FFFFFF',
          bodyColor: '#FFFFFF',
          padding: 12,
          cornerRadius: 4,
          titleFont: {
            weight: 'medium',
            family: "'Inter', sans-serif"
          },
          bodyFont: {
            family: "'Inter', sans-serif"
          }
        },
        title: {
          display: !!title,
          text: title || '',
          font: {
            weight: 'medium',
            size: 16,
            family: "'Inter', sans-serif"
          },
          color: '#0F172A', // slate-900
          padding: {
            bottom: 16
          }
        }
      }
    };
    
    // Chart-type specific options
    switch (chartType) {
      case 'bar':
        return {
          ...commonOptions,
          scales: {
            y: {
              beginAtZero: true,
              ticks: {
                font: {
                  family: "'Inter', sans-serif"
                },
                color: '#64748B' // slate-500
              },
              grid: {
                color: '#E2E8F0' // slate-200
              }
            },
            x: {
              ticks: {
                font: {
                  family: "'Inter', sans-serif"
                },
                color: '#64748B' // slate-500
              },
              grid: {
                display: false
              }
            }
          }
        };
        
      case 'line':
        return {
          ...commonOptions,
          scales: {
            y: {
              beginAtZero: true,
              ticks: {
                font: {
                  family: "'Inter', sans-serif"
                },
                color: '#64748B' // slate-500
              },
              grid: {
                color: '#E2E8F0' // slate-200
              }
            },
            x: {
              ticks: {
                font: {
                  family: "'Inter', sans-serif"
                },
                color: '#64748B' // slate-500
              },
              grid: {
                color: '#E2E8F0' // slate-200
              }
            }
          },
          elements: {
            line: {
              tension: 0.2
            },
            point: {
              radius: 3,
              hoverRadius: 5
            }
          }
        };
        
      case 'pie':
      case 'doughnut':
        return {
          ...commonOptions,
          cutout: chartType === 'doughnut' ? '50%' : undefined
        };
        
      case 'scatter':
        return {
          ...commonOptions,
          scales: {
            y: {
              ticks: {
                font: {
                  family: "'Inter', sans-serif"
                },
                color: '#64748B' // slate-500
              },
              grid: {
                color: '#E2E8F0' // slate-200
              }
            },
            x: {
              ticks: {
                font: {
                  family: "'Inter', sans-serif"
                },
                color: '#64748B' // slate-500
              },
              grid: {
                color: '#E2E8F0' // slate-200
              }
            }
          }
        };
        
      case 'radar':
        return {
          ...commonOptions,
          scales: {
            r: {
              angleLines: {
                color: '#E2E8F0' // slate-200
              },
              grid: {
                color: '#E2E8F0' // slate-200
              },
              pointLabels: {
                font: {
                  family: "'Inter', sans-serif"
                },
                color: '#64748B' // slate-500
              },
              ticks: {
                backdropColor: 'transparent',
                color: '#64748B' // slate-500
              }
            }
          },
          elements: {
            line: {
              borderWidth: 2
            },
            point: {
              radius: 3,
              hoverRadius: 5
            }
          }
        };
        
      case 'polarArea':
        return {
          ...commonOptions,
          scales: {
            r: {
              beginAtZero: true,
              ticks: {
                backdropColor: 'transparent',
                color: '#64748B' // slate-500
              },
              grid: {
                color: '#E2E8F0' // slate-200
              }
            }
          }
        };
        
      default:
        return commonOptions;
    }
  };
  
  useEffect(() => {
    // Clear any previous errors
    setError(null);
    
    // Validate data
    if (!data || !data.datasets || data.datasets.length === 0) {
      setError('No data available for chart');
      return;
    }
    
    // Get chart canvas context
    if (!chartRef.current) return;
    const ctx = chartRef.current.getContext('2d');
    if (!ctx) return;
    
    // Clean up existing chart
    if (chartInstance.current) {
      chartInstance.current.destroy();
    }
    
    try {
      // Get Chart.js chart type
      const chartType = getChartType(type);
      
      // Apply styling and options
      const styledData = getStyleForChartType(type as ChartType, data);
      const chartOptions = {
        ...getOptionsForChartType(type as ChartType),
        ...customOptions
      };
      
      // Create chart
      chartInstance.current = new Chart(ctx, {
        type: chartType,
        data: styledData,
        options: chartOptions
      });
    } catch (err) {
      console.error('Error creating chart:', err);
      setError(err instanceof Error ? err.message : 'Error creating chart');
    }
    
    // Clean up on unmount
    return () => {
      if (chartInstance.current) {
        chartInstance.current.destroy();
      }
    };
  }, [type, data, title, customOptions]);
  
  if (error) {
    return (
      <div className="flex items-center justify-center h-full bg-red-50 border border-red-200 rounded p-4">
        <p className="text-sm text-red-700">{error}</p>
      </div>
    );
  }
  
  if (!data || !data.datasets || data.datasets.length === 0) {
    return (
      <div className="flex items-center justify-center h-full bg-slate-50 border border-slate-200 rounded p-4">
        <p className="text-sm text-slate-500">No data available</p>
      </div>
    );
  }
  
  return (
    <div style={{ width, height }} className="relative">
      <canvas ref={chartRef} />
    </div>
  );
};

export default ChartRenderer;
</file>

<file path="server/routes/tables.js">
/**
 * Tables Route Handler
 * 
 * Handles all API endpoints related to database tables
 */

const express = require('express');
const router = express.Router({ mergeParams: true });
const connectionService = require('../services/connectionService');
const databaseService = require('../services/databaseService');
const queryBuilder = require('../utils/queryBuilder');
const dbUtils = require('../utils/dbUtils');
const { validateParams, validateQuery, schemas } = require('../middleware/dataValidator');
const Joi = require('joi');

// Table name parameter validation schema
const tableNameSchema = Joi.object({
  table: Joi.string().pattern(/^[a-zA-Z0-9_]+$/).required()
    .messages({
      'string.pattern.base': 'Table name contains invalid characters'
    }),
  id: Joi.number().integer().positive().required()
    .messages({
      'number.base': 'Connection ID must be a number',
      'number.integer': 'Connection ID must be an integer',
      'number.positive': 'Connection ID must be positive'
    })
});

// Sample data query schema
const sampleQuerySchema = Joi.object({
  limit: Joi.number().integer().min(1).max(100).default(10)
    .messages({
      'number.base': 'Limit must be a number',
      'number.integer': 'Limit must be an integer',
      'number.min': 'Limit must be at least 1',
      'number.max': 'Limit cannot exceed 100'
    })
});

// Enhanced table data query schema with advanced filtering
const tableDataQuerySchema = schemas.table.query.keys({
  filter: Joi.string().optional()
    .messages({
      'string.base': 'Filter must be a valid JSON string'
    }),
  sort: Joi.string().optional()
    .messages({
      'string.base': 'Sort must be a valid JSON string'
    }),
  search: Joi.string().optional()
    .messages({
      'string.base': 'Search must be a text string'
    }),
  searchColumns: Joi.string().optional()
    .messages({
      'string.base': 'Search columns must be a comma-separated list or JSON array'
    }),
  dateRange: Joi.string().optional()
    .messages({
      'string.base': 'Date range must be a valid JSON object with start and end properties'
    }),
  dateColumn: Joi.string().optional()
    .messages({
      'string.base': 'Date column must be a valid column name'
    })
});

/**
 * GET /api/connections/:id/tables
 * List all tables in the database
 */
router.get('/', 
  validateParams(schemas.connection.id),
  async (req, res, next) => {
    const connectionId = req.params.id;
    console.log(`Requesting tables for connection ID: ${connectionId}`);

    // Set a timeout for this operation
    const timeoutId = setTimeout(() => {
      console.error(`Timeout retrieving tables for connection ${connectionId}`);
      if (!res.headersSent) {
        res.status(504).json({
          success: false,
          error: 'Request timeout',
          message: 'Retrieving tables took too long. The database may be too large or experiencing issues.'
        });
      }
    }, 30000); // 30 second timeout

    try {
      // Get database connection directly
      const db = await connectionService.getConnection(connectionId);
      
      if (!db) {
        clearTimeout(timeoutId);
        return res.status(404).json({ 
          success: false,
          error: 'Connection not found',
          message: `No valid connection found with ID: ${connectionId}`
        });
      }
      
      // Use synchronous API for better-sqlite3
      const tables = db.prepare(
        `SELECT name, type, sql as creation_sql
         FROM sqlite_master 
         WHERE type = 'table' AND name NOT LIKE 'sqlite_%'
         ORDER BY name`
      ).all();
      
      // Process each table to get row counts
      const tablesWithDetails = [];
      
      // Process up to 10 tables at a time to avoid overwhelming the database
      const processInBatches = async (items, batchSize, processFn) => {
        const results = [];
        for (let i = 0; i < items.length; i += batchSize) {
          const batch = items.slice(i, i + batchSize);
          const batchResults = await Promise.all(batch.map(processFn));
          results.push(...batchResults);
        }
        return results;
      };
      
      await processInBatches(tables, 5, async (table) => {
        if (!table || !table.name) {
          return null;
        }
        
        let rowCount = 0;
        try {
          // Use QueryBuilder for a clean count query
          const countQuery = queryBuilder.buildCountQuery(table.name);
          
          // Get approximate row count using synchronous API
          let countResult;
          try {
            countResult = db.prepare(countQuery.sql).get(...countQuery.params) || { count: 0 };
          } catch (err) {
            console.warn(`Error counting rows for ${table.name}: ${err.message}`);
            countResult = { count: 0 };
          }
          
          rowCount = countResult.count;
        } catch (error) {
          console.warn(`Error getting row count for ${table.name}: ${error.message}`);
        }
        
        tablesWithDetails.push({
          name: table.name,
          type: table.type,
          creation_sql: table.creation_sql,
          row_count: rowCount
        });
      });
      
      // Clear the timeout as we've completed the operation
      clearTimeout(timeoutId);
      
      // Return the results
      console.log(`Found ${tablesWithDetails.length} tables for connection ${connectionId}`);
      res.json({
        success: true,
        data: tablesWithDetails
      });
    } catch (error) {
      clearTimeout(timeoutId);
      console.error(`Error getting tables for connection ${connectionId}:`, error);
      
      if (!res.headersSent) {
        res.status(500).json({
          success: false,
          error: 'Failed to retrieve tables',
          message: error.message
        });
      }
    }
  }
);

/**
 * GET /api/connections/:id/tables/:table/schema
 * Get table schema
 */
router.get('/:table/schema', 
  validateParams(tableNameSchema),
  async (req, res, next) => {
    const { id, table } = req.params;
    
    try {
      // Get database connection directly
      const db = await connectionService.getConnection(id);
      
      if (!db) {
        return res.status(404).json({ 
          success: false,
          error: 'Connection not found',
          message: `No valid connection found with ID: ${id}`
        });
      }
      
      // Check if table exists using synchronous API
      const tableExists = db.prepare(
        `SELECT name FROM sqlite_master WHERE type='table' AND name=?`
      ).get(table) !== undefined;
      
      if (!tableExists) {
        return res.status(404).json({
          success: false,
          error: 'Table not found',
          message: `Table '${table}' does not exist in this database`
        });
      }
      
      // Get table schema using synchronous API
      let columns;
      try {
        columns = db.prepare(`PRAGMA table_info("${table}")`).all();
      } catch (err) {
        throw new Error(`Error getting column info: ${err.message}`);
      }
      
      // Get foreign key info
      let foreignKeys;
      try {
        foreignKeys = db.prepare(`PRAGMA foreign_key_list("${table}")`).all();
      } catch (err) {
        console.warn(`Error getting foreign keys for ${table}: ${err.message}`);
        foreignKeys = [];
      }
      
      // Get index info
      let indices;
      try {
        indices = db.prepare(`PRAGMA index_list("${table}")`).all();
      } catch (err) {
        console.warn(`Error getting indices for ${table}: ${err.message}`);
        indices = [];
      }
      
      // Process index details with synchronous API
      const indexDetails = indices.map((index) => {
        let columns;
        try {
          columns = db.prepare(`PRAGMA index_info("${index.name}")`).all();
        } catch (err) {
          console.warn(`Error getting index details for ${index.name}: ${err.message}`);
          columns = [];
        }
        
        return {
          ...index,
          columns: columns.map(col => ({
            name: col.name,
            position: col.seqno
          }))
        };
      });
      
      // Format the columns with additional info
      const formattedColumns = columns.map(column => {
        // Check if column is part of a primary key
        const isPrimaryKey = column.pk === 1;
        
        // Check if column is a foreign key
        const foreignKey = foreignKeys.find(fk => fk.from === column.name);
        
        // Parse the column type
        const typeInfo = dbUtils.parseColumnType(column.type);
        
        return {
          name: column.name,
          type: column.type,
          nullable: column.notnull === 0,
          defaultValue: column.dflt_value,
          primaryKey: isPrimaryKey,
          autoIncrement: isPrimaryKey && column.type.toUpperCase() === 'INTEGER',
          foreignKey: foreignKey ? {
            table: foreignKey.table,
            column: foreignKey.to
          } : null,
          ...typeInfo
        };
      });
      
      // Return the schema
      res.json({
        success: true,
        data: {
          name: table,
          columns: formattedColumns,
          primaryKey: formattedColumns.filter(col => col.primaryKey).map(col => col.name),
          foreignKeys: foreignKeys.map(fk => ({
            column: fk.from,
            referencedTable: fk.table,
            referencedColumn: fk.to,
            onUpdate: fk.on_update,
            onDelete: fk.on_delete
          })),
          indices: indexDetails
        }
      });
    } catch (error) {
      console.error(`Error getting schema for table ${table}:`, error);
      
      if (!res.headersSent) {
        res.status(500).json({
          success: false,
          error: 'Failed to retrieve table schema',
          message: error.message
        });
      }
    }
  }
);

/**
 * GET /api/connections/:id/tables/:table/data
 * Get table data (with pagination, filtering, sorting, and searching)
 */
router.get('/:table/data', 
  validateParams(tableNameSchema),
  validateQuery(tableDataQuerySchema),
  async (req, res, next) => {
    const { id, table } = req.params;
    const { 
      page = 1, 
      limit = 100, 
      sort: sortParam, 
      filter: filterParam,
      search,
      searchColumns,
      dateRange,
      dateColumn
    } = req.query;
    
    // Set a timeout for this operation
    const timeoutId = setTimeout(() => {
      console.error(`Timeout retrieving data for table ${table}`);
      if (!res.headersSent) {
        res.status(504).json({
          success: false,
          error: 'Request timeout',
          message: 'Retrieving table data took too long. Try a smaller page size or fewer filters.'
        });
      }
    }, 30000); // 30 second timeout
    
    try {
      // Get database connection directly
      const db = await connectionService.getConnection(id);
      
      if (!db) {
        clearTimeout(timeoutId);
        return res.status(404).json({ 
          success: false,
          error: 'Connection not found',
          message: `No valid connection found with ID: ${id}`
        });
      }
      
      // Parse filter, sort, and other parameters
      const sort = queryBuilder.parseRawSort(sortParam);
      const filter = queryBuilder.parseRawFilter(filterParam);
      
      // Get table schema to determine date fields and searchable columns
      let columns;
      try {
        columns = db.prepare(`PRAGMA table_info("${table}")`).all();
      } catch (err) {
        console.error(`Error getting column info: ${err.message}`);
        throw new Error(`Error getting column info: ${err.message}`);
      }
      
      // Extract column names for search if needed
      const columnNames = columns.map(col => col.name);
      
      // Build the appropriate query based on parameters
      let query;
      let countQuery;
      
      // Handle text search if requested
      if (search && search.trim()) {
        // Parse searchColumns parameter
        let searchableColumns = [];
        if (searchColumns) {
          try {
            // Try parsing as JSON array
            searchableColumns = JSON.parse(searchColumns);
          } catch (e) {
            // Fall back to comma-separated list
            searchableColumns = searchColumns.split(',').map(col => col.trim());
          }
          
          // Validate that all columns exist in the table
          searchableColumns = searchableColumns.filter(col => columnNames.includes(col));
        }
        
        // If no valid search columns specified, use all text-like columns
        if (searchableColumns.length === 0) {
          searchableColumns = columns
            .filter(col => {
              const type = col.type.toUpperCase();
              return type.includes('TEXT') || type.includes('CHAR') || type.includes('VARCHAR');
            })
            .map(col => col.name);
        }
        
        // If we have columns to search in, use text search query
        if (searchableColumns.length > 0) {
          query = queryBuilder.buildTextSearchQuery(table, searchableColumns, search, {
            page: parseInt(page),
            limit: parseInt(limit),
            sort,
            filter
          });
          
          // Build count query with the same WHERE clause but without pagination
          const whereConditions = searchableColumns.map(() => '?');
          const whereParams = Array(searchableColumns.length).fill(`%${search}%`);
          
          countQuery = {
            sql: `SELECT COUNT(*) as count FROM "${table}" WHERE (${searchableColumns.map(col => `"${col}" LIKE ?`).join(' OR ')})`,
            params: whereParams
          };
          
          // Add filter conditions to count query if needed
          if (filter && Object.keys(filter).length > 0) {
            const filterClause = queryBuilder.parseFilters(filter);
            if (filterClause.where !== '1=1') {
              countQuery.sql += ` AND (${filterClause.where})`;
              countQuery.params.push(...filterClause.params);
            }
          }
        } else {
          // Fall back to regular query if no text columns found
          query = queryBuilder.buildPaginatedSelectQuery(table, ['*'], {
            page: parseInt(page),
            limit: parseInt(limit),
            sort,
            filter
          });
          
          countQuery = queryBuilder.buildCountQuery(table, filter);
        }
      }
      // Handle date range filtering if requested
      else if (dateRange && dateColumn && columnNames.includes(dateColumn)) {
        let dateRangeObj;
        try {
          dateRangeObj = JSON.parse(dateRange);
        } catch (e) {
          console.warn(`Invalid date range: ${dateRange}`);
          dateRangeObj = {};
        }
        
        const { start, end } = dateRangeObj;
        
        if (start || end) {
          query = queryBuilder.buildDateRangeQuery(table, dateColumn, start, end, {
            page: parseInt(page),
            limit: parseInt(limit),
            sort,
            filter
          });
          
          // Build a count query with the same WHERE clause
          countQuery = {
            sql: `SELECT COUNT(*) as count FROM "${table}" WHERE `,
            params: []
          };
          
          if (start && end) {
            countQuery.sql += `"${dateColumn}" BETWEEN ? AND ?`;
            countQuery.params.push(start, end);
          } else if (start) {
            countQuery.sql += `"${dateColumn}" >= ?`;
            countQuery.params.push(start);
          } else if (end) {
            countQuery.sql += `"${dateColumn}" <= ?`;
            countQuery.params.push(end);
          } else {
            countQuery.sql += '1=1';
          }
          
          // Add filter conditions if needed
          if (filter && Object.keys(filter).length > 0) {
            const filterClause = queryBuilder.parseFilters(filter);
            if (filterClause.where !== '1=1') {
              countQuery.sql += ` AND (${filterClause.where})`;
              countQuery.params.push(...filterClause.params);
            }
          }
        } else {
          // Fall back to regular query if no valid date range
          query = queryBuilder.buildPaginatedSelectQuery(table, ['*'], {
            page: parseInt(page),
            limit: parseInt(limit),
            sort,
            filter
          });
          
          countQuery = queryBuilder.buildCountQuery(table, filter);
        }
      }
      // Regular query with standard filtering and pagination
      else {
        query = queryBuilder.buildPaginatedSelectQuery(table, ['*'], {
          page: parseInt(page),
          limit: parseInt(limit),
          sort,
          filter
        });
        
        countQuery = queryBuilder.buildCountQuery(table, filter);
      }
      
      // Execute count query first to get total using synchronous API
      let countResult;
      try {
        countResult = db.prepare(countQuery.sql).get(...countQuery.params) || { count: 0 };
      } catch (err) {
        throw new Error(`Error executing count query: ${err.message}`);
      }
      
      // Now execute the main data query using synchronous API
      let data;
      try {
        data = db.prepare(query.sql).all(...query.params);
      } catch (err) {
        throw new Error(`Error executing data query: ${err.message}`);
      }
      
      // Clear the timeout as we've completed the operation
      clearTimeout(timeoutId);
      
      // Return the results
      res.json({
        success: true,
        data: data,
        meta: {
          total: countResult.count,
          page: parseInt(page),
          limit: parseInt(limit),
          totalPages: Math.ceil(countResult.count / parseInt(limit))
        }
      });
    } catch (error) {
      clearTimeout(timeoutId);
      console.error(`Error getting data for table ${table}:`, error);
      
      if (!res.headersSent) {
        res.status(500).json({
          success: false,
          error: 'Failed to retrieve table data',
          message: error.message
        });
      }
    }
  }
);

/**
 * GET /api/connections/:id/tables/:table/data/sample
 * Get a sample of table data
 */
router.get('/:table/data/sample', 
  validateParams(tableNameSchema),
  validateQuery(sampleQuerySchema),
  async (req, res, next) => {
    const { id, table } = req.params;
    const { limit = 10 } = req.query;
    
    try {
      // Get database connection directly
      const db = await connectionService.getConnection(id);
      
      if (!db) {
        return res.status(404).json({ 
          success: false,
          error: 'Connection not found',
          message: `No valid connection found with ID: ${id}`
        });
      }
      
      // Use the sample query builder from the enhanced query builder
      const sampleQuery = queryBuilder.buildSampleQuery(table, parseInt(limit));
      
      // Execute the sample query using synchronous API
      let data;
      try {
        data = db.prepare(sampleQuery.sql).all(...sampleQuery.params);
      } catch (err) {
        throw new Error(`Error executing sample query: ${err.message}`);
      }
      
      // Get total count using query builder
      const countQuery = queryBuilder.buildCountQuery(table);
      let countResult;
      try {
        countResult = db.prepare(countQuery.sql).get(...countQuery.params) || { count: 0 };
      } catch (err) {
        console.warn(`Error counting rows for ${table}: ${err.message}`);
        countResult = { count: 0 };
      }
      
      // Return the sample
      res.json({
        success: true,
        data: data,
        meta: {
          totalRows: countResult.count,
          sampleSize: data.length,
          columns: data.length > 0 ? Object.keys(data[0]) : []
        }
      });
    } catch (error) {
      console.error(`Error getting sample data for table ${table}:`, error);
      
      if (!res.headersSent) {
        res.status(500).json({
          success: false,
          error: 'Failed to retrieve table sample',
          message: error.message
        });
      }
    }
  }
);

/**
 * GET /api/connections/:id/tables/:table/search
 * Search for text across multiple columns
 */
router.get('/:table/search', 
  validateParams(tableNameSchema),
  async (req, res, next) => {
    const { id, table } = req.params;
    const { query, columns, page = 1, limit = 100 } = req.query;
    
    try {
      // Get database connection directly
      const db = await connectionService.getConnection(id);
      
      if (!db) {
        return res.status(404).json({ 
          success: false,
          error: 'Connection not found',
          message: `No valid connection found with ID: ${id}`
        });
      }
      
      // Validate search query
      if (!query || query.trim() === '') {
        return res.status(400).json({
          success: false,
          error: 'Invalid search query',
          message: 'Search query is required'
        });
      }
      
      // Get table columns to determine which ones to search using synchronous API
      let tableColumns;
      try {
        tableColumns = db.prepare(`PRAGMA table_info("${table}")`).all();
      } catch (err) {
        throw new Error(`Error getting table columns: ${err.message}`);
      }
      
      // Parse columns parameter
      let searchColumns = [];
      if (columns) {
        try {
          // Try parsing as JSON array
          searchColumns = JSON.parse(columns);
        } catch (e) {
          // Fall back to comma-separated list
          searchColumns = columns.split(',').map(col => col.trim());
        }
        
        // Validate that all columns exist in the table
        const columnNames = tableColumns.map(col => col.name);
        searchColumns = searchColumns.filter(col => columnNames.includes(col));
      }
      
      // If no valid search columns specified, use all text-like columns
      if (searchColumns.length === 0) {
        searchColumns = tableColumns
          .filter(col => {
            const type = col.type.toUpperCase();
            return type.includes('TEXT') || type.includes('CHAR') || type.includes('VARCHAR');
          })
          .map(col => col.name);
      }
      
      // Build search query if we have columns to search in
      if (searchColumns.length === 0) {
        return res.status(400).json({
          success: false,
          error: 'No searchable columns',
          message: 'This table has no text columns that can be searched'
        });
      }
      
      // Build and execute search query
      const searchQuery = queryBuilder.buildTextSearchQuery(
        table, 
        searchColumns, 
        query, 
        {
          page: parseInt(page),
          limit: parseInt(limit)
        }
      );
      
      // Execute search query using synchronous API
      let data;
      try {
        data = db.prepare(searchQuery.sql).all(...searchQuery.params);
      } catch (err) {
        throw new Error(`Error executing search query: ${err.message}`);
      }
      
      // Build and execute count query
      const countQuery = {
        sql: `SELECT COUNT(*) as count FROM "${table}" WHERE (${searchColumns.map(col => `"${col}" LIKE ?`).join(' OR ')})`,
        params: Array(searchColumns.length).fill(`%${query}%`)
      };
      
      let countResult;
      try {
        countResult = db.prepare(countQuery.sql).get(...countQuery.params) || { count: 0 };
      } catch (err) {
        throw new Error(`Error executing count query: ${err.message}`);
      }
      
      // Return the search results
      res.json({
        success: true,
        data: data,
        meta: {
          query: query,
          searchedColumns: searchColumns,
          total: countResult.count,
          page: parseInt(page),
          limit: parseInt(limit),
          totalPages: Math.ceil(countResult.count / parseInt(limit))
        }
      });
    } catch (error) {
      console.error(`Error searching table ${table}:`, error);
      
      if (!res.headersSent) {
        res.status(500).json({
          success: false,
          error: 'Failed to search table',
          message: error.message
        });
      }
    }
  }
);

/**
 * GET /api/connections/:id/tables/:table/operators
 * Get the list of supported query operators
 */
router.get('/:table/operators', (req, res) => {
  try {
    const operators = queryBuilder.getSupportedOperators();
    
    res.json({
      success: true,
      data: operators
    });
  } catch (error) {
    console.error('Error getting operators:', error);
    
    res.status(500).json({
      success: false,
      error: 'Failed to get operators',
      message: error.message
    });
  }
});

module.exports = router;
</file>

<file path="server/services/appDbService.js">
/**
 * Application Database Service
 * 
 * Handles operations on the application's own SQLite database
 * which stores connections, saved visualizations, and templates
 */

const path = require('path');
const fs = require('fs');
const Database = require('better-sqlite3');

let db = null;

/**
 * Initialize the application database
 */
function initializeDatabase() {
  try {
    // Ensure the data directory exists
    const dataDir = path.join(__dirname, '../../data');
    if (!fs.existsSync(dataDir)) {
      fs.mkdirSync(dataDir, { recursive: true });
    }
    
    // Create a file-based database
    const dbPath = path.join(dataDir, 'app_database.sqlite');
    db = new Database(dbPath, { verbose: process.env.NODE_ENV === 'development' ? console.log : undefined });
    console.log(`Using SQLite database at: ${dbPath}`);
    
    // Enable foreign keys for data integrity
    db.pragma('foreign_keys = ON');
    
    // Create the tables if they don't exist
    createTablesIfNotExist();
    
    // Seed the database with default templates
    seedDefaultTemplates();
    
    return db;
  } catch (error) {
    console.error('Error initializing the application database:', error);
    
    // More specific error handling for better-sqlite3 issues
    if (error.code === 'ERR_DLOPEN_FAILED') {
      console.error('SQLite module failed to load. Try running "npm rebuild better-sqlite3"');
    }
    
    // If we're in production, try to gracefully degrade instead of crashing
    if (process.env.NODE_ENV === 'production') {
      console.warn('Attempting to continue without database functionality. Some features may be limited.');
      return null;
    }
    
    throw error;
  }
}

/**
 * Create required tables if they don't exist
 */
function createTablesIfNotExist() {
  // Create tables using better-sqlite3 API
  db.exec(`
    CREATE TABLE IF NOT EXISTS connections (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      path TEXT NOT NULL,
      last_accessed TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      size_bytes INTEGER,
      table_count INTEGER,
      is_valid BOOLEAN DEFAULT 1
    );

    CREATE TABLE IF NOT EXISTS saved_visualizations (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      connection_id INTEGER,
      name TEXT NOT NULL,
      type TEXT NOT NULL,
      config TEXT NOT NULL,
      table_name TEXT,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (connection_id) REFERENCES connections(id) ON DELETE CASCADE
    );

    CREATE TABLE IF NOT EXISTS insight_templates (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      description TEXT,
      type TEXT NOT NULL,
      config TEXT NOT NULL,
      category TEXT,
      is_default BOOLEAN DEFAULT 0
    );
  `);
}

/**
 * Seed the database with default templates
 */
function seedDefaultTemplates() {
  // First check if any templates already exist
  const templateCount = db.prepare('SELECT COUNT(*) as count FROM insight_templates').get();
  
  // If templates already exist, don't add defaults
  if (templateCount && templateCount.count > 0) {
    console.log('Templates already exist, skipping seed...');
    return;
  }
  
  // Define default templates
  const defaultTemplates = [
    {
      name: 'Top Selling Products',
      description: 'Visualizes your top selling products by revenue or quantity',
      type: 'bar',
      config: JSON.stringify({
        title: 'Top Selling Products',
        mappings: {
          x: 'product_name',
          y: 'revenue',
          sort: 'desc',
          limit: 10
        }
      }),
      category: 'sales',
      is_default: 1
    },
    {
      name: 'Monthly Sales Trend',
      description: 'Shows sales trends over monthly periods',
      type: 'line',
      config: JSON.stringify({
        title: 'Monthly Sales Trend',
        mappings: {
          x: 'month',
          y: 'revenue',
          groupBy: 'month'
        }
      }),
      category: 'sales',
      is_default: 1
    },
    {
      name: 'Customer Distribution',
      description: 'Breaks down customers by region or category',
      type: 'pie',
      config: JSON.stringify({
        title: 'Customer Distribution',
        mappings: {
          labels: 'region',
          values: 'customer_count'
        }
      }),
      category: 'customers',
      is_default: 1
    }
  ];
  
  // Use transaction for better performance and atomicity
  const insertStmt = db.prepare(`
    INSERT INTO insight_templates 
    (name, description, type, config, category, is_default)
    VALUES (?, ?, ?, ?, ?, ?)
  `);
  
  // Begin transaction
  const transaction = db.transaction(() => {
    for (const template of defaultTemplates) {
      insertStmt.run(
        template.name,
        template.description,
        template.type,
        template.config,
        template.category,
        template.is_default
      );
    }
  });
  
  // Execute transaction
  transaction();
  console.log(`Added ${defaultTemplates.length} default templates`);
}

/**
 * Get database connection
 */
function getDb() {
  if (!db) {
    try {
      return initializeDatabase();
    } catch (error) {
      console.error('Failed to initialize database on demand:', error);
      throw new Error('Database service is unavailable. Please restart the application.');
    }
  }
  return db;
}

/**
 * Close database connection
 */
function closeDatabase() {
  if (db) {
    db.close();
    db = null;
  }
}

/**
 * Helper for running parameterized queries
 */
function run(sql, params = []) {
  try {
    const dbInstance = getDb();
    if (!dbInstance) {
      throw new Error('Database is not initialized');
    }
    
    const stmt = dbInstance.prepare(sql);
    const result = stmt.run(...params);
    
    return {
      lastID: result.lastInsertRowid,
      changes: result.changes
    };
  } catch (error) {
    console.error(`SQL Error in run: ${sql}`, error);
    
    // Create a more descriptive error
    const enhancedError = new Error(`Database operation failed: ${error.message}`);
    enhancedError.originalError = error;
    enhancedError.sql = sql;
    enhancedError.params = params;
    
    throw enhancedError;
  }
}

/**
 * Helper for getting a single row
 */
function get(sql, params = []) {
  try {
    const dbInstance = getDb();
    if (!dbInstance) {
      throw new Error('Database is not initialized');
    }
    
    return dbInstance.prepare(sql).get(...params);
  } catch (error) {
    console.error(`SQL Error in get: ${sql}`, error);
    
    // Create a more descriptive error
    const enhancedError = new Error(`Database query failed: ${error.message}`);
    enhancedError.originalError = error;
    enhancedError.sql = sql;
    enhancedError.params = params;
    
    throw enhancedError;
  }
}

/**
 * Helper for getting all rows
 */
function all(sql, params = []) {
  try {
    const dbInstance = getDb();
    if (!dbInstance) {
      throw new Error('Database is not initialized');
    }
    
    return dbInstance.prepare(sql).all(...params);
  } catch (error) {
    console.error(`SQL Error in all: ${sql}`, error);
    
    // Create a more descriptive error
    const enhancedError = new Error(`Database query failed: ${error.message}`);
    enhancedError.originalError = error;
    enhancedError.sql = sql;
    enhancedError.params = params;
    
    throw enhancedError;
  }
}

// Initialize database on module load
initializeDatabase();

module.exports = {
  getDb,
  closeDatabase,
  run,
  get,
  all
};
</file>

<file path="server/services/databaseService.js">
/**
 * Database Service
 * 
 * Handles database operations, querying, and data transformation
 */

const connectionService = require('./connectionService');

/**
 * Get all tables in a database
 * @param {string} connectionId - Connection ID
 * @returns {Promise<Array>} Array of table information objects
 * @throws {Error} If tables cannot be retrieved
 */
async function getAllTables(connectionId) {
  try {
    // Get database connection
    const db = await connectionService.getConnection(connectionId);
    
    if (!db) {
      throw new Error(`Database connection not available for ID: ${connectionId}`);
    }
    
    // Query for tables (excluding SQLite system tables)
    let tables = [];
    
    try {
      // Using callback style for sqlite3
      tables = await new Promise((resolve, reject) => {
        db.all(
          `SELECT 
            name,
            type,
            sql as creation_sql
          FROM 
            sqlite_master 
          WHERE 
            type = 'table' AND 
            name NOT LIKE 'sqlite_%'
          ORDER BY 
            name`,
          [], 
          (err, results) => {
            if (err) {
              reject(err);
            } else {
              resolve(results || []);
            }
          }
        );
      });
    } catch (error) {
      console.error(`Error querying tables: ${error.message}`);
      return [];
    }
    
    // Add row count to each table
    const tablesWithCount = [];
    
    for (const table of tables) {
      // Skip if table is null or doesn't have a name
      if (!table || !table.name) {
        console.warn('Found a table entry without a name, skipping');
        continue;
      }
      
      try {
        // Get row count safely using callback style
        const countResult = await new Promise((resolve, reject) => {
          db.get(
            `SELECT COUNT(*) as count FROM "${table.name}"`,
            [],
            (err, result) => {
              if (err) {
                reject(err);
              } else {
                resolve(result || { count: 0 });
              }
            }
          );
        });
        
        tablesWithCount.push({
          name: table.name,
          type: table.type,
          creation_sql: table.creation_sql,
          row_count: countResult.count || 0
        });
      } catch (error) {
        console.error(`Error getting row count for table ${table.name}:`, error);
        
        // Still add the table, but with a count of 0 and an error indicator
        tablesWithCount.push({
          name: table.name,
          type: table.type,
          creation_sql: table.creation_sql,
          row_count: 0,
          error: 'Failed to count rows'
        });
      }
    }
    
    return tablesWithCount;
  } catch (error) {
    console.error(`Error retrieving tables for connection ${connectionId}:`, error);
    throw new Error(`Failed to retrieve tables: ${error.message}`);
  }
}

/**
 * Get schema for a specific table
 * @param {string} connectionId - Connection ID
 * @param {string} tableName - Table name
 * @returns {Promise<Object>} Table schema information
 * @throws {Error} If schema cannot be retrieved
 */
async function getTableSchema(connectionId, tableName) {
  try {
    // Get database connection
    const db = await connectionService.getConnection(connectionId);
    
    if (!db) {
      throw new Error(`Database connection not available for ID: ${connectionId}`);
    }
    
    // Safely escape table name
    if (!tableName || tableName.includes(';') || tableName.includes('--')) {
      throw new Error('Invalid table name');
    }
    
    // Get table info (column details)
    const columns = await new Promise((resolve, reject) => {
      db.all(`PRAGMA table_info("${tableName}")`, [], (err, results) => {
        if (err) {
          reject(err);
        } else {
          resolve(results || []);
        }
      });
    });
    
    if (columns.length === 0) {
      throw new Error(`Table '${tableName}' not found`);
    }
    
    // Get foreign key information
    const foreignKeys = await new Promise((resolve, reject) => {
      db.all(`PRAGMA foreign_key_list("${tableName}")`, [], (err, results) => {
        if (err) {
          reject(err);
        } else {
          resolve(results || []);
        }
      });
    });
    
    // Get index information
    const indices = await new Promise((resolve, reject) => {
      db.all(`PRAGMA index_list("${tableName}")`, [], (err, results) => {
        if (err) {
          reject(err);
        } else {
          resolve(results || []);
        }
      });
    });
    
    // Process index details
    const indexDetails = await Promise.all(indices.map(async (index) => {
      const columns = await new Promise((resolve, reject) => {
        db.all(`PRAGMA index_info("${index.name}")`, [], (err, results) => {
          if (err) {
            reject(err);
          } else {
            resolve(results || []);
          }
        });
      });
      return {
        ...index,
        columns: columns.map(col => ({
          name: col.name,
          position: col.seqno
        }))
      };
    }));
    
    // Format columns with additional info
    const formattedColumns = columns.map(column => {
      // Parse the column type
      const parsedType = require('../utils/dbUtils').parseColumnType(column.type);
      
      // Check if column is part of a primary key
      const isPrimaryKey = column.pk === 1;
      
      // Check if column is a foreign key
      const foreignKey = foreignKeys.find(fk => fk.from === column.name);
      
      return {
        name: column.name,
        type: column.type,
        ...parsedType,
        nullable: column.notnull === 0,
        defaultValue: column.dflt_value,
        primaryKey: isPrimaryKey,
        autoIncrement: isPrimaryKey && column.type.toUpperCase() === 'INTEGER',
        foreignKey: foreignKey ? {
          table: foreignKey.table,
          column: foreignKey.to
        } : null
      };
    });
    
    // Get table creation SQL
    const tableInfo = await new Promise((resolve, reject) => {
      db.get(
        `SELECT sql FROM sqlite_master WHERE type='table' AND name = ?`,
        [tableName],
        (err, result) => {
          if (err) {
            reject(err);
          } else {
            resolve(result);
          }
        }
      );
    });
    
    return {
      name: tableName,
      columns: formattedColumns,
      primaryKey: formattedColumns.filter(col => col.primaryKey).map(col => col.name),
      foreignKeys: foreignKeys.map(fk => ({
        column: fk.from,
        referencedTable: fk.table,
        referencedColumn: fk.to,
        onUpdate: fk.on_update,
        onDelete: fk.on_delete
      })),
      indices: indexDetails,
      sql: tableInfo ? tableInfo.sql : null
    };
  } catch (error) {
    console.error(`Error retrieving schema for table ${tableName}:`, error);
    throw new Error(`Failed to retrieve table schema: ${error.message}`);
  }
}

/**
 * Get data from a table with pagination
 * @param {string} connectionId - Connection ID
 * @param {string} tableName - Table name
 * @param {Object} options - Query options
 * @param {number} options.page - Page number (1-based)
 * @param {number} options.limit - Items per page
 * @param {Object} [options.sort] - Sort configuration { column, direction }
 * @param {Object} [options.filter] - Filter conditions
 * @returns {Promise<Object>} Paginated data
 * @throws {Error} If data cannot be retrieved
 */
async function getTableData(connectionId, tableName, options) {
  try {
    // Get database connection
    const db = await connectionService.getConnection(connectionId);
    
    if (!db) {
      throw new Error(`Database connection not available for ID: ${connectionId}`);
    }
    
    // Import the query builder
    const queryBuilder = require('../utils/queryBuilder');
    
    // Use the query builder to create the count query
    const countQuery = queryBuilder.buildCountQuery(tableName, options.filter);
    
    // Execute count query
    const countResult = await new Promise((resolve, reject) => {
      db.get(countQuery.sql, countQuery.params, (err, result) => {
        if (err) {
          reject(err);
        } else {
          resolve(result || { count: 0 });
        }
      });
    });
    
    const total = countResult.count;
    
    // Build the paginated select query
    const dataQuery = queryBuilder.buildPaginatedSelectQuery(
      tableName,
      ['*'],
      {
        page: options.page || 1,
        limit: options.limit || 100,
        sort: options.sort,
        filter: options.filter
      }
    );
    
    // Execute data query
    const data = await new Promise((resolve, reject) => {
      db.all(dataQuery.sql, dataQuery.params, (err, rows) => {
        if (err) {
          reject(err);
        } else {
          resolve(rows || []);
        }
      });
    });
    
    return {
      data,
      total,
      page: options.page || 1,
      limit: options.limit || 100,
      totalPages: Math.ceil(total / (options.limit || 100))
    };
  } catch (error) {
    console.error(`Error retrieving data from table ${tableName}:`, error);
    throw new Error(`Failed to retrieve table data: ${error.message}`);
  }
}

/**
 * Get a sample of data from a table
 * @param {string} connectionId - Connection ID
 * @param {string} tableName - Table name
 * @param {number} limit - Number of sample rows
 * @returns {Promise<Object>} Sample data
 * @throws {Error} If sample cannot be retrieved
 */
async function getTableSample(connectionId, tableName, limit = 10) {
  try {
    // Get database connection
    const db = await connectionService.getConnection(connectionId);
    
    if (!db) {
      throw new Error(`Database connection not available for ID: ${connectionId}`);
    }
    
    // Import the query builder
    const queryBuilder = require('../utils/queryBuilder');
    
    // Make sure limit is a number and reasonable
    const safeLimit = Math.min(Math.max(parseInt(limit) || 10, 1), 1000);
    
    // Build sample query
    const sampleQuery = queryBuilder.buildPaginatedSelectQuery(
      tableName,
      ['*'],
      { page: 1, limit: safeLimit }
    );
    
    // Query for a sample of data
    const data = await new Promise((resolve, reject) => {
      db.all(sampleQuery.sql, sampleQuery.params, (err, rows) => {
        if (err) {
          reject(err);
        } else {
          resolve(rows || []);
        }
      });
    });
    
    // Build and execute count query
    const countQuery = queryBuilder.buildCountQuery(tableName);
    const countResult = await new Promise((resolve, reject) => {
      db.get(countQuery.sql, countQuery.params, (err, result) => {
        if (err) {
          reject(err);
        } else {
          resolve(result || { count: 0 });
        }
      });
    });
    
    return {
      data,
      count: countResult.count,
      columns: data.length > 0 ? Object.keys(data[0]) : []
    };
  } catch (error) {
    console.error(`Error retrieving sample from table ${tableName}:`, error);
    throw new Error(`Failed to retrieve table sample: ${error.message}`);
  }
}

/**
 * Execute a custom query against a database
 * @param {string} connectionId - Connection ID
 * @param {string} query - SQL query to execute
 * @param {Array} params - Query parameters
 * @returns {Promise<Object>} Query results
 * @throws {Error} If query execution fails
 */
async function executeQuery(connectionId, query, params = []) {
  try {
    // Get database connection
    const db = await connectionService.getConnection(connectionId);
    
    if (!db) {
      throw new Error(`Database connection not available for ID: ${connectionId}`);
    }
    
    // Validate query is read-only
    const normalizedQuery = query.trim().toUpperCase();
    
    // Check for write operations
    if (
      normalizedQuery.startsWith('INSERT') ||
      normalizedQuery.startsWith('UPDATE') ||
      normalizedQuery.startsWith('DELETE') ||
      normalizedQuery.startsWith('DROP') ||
      normalizedQuery.startsWith('ALTER') ||
      normalizedQuery.startsWith('CREATE')
    ) {
      throw new Error('Write operations are not allowed');
    }
    
    // Execute the query
    let data = [];
    let columns = [];
    
    // Check if it's a SELECT query (returns data)
    if (normalizedQuery.startsWith('SELECT') || normalizedQuery.startsWith('PRAGMA')) {
      data = await new Promise((resolve, reject) => {
        db.all(query, params, (err, rows) => {
          if (err) {
            reject(err);
          } else {
            resolve(rows || []);
          }
        });
      });
      
      // Extract column names from first row
      if (data.length > 0) {
        columns = Object.keys(data[0]);
      }
    } else {
      // For non-SELECT queries (shouldn't happen due to the check above)
      // But we'll handle it gracefully just in case
      const result = await new Promise((resolve, reject) => {
        db.run(query, params, function(err) {
          if (err) {
            reject(err);
          } else {
            resolve({
              changes: this.changes,
              lastID: this.lastID
            });
          }
        });
      });
      
      data = [{ changes: result.changes, lastInsertRowid: result.lastID }];
      columns = ['changes', 'lastInsertRowid'];
    }
    
    return {
      data,
      columns
    };
  } catch (error) {
    console.error(`Error executing query:`, error);
    throw new Error(`Failed to execute query: ${error.message}`);
  }
}

/**
 * Get database statistics
 * @param {string} connectionId - Connection ID
 * @returns {Promise<Object>} Database statistics
 * @throws {Error} If statistics cannot be retrieved
 */
async function getDatabaseStats(connectionId) {
  try {
    // Get database connection
    const db = await connectionService.getConnection(connectionId);
    
    if (!db) {
      throw new Error(`Database connection not available for ID: ${connectionId}`);
    }
    
    // Get table count
    const tables = await getAllTables(connectionId);
    
    // Get total row count across all tables
    let totalRows = 0;
    for (const table of tables) {
      totalRows += table.row_count || 0;
    }
    
    // Get database file size
    const connection = await connectionService.getConnectionById(connectionId);
    
    return {
      tableCount: tables.length,
      totalRows,
      size: connection.size_bytes || 0,
      tables: tables.map(t => ({
        name: t.name,
        rows: t.row_count || 0
      }))
    };
  } catch (error) {
    console.error(`Error retrieving database stats:`, error);
    throw new Error(`Failed to retrieve database statistics: ${error.message}`);
  }
}

/**
 * Get aggregated data from a table based on specific columns
 * @param {string} connectionId - Connection ID
 * @param {string} tableName - Table name
 * @param {Object} options - Aggregation options
 * @param {Array} options.columns - Columns to select
 * @param {string|Array} options.groupBy - Column(s) to group by
 * @param {Object} options.filter - Filter conditions
 * @param {Object} options.having - Having conditions
 * @param {Object|Array} options.sort - Sort configuration
 * @param {number} options.limit - Maximum number of rows to return
 * @returns {Promise<Object>} Aggregated data
 * @throws {Error} If data cannot be retrieved
 */
async function getAggregatedData(connectionId, tableName, options) {
  try {
    // Get database connection
    const db = await connectionService.getConnection(connectionId);
    
    if (!db) {
      throw new Error(`Database connection not available for ID: ${connectionId}`);
    }
    
    // Import the query builder
    const queryBuilder = require('../utils/queryBuilder');
    
    // Build the aggregation query
    const query = queryBuilder.buildAggregationQuery(tableName, options);
    
    // Execute the query
    const data = await new Promise((resolve, reject) => {
      db.all(query.sql, query.params, (err, rows) => {
        if (err) {
          reject(err);
        } else {
          resolve(rows || []);
        }
      });
    });
    
    return {
      data,
      columns: data.length > 0 ? Object.keys(data[0]) : []
    };
  } catch (error) {
    console.error(`Error retrieving aggregated data from table ${tableName}:`, error);
    throw new Error(`Failed to retrieve aggregated data: ${error.message}`);
  }
}

module.exports = {
  getAllTables,
  getTableSchema,
  getTableData,
  getTableSample,
  executeQuery,
  getDatabaseStats,
  getAggregatedData
};
</file>

<file path="client/src/components/connection/ConnectionForm.tsx">
import { FC, useState } from 'react';
import { Connection } from '../../types';

interface ConnectionFormProps {
  onAddConnection: (connectionData: Omit<Connection, 'id'>) => Promise<void>;
}

/**
 * Connection Form Component
 * 
 * Form for creating new database connections
 */
const ConnectionForm: FC<ConnectionFormProps> = ({ onAddConnection }) => {
  const [name, setName] = useState('');
  const [path, setPath] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!name || !path) {
      setError('Name and path are required');
      return;
    }
    
    try {
      setLoading(true);
      setError(null);
      
      // Call the parent handler to add the connection
      await onAddConnection({ name, path });
      
      // Reset form on success
      setName('');
      setPath('');
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to add connection');
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <div className="bg-white p-6 rounded-md border border-slate-200">
      <h2 className="text-xl font-medium text-slate-900 mb-4">Add New Connection</h2>
      
      <form onSubmit={handleSubmit} className="space-y-4">
        {error && (
          <div className="p-3 bg-red-50 border border-red-200 rounded-md text-red-700 text-sm">
            {error}
          </div>
        )}
        
        <div className="space-y-1">
          <label className="block text-sm font-medium text-slate-700">
            Connection Name
          </label>
          <input
            type="text"
            value={name}
            onChange={(e) => setName(e.target.value)}
            className="w-full px-3 py-2 border border-slate-300 rounded-sm text-sm placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-primary focus:border-primary"
            placeholder="My Database"
          />
        </div>
        
        <div className="space-y-1">
          <label className="block text-sm font-medium text-slate-700">
            Database Path
          </label>
          <input
            type="text"
            value={path}
            onChange={(e) => setPath(e.target.value)}
            className="w-full px-3 py-2 border border-slate-300 rounded-sm text-sm placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-primary focus:border-primary"
            placeholder="/path/to/database.sqlite"
          />
          <p className="text-xs text-slate-500">
            Absolute path to the SQLite database file
          </p>
        </div>
        
        <button
          type="submit"
          className="w-full px-4 py-2 bg-primary text-white rounded text-sm font-medium hover:bg-primary-dark transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
          disabled={loading}
        >
          {loading ? 'Connecting...' : 'Connect Database'}
        </button>
      </form>
    </div>
  );
};

export default ConnectionForm;
</file>

<file path="client/src/pages/SavedVisualizations.tsx">
import { FC, useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { Visualization } from '../types';
import { visualizationApi, exportApi } from '../services/api';

/**
 * Saved Visualizations Page
 * 
 * Displays and manages saved visualizations
 */
const SavedVisualizations: FC = () => {
  const navigate = useNavigate();
  const [visualizations, setVisualizations] = useState<Visualization[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  
  useEffect(() => {
    // Fetch saved visualizations from API
    const fetchVisualizations = async () => {
      try {
        setLoading(true);
        const data = await visualizationApi.getAll();
        // Transform the API data to match the expected Visualization type
        const formattedData: Visualization[] = data.map(item => {
          // Handle config safely
          let config = {};
          try {
            config = typeof item.config === 'string' ? JSON.parse(item.config) : (item.config || {});
          } catch (parseError) {
            console.error(`Error parsing config for visualization ${item.id}:`, parseError);
          }
          
          return {
            id: item.id,
            name: item.name,
            type: item.type,
            connectionId: item.connectionId || item.connection_id || 0,
            tableName: item.tableName || item.table_name || '',
            config,
            createdAt: item.createdAt || item.created_at,
            updatedAt: item.updatedAt || item.updated_at
          };
        });
        setVisualizations(formattedData);
        setError(null);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to load visualizations');
      } finally {
        setLoading(false);
      }
    };
    
    fetchVisualizations();
  }, []);
  
  const handleDeleteVisualization = async (id: string | number) => {
    try {
      await visualizationApi.delete(id.toString());
      setVisualizations(visualizations.filter(viz => viz.id !== id));
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to delete visualization');
    }
  };
  
  const handleViewVisualization = (id: string | number) => {
    // Navigate to a separate view page or show a modal
    // For now, we'll simply alert
    alert(`Viewing visualization ${id}`);
  };
  
  const handleEditVisualization = (id: string | number) => {
    // Navigate to visualization builder with this visualization loaded
    navigate(`/visualize?edit=${id}`);
  };
  
  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h1 className="text-3xl font-semibold text-slate-900">Saved Visualizations</h1>
        <button
          className="px-4 py-2 bg-primary text-white rounded text-sm font-medium hover:bg-primary-dark transition-colors"
          onClick={() => navigate('/visualize')}
        >
          Create New Visualization
        </button>
      </div>
      
      {error && (
        <div className="p-4 bg-red-50 border border-red-200 rounded-md text-red-700">
          {error}
        </div>
      )}
      
      {loading ? (
        <div className="text-center p-6">
          <p className="text-slate-500">Loading visualizations...</p>
        </div>
      ) : visualizations.length > 0 ? (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {visualizations.map((visualization) => (
            <div key={visualization.id} className="bg-white p-6 rounded-md border border-slate-200 shadow-sm">
              <div className="h-48 bg-slate-100 mb-4 rounded flex items-center justify-center">
                {/* Placeholder for visualization preview */}
                <span className="text-slate-400">Chart Preview</span>
              </div>
              <h3 className="text-lg font-medium text-slate-900 mb-1">{visualization.name}</h3>
              <p className="text-sm text-slate-500 mb-4">
                {visualization.type} chart showing {visualization.tableName} data
              </p>
              <div className="flex space-x-2">
                <button 
                  className="px-3 py-1.5 text-xs bg-slate-100 text-slate-700 rounded hover:bg-slate-200"
                  onClick={() => handleViewVisualization(visualization.id)}
                >
                  View
                </button>
                <button 
                  className="px-3 py-1.5 text-xs bg-blue-50 text-blue-700 rounded hover:bg-blue-100"
                  onClick={() => handleEditVisualization(visualization.id)}
                >
                  Edit
                </button>
                <button 
                  className="px-3 py-1.5 text-xs bg-red-50 text-red-700 rounded hover:bg-red-100"
                  onClick={() => handleDeleteVisualization(visualization.id)}
                >
                  Delete
                </button>
              </div>
            </div>
          ))}
        </div>
      ) : (
        <div className="bg-white p-6 rounded-md border border-slate-200 text-center">
          <p className="text-slate-500 mb-4">No saved visualizations yet</p>
          <button
            className="px-4 py-2 bg-primary text-white rounded text-sm font-medium hover:bg-primary-dark transition-colors"
            onClick={() => navigate('/visualize')}
          >
            Create Your First Visualization
          </button>
        </div>
      )}
    </div>
  );
};

export default SavedVisualizations;
</file>

<file path="client/src/pages/VisualizationBuilder.tsx">
import { FC, useState, useEffect } from 'react';
import { useLocation, useSearchParams } from 'react-router-dom';
import ChartTypeSelector from '../components/visualization/ChartTypeSelector';
import FieldMapper from '../components/visualization/FieldMapper';
import ChartRenderer from '../components/visualization/ChartRenderer';
import { Connection, TableInfo, TableSchema, FieldMapping, ChartData } from '../types';
import { connectionApi, tableApi, visualizationApi } from '../services/api';

type ChartType = 'bar' | 'line' | 'pie' | 'doughnut' | 'scatter';

/**
 * Visualization Builder Page
 * 
 * Allows users to create custom visualizations from database data
 */
const VisualizationBuilder: FC = () => {
  // Get location state for template data passed from template application
  const location = useLocation();
  const [searchParams] = useSearchParams();
  
  // Get template-related parameters from the URL
  const templateId = searchParams.get('template');
  const connectionParam = searchParams.get('connection');
  const tableParam = searchParams.get('table');
  
  // Get template result from location state if available
  const templateResult = location.state?.templateResult;
  const templateMappings = location.state?.mappings;
  const templateSourceName = location.state?.sourceName;
  
  const [connections, setConnections] = useState<Connection[]>([]);
  const [selectedConnection, setSelectedConnection] = useState<string | null>(connectionParam || null);
  const [tables, setTables] = useState<TableInfo[]>([]);
  const [selectedTable, setSelectedTable] = useState<string | null>(tableParam || null);
  const [tableSchema, setTableSchema] = useState<TableSchema | null>(null);
  const [chartType, setChartType] = useState<ChartType>(
    templateResult?.type?.toLowerCase() as ChartType || 'bar'
  );
  const [fieldMappings, setFieldMappings] = useState<FieldMapping>(templateMappings || {});
  const [chartData, setChartData] = useState<ChartData | null>(templateResult?.data || null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [isFromTemplate, setIsFromTemplate] = useState<boolean>(!!templateResult);
  const [visualizationName, setVisualizationName] = useState<string>(
    templateSourceName ? `${templateSourceName} (from template)` : ''
  );
  
  useEffect(() => {
    // Fetch connections from API
    const fetchConnections = async () => {
      try {
        setLoading(true);
        const data = await connectionApi.getAll();
        setConnections(data);
        setError(null);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to load connections');
      } finally {
        setLoading(false);
      }
    };
    
    fetchConnections();
  }, []);
  
  useEffect(() => {
    // Fetch tables for the selected connection
    const fetchTables = async () => {
      if (!selectedConnection) return;
      
      try {
        setLoading(true);
        const data = await tableApi.getAll(selectedConnection);
        setTables(data);
        setError(null);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to load tables');
      } finally {
        setLoading(false);
      }
    };
    
    fetchTables();
  }, [selectedConnection]);
  
  useEffect(() => {
    // Fetch table schema for the selected table
    const fetchTableSchema = async () => {
      if (!selectedConnection || !selectedTable) return;
      
      try {
        setLoading(true);
        const schema = await tableApi.getSchema(selectedConnection, selectedTable);
        setTableSchema(schema);
        setError(null);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to load table schema');
      } finally {
        setLoading(false);
      }
    };
    
    fetchTableSchema();
  }, [selectedConnection, selectedTable]);
  
  useEffect(() => {
    // Skip this effect if we already have chart data from a template
    if (isFromTemplate && chartData && Object.keys(fieldMappings).length > 0 && !selectedTable) {
      return;
    }

    // Generate chart data based on field mappings
    const generateChartData = async () => {
      if (
        !selectedConnection || 
        !selectedTable || 
        !tableSchema || 
        Object.keys(fieldMappings).length === 0
      ) {
        return;
      }
      
      try {
        setLoading(true);
        
        // Get a sample of data from the table
        const sample = await tableApi.getSample(selectedConnection, selectedTable);
        
        // Parse field mappings for aggregations
        // Format: fieldName|aggregation (e.g., "sales|sum")
        const parsedMappings: Record<string, { field: string, aggregation?: string }> = {};
        
        Object.entries(fieldMappings).forEach(([key, value]) => {
          if (typeof value === 'string' && value.includes('|')) {
            const [field, aggregation] = value.split('|');
            parsedMappings[key] = { field, aggregation };
          } else {
            parsedMappings[key] = { field: value as string };
          }
        });
        
        // Apply aggregations if needed
        const processedData = applyAggregations(sample.data, parsedMappings, chartType);
        
        // Transform the data into a format suitable for Chart.js
        let chartData: ChartData;
        
        switch (chartType) {
          case 'bar':
          case 'line':
            chartData = processBarOrLineChartData(processedData, parsedMappings);
            break;
          case 'pie':
          case 'doughnut':
            chartData = processPieChartData(processedData, parsedMappings);
            break;
          case 'scatter':
            chartData = processScatterChartData(processedData, parsedMappings);
            break;
          default:
            chartData = processBarOrLineChartData(processedData, parsedMappings);
        }
        
        setChartData(chartData);
        setError(null);
      } catch (err) {
        console.error('Error generating chart data:', err);
        setError(err instanceof Error ? err.message : 'Failed to generate chart data');
      } finally {
        setLoading(false);
      }
    };
    
    generateChartData();
  }, [selectedConnection, selectedTable, chartType, fieldMappings, tableSchema, isFromTemplate, chartData]);
  
  // Helper function to apply aggregations to data
  const applyAggregations = (
    data: any[], 
    mappings: Record<string, { field: string, aggregation?: string }>,
    chartType: string
  ) => {
    // Return original data if no aggregations needed
    const hasAggregations = Object.values(mappings).some(m => m.aggregation && m.aggregation !== 'none');
    if (!hasAggregations) return data;
    
    // Determine grouping field based on chart type
    let groupByField = '';
    if (chartType === 'bar' || chartType === 'line') {
      groupByField = mappings.x?.field || '';
    } else if (chartType === 'pie' || chartType === 'doughnut') {
      groupByField = mappings.labels?.field || '';
    } else if (chartType === 'scatter') {
      // Scatter plots typically don't use aggregation, but we'll support it anyway
      return data;
    }
    
    if (!groupByField) return data;
    
    // Group data by the grouping field
    const groupedData: Record<string, any[]> = {};
    data.forEach(row => {
      const groupValue = String(row[groupByField] || '');
      if (!groupedData[groupValue]) {
        groupedData[groupValue] = [];
      }
      groupedData[groupValue].push(row);
    });
    
    // Apply aggregations to each group
    const result = Object.entries(groupedData).map(([groupValue, rows]) => {
      const resultRow: Record<string, any> = { [groupByField]: groupValue };
      
      // Apply aggregations for each mapping that has one
      Object.entries(mappings).forEach(([mappingKey, { field, aggregation }]) => {
        if (!aggregation || aggregation === 'none' || field === groupByField) {
          return;
        }
        
        // Extract numeric values for the field
        const values = rows
          .map(row => parseFloat(row[field]))
          .filter(value => !isNaN(value));
        
        // Apply the aggregation function
        let aggregatedValue = 0;
        switch (aggregation) {
          case 'sum':
            aggregatedValue = values.reduce((sum, value) => sum + value, 0);
            break;
          case 'avg':
            aggregatedValue = values.length > 0 
              ? values.reduce((sum, value) => sum + value, 0) / values.length 
              : 0;
            break;
          case 'min':
            aggregatedValue = values.length > 0 
              ? Math.min(...values) 
              : 0;
            break;
          case 'max':
            aggregatedValue = values.length > 0 
              ? Math.max(...values) 
              : 0;
            break;
          case 'count':
            aggregatedValue = values.length;
            break;
          default:
            aggregatedValue = 0;
        }
        
        resultRow[field] = aggregatedValue;
      });
      
      // Copy non-aggregated fields
      Object.entries(mappings).forEach(([mappingKey, { field, aggregation }]) => {
        if ((!aggregation || aggregation === 'none') && field !== groupByField) {
          // For non-aggregated fields, use the first row's value
          resultRow[field] = rows[0][field];
        }
      });
      
      return resultRow;
    });
    
    return result;
  };
  
  // Helper function to process data for bar or line charts
  const processBarOrLineChartData = (
    data: any[],
    mappings: Record<string, { field: string, aggregation?: string }>
  ): ChartData => {
    const xField = mappings.x?.field || '';
    const yField = mappings.y?.field || '';
    const colorField = mappings.color?.field;
    
    // Handle case with color field (creates multiple datasets)
    if (colorField) {
      // Group data by the color field
      const groupedByColor: Record<string, any[]> = {};
      data.forEach(row => {
        const colorValue = String(row[colorField] || 'Unknown');
        if (!groupedByColor[colorValue]) {
          groupedByColor[colorValue] = [];
        }
        groupedByColor[colorValue].push(row);
      });
      
      // Sort data by x-axis values for line charts (improves line rendering)
      if (chartType === 'line') {
        Object.keys(groupedByColor).forEach(colorValue => {
          groupedByColor[colorValue].sort((a, b) => {
            // Try to sort numerically first
            const numA = parseFloat(a[xField]);
            const numB = parseFloat(b[xField]);
            if (!isNaN(numA) && !isNaN(numB)) {
              return numA - numB;
            }
            // Fall back to string comparison
            return String(a[xField]).localeCompare(String(b[xField]));
          });
        });
      }
      
      // Get unique x values across all datasets
      const allXValues = Array.from(new Set(data.map(row => row[xField])));
      
      // Prepare datasets
      const datasets = Object.entries(groupedByColor).map(([colorValue, rows], index) => {
        const color = [
          '#2563EB', // blue-600
          '#D946EF', // fuchsia-500
          '#F59E0B', // amber-500
          '#10B981', // emerald-500
          '#6366F1', // indigo-500
          '#EF4444', // red-500
          '#8B5CF6', // violet-500
          '#EC4899', // pink-500
          '#06B6D4', // cyan-500
          '#84CC16'  // lime-500
        ][index % 10];
        
        return {
          label: colorValue,
          data: rows.map(row => parseFloat(row[yField]) || 0),
          backgroundColor: chartType === 'bar' ? color : `${color}33`,
          borderColor: color,
          borderWidth: 2,
          tension: chartType === 'line' ? 0.2 : undefined,
          fill: chartType === 'line' ? true : undefined
        };
      });
      
      return {
        labels: data.map(row => String(row[xField])),
        datasets
      };
    } 
    // Handle simple case (single dataset)
    else {
      // Sort data by x-axis values for line charts
      let processedData = [...data];
      if (chartType === 'line') {
        processedData.sort((a, b) => {
          // Try to sort numerically first
          const numA = parseFloat(a[xField]);
          const numB = parseFloat(b[xField]);
          if (!isNaN(numA) && !isNaN(numB)) {
            return numA - numB;
          }
          // Fall back to string comparison
          return String(a[xField]).localeCompare(String(b[xField]));
        });
      }
      
      const labels = processedData.map(row => String(row[xField]));
      const values = processedData.map(row => parseFloat(row[yField]) || 0);
      
      return {
        labels,
        datasets: [
          {
            label: yField,
            data: values,
            backgroundColor: chartType === 'bar' ? '#2563EB' : 'rgba(37, 99, 235, 0.2)',
            borderColor: chartType === 'line' ? '#2563EB' : undefined,
            borderWidth: 2,
            tension: chartType === 'line' ? 0.2 : undefined,
            fill: chartType === 'line' ? true : undefined
          }
        ]
      };
    }
  };
  
  // Helper function to process data for pie and doughnut charts
  const processPieChartData = (
    data: any[],
    mappings: Record<string, { field: string, aggregation?: string }>
  ): ChartData => {
    const labelsField = mappings.labels?.field || '';
    const valuesField = mappings.values?.field || '';
    
    const labels = data.map(row => String(row[labelsField]));
    const values = data.map(row => parseFloat(row[valuesField]) || 0);
    
    // Generate colors for each segment
    const baseColors = [
      '#2563EB', // blue-600
      '#D946EF', // fuchsia-500
      '#F59E0B', // amber-500
      '#10B981', // emerald-500
      '#6366F1', // indigo-500
      '#EF4444', // red-500
      '#8B5CF6', // violet-500
      '#EC4899', // pink-500
      '#06B6D4', // cyan-500
      '#84CC16'  // lime-500
    ];
    
    // Repeat colors if needed
    const colors = labels.map((_, i) => baseColors[i % baseColors.length]);
    
    return {
      labels,
      datasets: [
        {
          data: values,
          backgroundColor: colors,
          borderColor: '#FFFFFF',
          borderWidth: 2
        }
      ]
    };
  };
  
  // Helper function to process data for scatter charts
  const processScatterChartData = (
    data: any[],
    mappings: Record<string, { field: string, aggregation?: string }>
  ): ChartData => {
    const xField = mappings.x?.field || '';
    const yField = mappings.y?.field || '';
    const sizeField = mappings.size?.field;
    const colorField = mappings.color?.field;
    
    // Transform data for scatter chart
    // For scatter charts, we need to transform the data into a format that Chart.js expects
    if (colorField) {
      // Group data by the color field
      const groupedByColor: Record<string, any[]> = {};
      data.forEach(row => {
        const colorValue = String(row[colorField] || 'Unknown');
        if (!groupedByColor[colorValue]) {
          groupedByColor[colorValue] = [];
        }
        groupedByColor[colorValue].push(row);
      });
      
      // Create datasets for each color group
      const datasets = Object.entries(groupedByColor).map(([colorValue, rows], index) => {
        const color = [
          '#2563EB', // blue-600
          '#D946EF', // fuchsia-500
          '#F59E0B', // amber-500
          '#10B981', // emerald-500
          '#6366F1', // indigo-500
          '#EF4444', // red-500
          '#8B5CF6', // violet-500
          '#EC4899', // pink-500
          '#06B6D4', // cyan-500
          '#84CC16'  // lime-500
        ][index % 10];
        
        return {
          label: colorValue,
          data: rows.map(row => ({
            x: parseFloat(row[xField]) || 0,
            y: parseFloat(row[yField]) || 0,
            r: sizeField ? (parseFloat(row[sizeField]) / 5 || 3) : 5
          })),
          backgroundColor: `${color}88`,
          borderColor: color,
          borderWidth: 1
        };
      });
      
      return {
        labels: [],
        datasets
      };
    } else {
      // Single dataset for scatter
      return {
        labels: [],
        datasets: [
          {
            label: 'Data Points',
            data: data.map(row => ({
              x: parseFloat(row[xField]) || 0,
              y: parseFloat(row[yField]) || 0,
              r: sizeField ? (parseFloat(row[sizeField]) / 5 || 3) : 5
            })),
            backgroundColor: 'rgba(37, 99, 235, 0.6)',
            borderColor: '#2563EB',
            borderWidth: 1
          }
        ]
      };
    }
  };
  
  const handleConnectionChange = (connectionId: string) => {
    setSelectedConnection(connectionId);
    setSelectedTable(null);
    setTableSchema(null);
    setFieldMappings({});
    setChartData(null);
    setIsFromTemplate(false);
  };
  
  const handleTableChange = (tableName: string) => {
    setSelectedTable(tableName);
    
    // Only reset mappings if not from template
    if (!isFromTemplate) {
      setFieldMappings({});
      setChartData(null);
    } else {
      // If from template but table changed, no longer consider it from template
      setIsFromTemplate(tableName === tableParam);
    }
  };
  
  const handleChartTypeChange = (type: ChartType) => {
    setChartType(type);
    // Reset field mappings when changing chart type as they may be incompatible
    setFieldMappings({});
    setChartData(null);
    setIsFromTemplate(false);
  };
  
  const handleFieldMappingChange = (mappings: FieldMapping) => {
    setFieldMappings(mappings);
    // No longer consider from template if mappings changed
    if (isFromTemplate && JSON.stringify(mappings) !== JSON.stringify(templateMappings)) {
      setIsFromTemplate(false);
    }
  };
  
  const handleSaveVisualization = async () => {
    if (!selectedConnection || !selectedTable || !chartData) {
      setError('Cannot save visualization: missing data');
      return;
    }
    
    // Use custom name or generate one if empty
    if (!visualizationName.trim()) {
      setError('Please provide a name for the visualization');
      return;
    }
    
    try {
      setLoading(true);
      
      // Extract aggregation information from field mappings
      const parsedMappings: Record<string, { field: string, aggregation?: string }> = {};
      let hasAdvancedSettings = false;
      
      Object.entries(fieldMappings).forEach(([key, value]) => {
        if (typeof value === 'string' && value.includes('|')) {
          const [field, aggregation] = value.split('|');
          parsedMappings[key] = { field, aggregation };
          hasAdvancedSettings = true;
        } else {
          parsedMappings[key] = { field: value as string };
        }
      });
      
      // Create visualization data object with the structure expected by the API
      const visualizationData = {
        name: visualizationName,
        type: chartType,
        connectionId: parseInt(selectedConnection, 10),
        tableName: selectedTable,
        config: {
          mappings: fieldMappings,
          parsedMappings,
          chartType,
          isFromTemplate: isFromTemplate,
          templateId: templateId || undefined
        }
      };
      
      // Save to API
      const savedViz = await visualizationApi.create(visualizationData);
      
      // Show success message
      setError(null);
      
      // Show success message with some styling
      const successDiv = document.createElement('div');
      successDiv.className = 'fixed top-4 right-4 bg-green-50 border border-green-200 text-green-800 px-4 py-3 rounded shadow-md z-50';
      successDiv.innerHTML = `
        <div class="flex items-center">
          <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
          </svg>
          <span>Visualization "${visualizationName}" saved successfully!</span>
        </div>
      `;
      document.body.appendChild(successDiv);
      
      // Remove the success message after 3 seconds
      setTimeout(() => {
        document.body.removeChild(successDiv);
      }, 3000);
      
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to save visualization');
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h1 className="text-3xl font-semibold text-slate-900">Visualization Builder</h1>
      </div>
      
      {error && (
        <div className="p-4 bg-red-50 border border-red-200 rounded-md text-red-700">
          {error}
        </div>
      )}
      
      {isFromTemplate && (
        <div className="p-4 bg-blue-50 border border-blue-200 rounded-md">
          <div className="flex items-center">
            <svg className="w-5 h-5 mr-2 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <p className="text-blue-700">
              You're using the <strong>{templateSourceName}</strong> template. You can modify the settings below or save it as is.
            </p>
          </div>
        </div>
      )}
      
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Configuration Panel */}
        <div className="lg:col-span-1 space-y-6">
          {/* Connection and Table Selection */}
          <div className="bg-white p-6 rounded-md border border-slate-200">
            <h2 className="text-xl font-medium text-slate-900 mb-4">Data Source</h2>
            <div className="space-y-4">
              <div className="space-y-1">
                <label className="block text-sm font-medium text-slate-700">
                  Connection
                </label>
                <select
                  className="w-full px-3 py-2 border border-slate-300 rounded-sm text-sm"
                  value={selectedConnection || ''}
                  onChange={(e) => handleConnectionChange(e.target.value)}
                  disabled={loading || (isFromTemplate && !!templateResult)}
                >
                  <option value="">Select a connection</option>
                  {connections.map((connection) => (
                    <option key={connection.id} value={connection.id.toString()}>
                      {connection.name}
                    </option>
                  ))}
                </select>
              </div>
              
              {selectedConnection && (
                <div className="space-y-1">
                  <label className="block text-sm font-medium text-slate-700">
                    Table
                  </label>
                  <select
                    className="w-full px-3 py-2 border border-slate-300 rounded-sm text-sm"
                    value={selectedTable || ''}
                    onChange={(e) => handleTableChange(e.target.value)}
                    disabled={loading || tables.length === 0 || (isFromTemplate && !!templateResult)}
                  >
                    <option value="">Select a table</option>
                    {tables.map((table) => (
                      <option key={table.name} value={table.name}>
                        {table.name}
                      </option>
                    ))}
                  </select>
                </div>
              )}
            </div>
          </div>
          
          {/* Chart Type Selection */}
          <div className="bg-white p-6 rounded-md border border-slate-200">
            <h2 className="text-xl font-medium text-slate-900 mb-4">Chart Type</h2>
            <ChartTypeSelector 
              selected={chartType}
              onChange={handleChartTypeChange}
            />
          </div>
          
          {/* Field Mapping */}
          <div className="bg-white p-6 rounded-md border border-slate-200">
            <h2 className="text-xl font-medium text-slate-900 mb-4">Field Mapping</h2>
            {tableSchema ? (
              <FieldMapper 
                schema={tableSchema}
                chartType={chartType}
                mappings={fieldMappings}
                onChange={handleFieldMappingChange}
              />
            ) : isFromTemplate && templateResult ? (
              <div className="p-4 bg-green-50 border border-green-200 rounded-md">
                <p className="text-green-700">
                  Field mappings already configured from the template.
                </p>
              </div>
            ) : (
              <p className="text-slate-500">Select a table to map fields</p>
            )}
          </div>
        </div>
        
        {/* Chart Preview */}
        <div className="lg:col-span-2">
          <div className="bg-white p-6 rounded-md border border-slate-200 h-full">
            <div className="flex justify-between items-center mb-4">
              <h2 className="text-xl font-medium text-slate-900">Chart Preview</h2>
              {chartData && (
                <button
                  className="px-4 py-2 bg-blue-600 text-white rounded text-sm font-medium hover:bg-blue-700 transition-colors"
                  onClick={handleSaveVisualization}
                  disabled={loading}
                >
                  Save Visualization
                </button>
              )}
            </div>

            {/* Visualization Name Input */}
            {chartData && (
              <div className="mb-4">
                <label className="block text-sm font-medium text-slate-700 mb-1">
                  Visualization Name
                </label>
                <input
                  type="text"
                  className="w-full px-3 py-2 border border-slate-300 rounded-sm text-sm"
                  value={visualizationName}
                  onChange={(e) => setVisualizationName(e.target.value)}
                  placeholder="Enter a name for this visualization"
                />
                {isFromTemplate && (
                  <p className="text-xs text-slate-500 mt-1">
                    This visualization was created from the "{templateSourceName}" template
                  </p>
                )}
              </div>
            )}
            
            <div className="h-[500px] flex items-center justify-center">
              {loading ? (
                <div className="flex flex-col items-center justify-center">
                  <div className="w-8 h-8 border-4 border-blue-600 border-t-transparent rounded-full animate-spin"></div>
                  <p className="text-slate-500 mt-4">Loading chart data...</p>
                </div>
              ) : chartData ? (
                <ChartRenderer 
                  type={chartType}
                  data={chartData}
                />
              ) : (
                <div className="text-center p-4">
                  <p className="text-slate-500 mb-2">Select data source and map fields to generate a chart</p>
                  <p className="text-xs text-slate-400">Charts will update automatically as you configure them</p>
                </div>
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default VisualizationBuilder;
</file>

<file path="server/services/connectionService.js">
/**
 * Connection Service
 * 
 * Handles database connection management, storage, and health checks
 */

const Database = require('better-sqlite3');
const path = require('path');
const fs = require('fs');
const appDbService = require('./appDbService');
const dbUtils = require('../utils/dbUtils');
const connectionModel = require('../models/connection');

// Map of active connections to avoid creating duplicate connections
const activeConnections = new Map();

/**
 * Get all stored database connections
 * @returns {Promise<Array>} List of all database connections
 */
async function getAllConnections() {
  try {
    const connections = await connectionModel.findAll();
    return connections;
  } catch (error) {
    console.error('Error retrieving connections:', error);
    throw new Error('Failed to retrieve database connections');
  }
}

/**
 * Create a new database connection
 * @param {Object} connectionData - Connection details
 * @param {string} connectionData.name - Connection name
 * @param {string} connectionData.path - Path to SQLite database file
 * @returns {Promise<Object>} Created connection details
 * @throws {Error} If validation fails or connection cannot be established
 */
async function createConnection(connectionData) {
  try {
    console.log("Creating connection with data:", JSON.stringify(connectionData));
    
    // Validate connection parameters
    if (!connectionData.name) {
      const error = new Error('Connection name is required');
      error.statusCode = 400;
      throw error;
    }
    
    if (!connectionData.path) {
      const error = new Error('Database path is required');
      error.statusCode = 400;
      throw error;
    }
    
    // Normalize path to handle any OS-specific issues
    const normalizedPath = path.normalize(connectionData.path);
    console.log("Normalized path:", normalizedPath);
    
    // Check that the file exists
    try {
      const fileStats = fs.statSync(normalizedPath);
      if (!fileStats.isFile()) {
        const error = new Error(`Path exists but is not a file: ${normalizedPath}`);
        error.statusCode = 400;
        throw error;
      }
      console.log("File stats:", {
        size: fileStats.size,
        isFile: fileStats.isFile(),
        path: normalizedPath
      });
    } catch (fsError) {
      console.error("File system error:", fsError);
      if (fsError.code === 'ENOENT') {
        const error = new Error(`Database file not found at path: ${normalizedPath}`);
        error.statusCode = 404;
        error.code = 'ENOENT';
        error.path = normalizedPath;
        throw error;
      }
      // Rethrow with more context
      const error = new Error(`Error accessing database file: ${fsError.message}`);
      error.statusCode = 400;
      error.originalError = fsError;
      throw error;
    }
    
    // Validate that the file is a valid SQLite database
    console.log("Validating SQLite database...");
    const isValid = await dbUtils.validateDatabase(normalizedPath);
    if (!isValid) {
      const error = new Error(`Invalid SQLite database file: ${normalizedPath}`);
      error.statusCode = 400;
      throw error;
    }
    
    // Get database size and table count
    const sizeBytes = dbUtils.getDatabaseSize(normalizedPath);
    
    // Create a temporary connection to get table count
    console.log("Getting table count...");
    let tempDb;
    try {
      tempDb = new Database(normalizedPath, { readonly: true });
      const tableCount = dbUtils.getTableCount(tempDb);
      
      // Save connection to database
      console.log("Saving connection to app database...");
      const newConnection = await connectionModel.create({
        name: connectionData.name,
        path: normalizedPath,
        size_bytes: sizeBytes,
        table_count: tableCount,
        is_valid: true,
        last_accessed: new Date().toISOString()
      });
      
      // Close the temporary connection
      tempDb.close();
      
      console.log("Connection created successfully:", newConnection);
      return newConnection;
    } catch (dbError) {
      if (tempDb) {
        tempDb.close();
      }
      console.error("Database error during connection creation:", dbError);
      const error = new Error(`Database error: ${dbError.message}`);
      error.statusCode = 400;
      error.originalError = dbError;
      throw error;
    }
  } catch (error) {
    console.error('Error creating connection:', error);
    // Ensure the error has a status code
    if (!error.statusCode) {
      error.statusCode = 500;
    }
    throw error;
  }
}

/**
 * Get a connection by ID
 * @param {string} id - Connection ID
 * @returns {Promise<Object>} Connection details
 * @throws {Error} If connection not found
 */
async function getConnectionById(id) {
  try {
    const connection = await connectionModel.findById(id);
    
    if (!connection) {
      // Log this as a warning rather than an error for debugging
      console.warn(`Connection with ID ${id} not found in database`);
      throw new Error(`Connection with ID ${id} not found`);
    }
    
    // Update last accessed timestamp
    await connectionModel.update(id, {
      last_accessed: new Date().toISOString()
    });
    
    return connection;
  } catch (error) {
    console.error(`Error retrieving connection with ID ${id}:`, error);
    throw error;
  }
}

/**
 * Delete a connection
 * @param {string} id - Connection ID
 * @returns {Promise<boolean>} True if deletion was successful
 * @throws {Error} If deletion fails
 */
async function deleteConnection(id) {
  try {
    // Close active connection if it exists
    if (activeConnections.has(id)) {
      const conn = activeConnections.get(id);
      
      // Close the connection (better-sqlite3 just needs direct close call)
      conn.close();
      
      activeConnections.delete(id);
    }
    
    const result = await connectionModel.remove(id);
    
    if (!result) {
      throw new Error(`Failed to delete connection with ID ${id}`);
    }
    
    return true;
  } catch (error) {
    console.error(`Error deleting connection with ID ${id}:`, error);
    throw error;
  }
}

/**
 * Check database health and statistics
 * @param {string} id - Connection ID
 * @returns {Promise<Object>} Health statistics
 * @throws {Error} If health check fails
 */
async function checkDatabaseHealth(id) {
  try {
    // Get connection details
    const connection = await getConnectionById(id);
    
    if (!connection) {
      throw new Error(`Connection with ID ${id} not found`);
    }
    
    // Check that the file still exists
    if (!fs.existsSync(connection.path)) {
      // Update connection status
      await connectionModel.update(id, { is_valid: false });
      
      return {
        size_bytes: 0,
        table_count: 0,
        is_valid: false,
        last_checked: new Date().toISOString()
      };
    }
    
    // Get current database size
    const sizeBytes = dbUtils.getDatabaseSize(connection.path);
    
    // Create a temporary connection to get table count
    let isValid = true;
    let tableCount = 0;
    let tempDb;
    
    try {
      // Create a temporary connection using better-sqlite3
      tempDb = new Database(connection.path, { readonly: true });
      tableCount = dbUtils.getTableCount(tempDb);
      
      // Close the temporary connection
      tempDb.close();
    } catch (error) {
      console.error(`Error connecting to database at ${connection.path}:`, error);
      isValid = false;
      if (tempDb) {
        try {
          tempDb.close();
        } catch (closeError) {
          console.error(`Error closing database: ${closeError.message}`);
        }
      }
    }
    
    // Update connection in database
    await connectionModel.update(id, {
      size_bytes: sizeBytes,
      table_count: tableCount,
      is_valid: isValid
    });
    
    return {
      size_bytes: sizeBytes,
      table_count: tableCount,
      is_valid: isValid,
      last_checked: new Date().toISOString()
    };
  } catch (error) {
    console.error(`Error checking health for connection ${id}:`, error);
    throw error;
  }
}

/**
 * Get an active connection to a database
 * @param {string} id - Connection ID
 * @returns {Promise<Object>} SQLite database connection
 * @throws {Error} If connection cannot be established
 */
async function getConnection(id) {
  try {
    // Check if we already have an active connection
    if (activeConnections.has(id)) {
      return activeConnections.get(id);
    }
    
    // Get connection details
    const connection = await getConnectionById(id);
    
    if (!connection) {
      throw new Error(`Connection with ID ${id} not found`);
    }
    
    // Check if database file still exists
    if (!fs.existsSync(connection.path)) {
      // Update connection status
      await connectionModel.update(id, { is_valid: false });
      throw new Error(`Database file not found at path: ${connection.path}`);
    }
    
    // Create a better-sqlite3 database connection
    const db = new Database(connection.path, { readonly: true });
    
    // Store in active connections map
    activeConnections.set(id, db);
    
    // Update last accessed timestamp
    await connectionModel.update(id, {
      last_accessed: new Date().toISOString()
    });
    
    return db;
  } catch (error) {
    console.error(`Error getting connection for ID ${id}:`, error);
    throw error;
  }
}

module.exports = {
  getAllConnections,
  createConnection,
  getConnectionById,
  deleteConnection,
  checkDatabaseHealth,
  getConnection
};
</file>

<file path="client/src/components/connection/ConnectionList.tsx">
import { FC } from 'react';
import { Link } from 'react-router-dom';
import { Connection } from '../../types';

interface ConnectionListProps {
  connections: Connection[] | null;
  loading?: boolean;
  error?: string | null;
  onDeleteConnection: (id: string | number) => void;
}

/**
 * Connection List Component
 * 
 * Displays a list of database connections
 */
const ConnectionList: FC<ConnectionListProps> = ({ 
  connections = null, 
  loading = false, 
  error = null, 
  onDeleteConnection 
}) => {
  if (loading) {
    return (
      <div className="bg-white p-6 rounded-md border border-slate-200 text-center">
        <p className="text-slate-500">Loading connections...</p>
      </div>
    );
  }
  
  if (error) {
    return (
      <div className="p-4 bg-red-50 border border-red-200 rounded-md text-red-700">
        <p>Error: {error}</p>
      </div>
    );
  }
  
  if (!loading && (!connections || connections.length === 0)) {
    return (
      <div className="bg-white p-6 rounded-md border border-slate-200 text-center">
        <p className="text-slate-500">No connections yet. Add your first database connection.</p>
      </div>
    );
  }
  
  return (
    <div className="bg-white rounded-md border border-slate-200">
      <div className="p-4 border-b border-slate-200">
        <h2 className="text-lg font-medium text-slate-900">Your Connections</h2>
      </div>
      
      <ul className="divide-y divide-slate-200">
        {
          Array.isArray(connections) && connections.map((connection) => (
            <li key={connection.id} className="p-4">
              <div className="flex justify-between items-center">
                <div>
                  <h3 className="text-base font-medium text-slate-900">{connection.name}</h3>
                  <p className="text-sm text-slate-500">{connection.path}</p>
                  <div className="mt-1 flex items-center space-x-2">
                    <span className="inline-block px-2 py-0.5 bg-green-50 text-green-700 rounded-full text-xs">
                      {connection.is_valid ? 'Connected' : 'Disconnected'}
                    </span>
                    <span className="text-xs text-slate-400">
                      Last accessed: {connection.last_accessed ? new Date(connection.last_accessed).toLocaleString() : 'Never'}
                    </span>
                  </div>
                </div>
                <div className="flex items-center space-x-2">
                  <Link
                    to={`/connections/${connection.id}/tables`}
                    className="px-3 py-1.5 bg-primary-light text-primary rounded text-xs hover:bg-blue-100"
                  >
                    Open
                  </Link>
                  <button
                    className="px-3 py-1.5 bg-red-50 text-red-700 rounded text-xs hover:bg-red-100"
                    onClick={() => onDeleteConnection(connection.id)}
                  >
                    Delete
                  </button>
                </div>
              </div>
            </li>
          ))
        }
      </ul>
    </div>
  );
};

export default ConnectionList;
</file>

<file path="server/app.js">
/**
 * SQLite Visualizer - Main Server Application
 * 
 * This is the entry point for the SQLite Visualizer backend application.
 * It sets up Express, middleware, and routes.
 */

const express = require('express');
const path = require('path');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
const net = require('net');
const fs = require('fs');
const os = require('os');

// Import routes
const connectionsRoutes = require('./routes/connections');
const tablesRoutes = require('./routes/tables');
const visualizationsRoutes = require('./routes/visualizations');
const templatesRoutes = require('./routes/templates');
const exportRoutes = require('./routes/export');

// Import error handling middleware
const errorHandler = require('./middleware/errorHandler');

const app = express();
const DEFAULT_PORT = process.env.PORT || 8765;
const PORT_INFO_FILE = path.join(os.tmpdir(), 'sqlite-visualizer-server-port.txt');

/**
 * Checks if a port is in use
 * @param {number} port - The port to check
 * @returns {Promise<boolean>} - True if the port is available, false if it's in use
 */
const isPortAvailable = (port) => {
  return new Promise((resolve) => {
    const server = net.createServer();
    
    server.once('error', (err) => {
      if (err.code === 'EADDRINUSE') {
        resolve(false);
      } else {
        resolve(true);
      }
    });
    
    server.once('listening', () => {
      server.close();
      resolve(true);
    });
    
    server.listen(port);
  });
};

/**
 * Find an available port starting from the default port
 * @param {number} startPort - The port to start checking from
 * @returns {Promise<number>} - An available port
 */
const findAvailablePort = async (startPort) => {
  let port = startPort;
  const MAX_PORT = startPort + 50; // Don't check indefinitely
  
  while (port < MAX_PORT) {
    const available = await isPortAvailable(port);
    if (available) {
      return port;
    }
    port++;
  }
  
  // If we can't find a free port, return the original port and let the system handle the error
  console.warn(`Could not find an available port. Will try using the default port: ${startPort}`);
  return startPort;
};

// Middleware
app.use(cors({
  origin: function(origin, callback) {
    // Allow requests with no origin (like mobile apps or curl requests)
    if(!origin) return callback(null, true);
    return callback(null, true); // Allow all origins in development
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));

app.use(helmet({
  contentSecurityPolicy: false,
  crossOriginEmbedderPolicy: false
}));

// Add additional debugging for requests
app.use((req, res, next) => {
  console.log(`${req.method} ${req.url}`);
  if (req.body && Object.keys(req.body).length > 0) {
    console.log('Request body:', JSON.stringify(req.body));
  }
  next();
});
app.use(morgan('dev'));
app.use(express.json());
app.use(express.urlencoded({ extended: false }));

// Add a simple health check endpoint
app.get('/api/health', (req, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

// API Routes
app.use('/api/connections', connectionsRoutes);
app.use('/api/connections/:id/tables', tablesRoutes);
app.use('/api/visualizations', visualizationsRoutes);
app.use('/api/templates', templatesRoutes);
app.use('/api/export', exportRoutes);

// Serve static files in production
if (process.env.NODE_ENV === 'production') {
  app.use(express.static(path.join(__dirname, '../client/dist')));
  
  app.get('*', (req, res) => {
    res.sendFile(path.join(__dirname, '../client/dist/index.html'));
  });
}

// Error handling
app.use(errorHandler);

// Start server with graceful handling
let server = null;

const startServer = async () => {
  try {
    const availablePort = await findAvailablePort(DEFAULT_PORT);
    
    server = app.listen(availablePort, () => {
      console.log(`Server running on port ${availablePort}`);
      
      // Save the port to a file that can be read by other processes
      try {
        fs.writeFileSync(PORT_INFO_FILE, availablePort.toString());
      } catch (err) {
        console.warn('Failed to write port info file:', err);
      }
      
      // Export the actual port for the client to use
      process.env.ACTUAL_SERVER_PORT = availablePort.toString();
    });
    
    // Handle graceful shutdown
    const gracefulShutdown = () => {
      console.log('Received shutdown signal, closing server...');
      
      // Remove the port info file
      try {
        if (fs.existsSync(PORT_INFO_FILE)) {
          fs.unlinkSync(PORT_INFO_FILE);
        }
      } catch (err) {
        console.warn('Failed to remove port info file:', err);
      }
      
      server.close(() => {
        console.log('Server closed successfully');
        process.exit(0);
      });
      
      // Force close after 10s if graceful shutdown fails
      setTimeout(() => {
        console.error('Could not close connections in time, forcefully shutting down');
        process.exit(1);
      }, 10000);
    };
    
    // Listen for termination signals
    process.on('SIGTERM', gracefulShutdown);
    process.on('SIGINT', gracefulShutdown);
    
    return server;
  } catch (err) {
    console.error('Failed to start server:', err);
    process.exit(1);
  }
};

// Update the start-dev.js script to read the server port
const getServerPort = () => {
  try {
    if (fs.existsSync(PORT_INFO_FILE)) {
      const port = fs.readFileSync(PORT_INFO_FILE, 'utf8');
      return parseInt(port, 10);
    }
  } catch (err) {
    console.warn('Failed to read server port info file:', err);
  }
  
  return null;
};

// Export the getServerPort function for other modules to use
app.getServerPort = getServerPort;

// Start server if this file is run directly
if (require.main === module) {
  startServer();
}

module.exports = { app, startServer, getServerPort };
</file>

<file path="client/vite.config.ts">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'
import fs from 'fs'
import net from 'net'
import * as http from 'http'
import os from 'os'

// Check if a port is available
const isPortAvailable = (port: number): Promise<boolean> => {
  return new Promise((resolve) => {
    const server = net.createServer()

    server.once('error', (err: NodeJS.ErrnoException) => {
      if (err.code === 'EADDRINUSE') {
        resolve(false)
      } else {
        resolve(true)
      }
    })

    server.once('listening', () => {
      server.close()
      resolve(true)
    })

    server.listen(port)
  })
}

// Find an available port starting from the given port
const findAvailablePort = async (startPort: number): Promise<number> => {
  let port = startPort
  const MAX_PORT = startPort + 50 // Don't check indefinitely

  while (port < MAX_PORT) {
    const available = await isPortAvailable(port)
    if (available) {
      return port
    }
    port++
  }

  console.warn(`Could not find an available port. Will try using the default port: ${startPort}`)
  return startPort
}

// Get server port by checking if the server is running
const detectRunningServerPort = async (): Promise<number> => {
  // Try to read the port from the temp file written by the server
  const PORT_INFO_FILE = path.join(os.tmpdir(), 'sqlite-visualizer-server-port.txt')
  
  try {
    if (fs.existsSync(PORT_INFO_FILE)) {
      const port = fs.readFileSync(PORT_INFO_FILE, 'utf8')
      const portNumber = parseInt(port, 10)
      console.log(`Found server port ${portNumber} from info file`)
      return portNumber
    }
  } catch (err) {
    console.warn('Failed to read server port info file:', err)
  }
  
  // Default port from server's configuration
  const DEFAULT_SERVER_PORT = 8768
  
  console.log(`Using server port ${DEFAULT_SERVER_PORT}`)
  return DEFAULT_SERVER_PORT
}

// https://vitejs.dev/config/
export default defineConfig(async () => {
  const DEFAULT_CLIENT_PORT = 3001
  const availablePort = await findAvailablePort(DEFAULT_CLIENT_PORT)
  const serverPort = process.env.ACTUAL_SERVER_PORT 
    ? parseInt(process.env.ACTUAL_SERVER_PORT, 10) 
    : await detectRunningServerPort()

  console.log(`Client will run on port ${availablePort}`)
  console.log(`Proxying API requests to server on port ${serverPort}`)

  // Write port info to a temporary file that can be read by npm scripts
  fs.writeFileSync(
    path.resolve(__dirname, '.vite-port'),
    availablePort.toString()
  )

  return {
    plugins: [
      react({
        // Disable Fast Refresh to prevent React duplicate rendering in development
        fastRefresh: false
      })
    ],
    server: {
      port: availablePort,
      strictPort: false, // Allow Vite to find another port if specified one is in use
      hmr: {
        // Configure HMR for more stable updates
        overlay: false,
        port: availablePort
      },
      proxy: {
        '/api': {
          target: `http://localhost:${serverPort}`,
          changeOrigin: true,
        },
      },
    },
    resolve: {
      alias: {
        '@': path.resolve(__dirname, './src'),
      },
    },
    // Avoid potential rendering issues
    esbuild: {
      jsxInject: `import React from 'react'`
    },
    build: {
      // Improve the build process
      sourcemap: false,
      minify: 'terser',
      // Prevent duplicate bundling
      commonjsOptions: {
        include: [/node_modules/],
      }
    }
  }
})
</file>

<file path="client/src/services/api.ts">
/**
 * API Service
 * 
 * Handles all API requests to the backend
 */
import { Connection, Visualization, Template, ApiError } from '../types';

import { API_BASE_URL } from '../config';

const API_URL = API_BASE_URL.replace('/api', '');

// Log server connection status
(async function checkServerAvailability() {
  try {
    const response = await fetch(`${API_URL}/api/connections`);
    console.log(`Server connection check: ${response.status === 200 ? 'SUCCESS' : 'FAILED'} (${response.status})`);
  } catch (error) {
    console.error(`Server connection check FAILED: ${error.message}`);
    console.log(`Failed connecting to: ${API_URL}/api/connections`);
  }
})();

console.log('API Service Initialized:', {
  environment: process.env.NODE_ENV,
  apiBaseUrl: API_URL
});

/**
 * Make an API request
 * @param {string} endpoint - API endpoint
 * @param {Object} options - Fetch options
 * @returns {Promise<any>} - Response data
 */
async function apiRequest<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
  const url = `${API_URL}/api${endpoint}`;
  
  console.log(`Making API request to: ${url}`);
  
  const defaultHeaders = {
    'Content-Type': 'application/json',
    'Accept': 'application/json',
  };
  
  const config = {
    ...options,
    headers: {
      ...defaultHeaders,
      ...(options.headers || {}),
    },
  };
  
  // Log request details for debugging
  console.log(`API Request: ${config.method || 'GET'} ${url}`);
  if (config.body) {
    try {
      // Try to parse and log the request body if it's JSON
      const bodyObj = JSON.parse(config.body as string);
      console.log('Request body:', bodyObj);
    } catch (e) {
      // If it's not valid JSON, just log it as is
      console.log('Request body (raw):', config.body);
    }
  }
  
  try {
    // Make the fetch request
    const response = await fetch(url, config);
    console.log(`Received response from ${url} with status: ${response.status}`);
    
    // Try to parse the response as JSON
    let data;
    const contentType = response.headers.get('content-type');
    
    try {
      if (contentType && contentType.includes('application/json')) {
        const text = await response.text();
        console.log('Response text:', text.substring(0, 500) + (text.length > 500 ? '...' : ''));
        try {
          data = JSON.parse(text);
        } catch (jsonError) {
          console.error('Failed to parse JSON response:', jsonError);
          data = { message: text };
        }
      } else {
        // Handle non-JSON responses
        const text = await response.text();
        console.warn('Received non-JSON response:', text.substring(0, 500) + (text.length > 500 ? '...' : ''));
        data = { message: text };
      }
    } catch (parseError) {
      console.error('Error parsing response:', parseError);
      throw new Error(`Failed to parse server response: ${parseError.message}`);
    }
    
    // Handle error responses
    if (!response.ok) {
      console.error('Server returned error status:', response.status, data);
      const errorMessage = data && data.message 
        ? data.message 
        : `API error: ${response.status} ${response.statusText}`;
      
      const error = new Error(errorMessage) as ApiError;
      error.status = response.status;
      error.data = data;
      throw error;
    }
    
    // Return successful response data
    return data;
  } catch (error: any) {
    // Handle network errors
    if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
      console.error('Network error connecting to server:', error);
      const errorMsg = `Cannot connect to server at ${url}. Please check:
      1. Server is running (on port ${API_URL.split(':').pop()})
      2. Network connectivity
      3. CORS configuration`;
      
      throw new Error(errorMsg);
    }
    
    // Re-throw the error with enhanced context
    console.error('API request failed:', {
      url,
      method: config.method || 'GET',
      error: {
        name: error.name,
        message: error.message,
        status: error.status,
        data: error.data
      }
    });
    
    // If it's already an augmented API error, just rethrow it
    if (error.status) {
      throw error;
    }
    
    // Otherwise wrap in a more helpful error
    throw new Error(`API Error: ${error.message || 'Unknown error'}`);
  }
}

// Connection endpoints
export const connectionApi = {
  getAll: (): Promise<Connection[]> => 
    apiRequest<{data: Connection[]}>('/connections')
      .then(response => response.data),
  
  getById: (id: string | number): Promise<Connection> => 
    apiRequest<{data: Connection}>(`/connections/${id}`)
      .then(response => response.data),
  
  create: (connectionData: { name: string; path: string }): Promise<Connection> => 
    apiRequest<{data: Connection}>('/connections', {
      method: 'POST',
      body: JSON.stringify(connectionData),
    }).then(response => response.data),
  
  delete: (id: string | number): Promise<void> => 
    apiRequest<void>(`/connections/${id}`, {
      method: 'DELETE',
    }),
  
  checkHealth: (id: string | number): Promise<{
    size_bytes: number;
    table_count: number;
    is_valid: boolean;
    last_checked: string;
  }> => 
    apiRequest<{
      data: {
        size_bytes: number;
        table_count: number;
        is_valid: boolean;
        last_checked: string;
      }
    }>(`/connections/${id}/health`)
      .then(response => response.data),
};

// Table endpoints
export const tableApi = {
  getAll: (connectionId: string | number): Promise<{
    name: string;
    type: string;
  }[]> => 
    apiRequest<{
      data: {
        name: string;
        type: string;
      }[]
    }>(`/connections/${connectionId}/tables`)
      .then(response => response.data),
  
  getSchema: (connectionId: string | number, tableName: string): Promise<{
    columns: {
      name: string;
      type: string;
      nullable: boolean;
    }[];
  }> => 
    apiRequest<{
      data: {
        columns: {
          name: string;
          type: string;
          nullable: boolean;
        }[];
      }
    }>(`/connections/${connectionId}/tables/${tableName}/schema`)
      .then(response => response.data),
  
  getData: <T>(connectionId: string | number, tableName: string, params: Record<string, any> = {}): Promise<{
    data: T[];
    total: number;
    page: number;
    limit: number;
    totalPages: number;
  }> => {
    const queryParams = new URLSearchParams();
    Object.entries(params).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        queryParams.append(key, String(value));
      }
    });
    
    return apiRequest<{
      data: T[];
      total: number;
      page: number;
      limit: number;
      totalPages: number;
    }>(`/connections/${connectionId}/tables/${tableName}/data?${queryParams}`);
  },
  
  getSample: <T>(connectionId: string | number, tableName: string, limit = 10): Promise<{
    data: T[];
    count: number;
  }> => 
    apiRequest<{
      data: {
        data: T[];
        count: number;
      }
    }>(`/connections/${connectionId}/tables/${tableName}/data/sample?limit=${limit}`)
      .then(response => response.data),
};

// Visualization endpoints
export const visualizationApi = {
  getAll: (): Promise<Visualization[]> => 
    apiRequest<{data: Visualization[]}>('/visualizations')
      .then(response => response.data),
  
  getById: (id: string | number): Promise<Visualization> => 
    apiRequest<{data: Visualization}>(`/visualizations/${id}`)
      .then(response => response.data),
  
  create: (visualizationData: Omit<Visualization, 'id' | 'createdAt' | 'updatedAt'>): Promise<Visualization> => 
    apiRequest<{data: Visualization}>('/visualizations', {
      method: 'POST',
      body: JSON.stringify(visualizationData),
    }).then(response => response.data),
  
  update: (id: string | number, visualizationData: Partial<Omit<Visualization, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Visualization> => 
    apiRequest<{data: Visualization}>(`/visualizations/${id}`, {
      method: 'PUT',
      body: JSON.stringify(visualizationData),
    }).then(response => response.data),
  
  delete: (id: string | number): Promise<void> => 
    apiRequest<void>(`/visualizations/${id}`, {
      method: 'DELETE',
    }),
    
  /**
   * Get sample data for a visualization preview
   * @param connectionId - Database connection ID
   * @param tableName - Table name
   * @param mappings - Field mappings
   * @param limit - Max number of records to return (default: 20)
   */
  getSampleData: <T>(connectionId: string | number, tableName: string, mappings: Record<string, string>, limit: number = 20): Promise<T[]> => {
    try {
      // Create query params for field selection
      const fields = Object.values(mappings).filter(Boolean);
      
      // Define fields if they exist
      const params: Record<string, any> = { limit };
      if (fields.length > 0) {
        params.fields = fields.join(',');
      }
      
      // Use a simpler approach - just get sample data and return empty array on error
      return tableApi.getSample<T>(connectionId, tableName, limit)
        .then(response => response.data)
        .catch(error => {
          console.error('Error fetching sample data:', error);
          return [] as T[];
        });
    } catch (error) {
      console.error('Error in getSampleData:', error);
      return Promise.resolve([] as T[]);
    }
  },
  
  /**
   * Get full data for a visualization
   * @param connectionId - Database connection ID
   * @param tableName - Table name
   * @param mappings - Field mappings
   * @param limit - Max number of records to return (default: 500)
   */
  getFullData: <T>(connectionId: string | number, tableName: string, mappings: Record<string, string>, limit: number = 500): Promise<{
    data: T[];
    total: number;
  }> => {
    try {
      // Create query params for field selection and pagination
      const fields = Object.values(mappings).filter(Boolean);
      
      // Define query parameters
      const params: Record<string, any> = { limit, page: 1 };
      if (fields.length > 0) {
        params.fields = fields.join(',');
      }
      
      return tableApi.getData<T>(connectionId, tableName, params)
        .then(response => ({
          data: response.data,
          total: response.total
        }))
        .catch(error => {
          console.error('Error fetching full data:', error);
          return {
            data: [] as T[],
            total: 0
          };
        });
    } catch (error) {
      console.error('Error in getFullData:', error);
      return Promise.resolve({
        data: [] as T[],
        total: 0
      });
    }
  }
};

// Template endpoints
export const templateApi = {
  getAll: (filters?: Record<string, any>): Promise<Template[]> => {
    const queryParams = new URLSearchParams();
    if (filters) {
      Object.entries(filters).forEach(([key, value]) => {
        if (value !== undefined && value !== null) {
          queryParams.append(key, String(value));
        }
      });
    }
    
    const queryString = queryParams.toString() ? `?${queryParams.toString()}` : '';
    return apiRequest<{data: Template[]}>(`/templates${queryString}`)
      .then(response => response.data);
  },
  
  getById: (id: string | number): Promise<Template> => 
    apiRequest<{data: Template}>(`/templates/${id}`)
      .then(response => response.data),
  
  getRequirements: (id: string | number): Promise<{
    requiredFields: {name: string, label: string}[];
    optionalFields: {name: string, label: string}[];
    templateInfo: {
      name: string;
      description?: string;
      type: string;
      category?: string;
    };
  }> => 
    apiRequest<{
      data: {
        requiredFields: {name: string, label: string}[];
        optionalFields: {name: string, label: string}[];
        templateInfo: {
          name: string;
          description?: string;
          type: string;
          category?: string;
        };
      }
    }>(`/templates/${id}/requirements`)
      .then(response => response.data),
  
  getCategories: (): Promise<string[]> => 
    apiRequest<{data: string[]}>('/templates/categories')
      .then(response => response.data),
  
  create: (templateData: Omit<Template, 'id'>): Promise<Template> => 
    apiRequest<{data: Template}>('/templates', {
      method: 'POST',
      body: JSON.stringify(templateData),
    }).then(response => response.data),
  
  update: (id: string | number, templateData: Partial<Omit<Template, 'id'>>): Promise<Template> => 
    apiRequest<{data: Template}>(`/templates/${id}`, {
      method: 'PUT',
      body: JSON.stringify(templateData),
    }).then(response => response.data),
  
  delete: (id: string | number): Promise<void> => 
    apiRequest<void>(`/templates/${id}`, {
      method: 'DELETE',
    }),
  
  apply: (templateId: string | number, applicationData: {
    connectionId: number | string;
    tableNames: string | string[];
    mappings: Record<string, string>;
  }): Promise<{
    data: any;
    config: Record<string, any>;
    type: string;
  }> => 
    apiRequest<{
      data: {
        data: any;
        config: Record<string, any>;
        type: string;
      }
    }>(`/templates/${templateId}/apply`, {
      method: 'POST',
      body: JSON.stringify(applicationData),
    }).then(response => response.data),
};

// Export endpoints
export const exportApi = {
  getSupportedFormats: (): Promise<{
    id: string;
    name: string;
    extension: string;
    mimeType: string;
  }[]> => 
    apiRequest<{
      data: {
        id: string;
        name: string;
        extension: string;
        mimeType: string;
      }[]
    }>('/export/formats')
      .then(response => response.data),
  
  exportVisualization: (visualizationId: string | number, format: string = 'csv'): string => 
    `${API_URL}/api/export/${format}/${visualizationId}`,
  
  exportTable: (
    connectionId: string | number, 
    tableName: string, 
    options: { 
      format?: string;
      limit?: number;
      filter?: Record<string, any>;
      sort?: { column: string; direction: 'asc' | 'desc' };
      includeSchema?: boolean;
    } = {}
  ): string => {
    const { format = 'csv', limit, filter, sort, includeSchema } = options;
    
    // Build base URL
    let url = `${API_URL}/api/export/${format}/table/${connectionId}/${tableName}`;
    
    // Add query parameters
    const params = new URLSearchParams();
    
    if (limit) {
      params.append('limit', limit.toString());
    }
    
    if (filter && Object.keys(filter).length > 0) {
      params.append('filter', JSON.stringify(filter));
    }
    
    if (sort && sort.column) {
      params.append('sort', JSON.stringify(sort));
    }
    
    if (format === 'json' && includeSchema !== undefined) {
      params.append('includeSchema', includeSchema.toString());
    }
    
    // Append query parameters if any
    const queryString = params.toString();
    if (queryString) {
      url += `?${queryString}`;
    }
    
    return url;
  }
};

// Test server connection
export const testServerConnection = async (): Promise<boolean> => {
  try {
    const response = await fetch(`${API_URL}/api/health`);
    if (!response.ok) return false;
    const data = await response.json();
    return data?.status === 'ok';
  } catch (error) {
    console.error('Server connection test failed:', error);
    return false;
  }
};

export default {
  connectionApi,
  tableApi,
  visualizationApi,
  templateApi,
  exportApi,
  testServerConnection,
};
</file>

</files>
